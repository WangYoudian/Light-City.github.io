<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>C++ STL源码剖析之序列式容器deque</title>
      <link href="/2019/10/16/deque/"/>
      <url>/2019/10/16/deque/</url>
      
        <content type="html"><![CDATA[<h1 id="C-STL源码剖析之序列式容器deque"><a href="#C-STL源码剖析之序列式容器deque" class="headerlink" title="C++ STL源码剖析之序列式容器deque"></a>C++ STL源码剖析之序列式容器deque</h1><h2 id="0-导语"><a href="#0-导语" class="headerlink" title="0.导语"></a>0.导语</h2><p>deque是一种双向开口的分段连续线性空间(简单理解为：双端队列)，可以在头尾端进行元素的插入和删除。</p><p>deque与vector最大的差异就是：</p><ul><li><p>deque允许于常数时间内对头端进行插入或删除元素；</p></li><li><p>deque是分段连续线性空间，随时可以增加一段新的空间；</p></li></ul><p>deque不像vector那样，vector当内存不够时，需重新分配/复制数据/释放原始空间；不过deque的迭代器设置比vector复杂，因为迭代器不能使用普通指针，因此尽量使用vector。</p><h2 id="1-deque中控器"><a href="#1-deque中控器" class="headerlink" title="1.deque中控器"></a>1.deque中控器</h2><p>用户看起来deque使用的是连续空间，实际上是<strong>分段连续线性空间</strong>。为了管理分段空间deque容器引入了map，称之为中控器，map是一块连续的空间，其中每个元素是指向缓冲区的指针，缓冲区才是deque存储数据的主体。</p><p><img src="https://raw.githubusercontent.com/Light-City/cloudimg/master/deque_r.png" alt="deque_r.png"></p><p>在上图中，buffer称为缓冲区，显示map size的一段连续空间就是中控器。</p><p>中控器包含了map size,指向buffer的指针，deque的开始迭代器与结尾迭代器。</p><pre class=" language-cpp"><code class="language-cpp">_Tp        <span class="token operator">*</span><span class="token operator">*</span>_M_map<span class="token punctuation">;</span>size_t        _M_map_size<span class="token punctuation">;</span>iterator    _M_start<span class="token punctuation">;</span>iterator    _M_finish<span class="token punctuation">;</span></code></pre><p>由于buffer也是指针，所以<code>_Tp</code>是指针的指针。</p><p>deque继承自<code>_Deque_base</code>,而<code>_Deque_base</code>里面有一个<code>_M_impl</code>。</p><p><img src="https://raw.githubusercontent.com/Light-City/cloudimg/master/deque_bacse.png" alt="deque_base.png"></p><p>根据下图与上述描述，可以知道，中控器是由<code>_Deque_impl</code>实现的。</p><p><img src="https://raw.githubusercontent.com/Light-City/cloudimg/master/impl.png" alt="impl.png"></p><p>而deque是使用基类<code>_Deque_base</code>来完成内存管理与中控器管理。</p><h2 id="2-高端的迭代器"><a href="#2-高端的迭代器" class="headerlink" title="2.高端的迭代器"></a>2.高端的迭代器</h2><p>对于deque来说，它的迭代器设计的非常棒！</p><p>如下图所示：<br><img src="https://raw.githubusercontent.com/Light-City/cloudimg/master/deque_iterator.png" alt="deque_iterator.png"></p><p>首先来看一下比较重要的成员：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">typedef</span> _Tp                <span class="token operator">*</span><span class="token operator">*</span>_Map_pointer<span class="token punctuation">;</span>_Tp        <span class="token operator">*</span>_M_cur<span class="token punctuation">;</span>_Tp        <span class="token operator">*</span>_M_first<span class="token punctuation">;</span>_Tp        <span class="token operator">*</span>_M_last<span class="token punctuation">;</span>_Map_pointer    _M_node<span class="token punctuation">;</span></code></pre><p>这几个究竟是什么呢，根据名字，很容易知道啥意思，对于deque来说，是分段连续空间，迭代器执行操作，上述的<code>_M_cur</code>指向具体的元素，<code>_M_first</code>指向这段buffer中的第一个元素,<code>_M_last</code>指向最后一个元素(不是有效的元素)，而<code>_M_node</code>则是指向中控器。所以它是一个指针的指针。</p><p>例如现在迭代器执行++操作，当前buffer不够用了，那么此时需要一个指针能够回到中控器，取下一段buffer，重置<code>_M_first</code>与<code>_M_last</code>的指针位置，<code>_M_cur</code>指向新段buffer中的指定位置。</p><p>我们现在回到一开始的图：</p><p><img src="https://raw.githubusercontent.com/Light-City/cloudimg/master/deque_r.png" alt="deque_r.png"></p><p>最上面的的iterator就是上面几个指针的区块配图。</p><p>那buffer计算是什么实现的呢?</p><p>在源码中计算是根据传递进来的类型，如果传递的类型小于512字节，那么buffersize就是512/sizeof(_Tp)，超过512，就是1。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">static</span> size_t <span class="token function">_S_buffer_size</span><span class="token punctuation">(</span><span class="token punctuation">)</span>_GLIBCXX_NOEXCEPT<span class="token punctuation">{</span>    <span class="token keyword">return</span><span class="token punctuation">(</span><span class="token function">__deque_buf_size</span><span class="token punctuation">(</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>_Tp<span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><code>__deque_buf_size</code>实现</p><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">ifndef</span> _GLIBCXX_DEQUE_BUF_SIZE</span><span class="token macro property">#<span class="token directive keyword">define</span> _GLIBCXX_DEQUE_BUF_SIZE 512</span><span class="token macro property">#<span class="token directive keyword">endif</span></span><span class="token keyword">inline</span> size_t<span class="token function">__deque_buf_size</span><span class="token punctuation">(</span> size_t            __size <span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span><span class="token punctuation">(</span>__size <span class="token operator">&lt;</span> _GLIBCXX_DEQUE_BUF_SIZE            <span class="token operator">?</span> <span class="token function">size_t</span><span class="token punctuation">(</span> _GLIBCXX_DEQUE_BUF_SIZE <span class="token operator">/</span> __size <span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">size_t</span><span class="token punctuation">(</span> <span class="token number">1</span> <span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>前面几节源码中提到了萃取机技术，针对每个迭代器都需要嵌入下面五种typedef：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">typedef</span> std<span class="token operator">::</span>random_access_iterator_tag iterator_category<span class="token punctuation">;</span><span class="token keyword">typedef</span> _Tp                value_type<span class="token punctuation">;</span><span class="token keyword">typedef</span> _Ptr                pointer<span class="token punctuation">;</span><span class="token keyword">typedef</span> _Ref                reference<span class="token punctuation">;</span><span class="token keyword">typedef</span> ptrdiff_t            difference_type<span class="token punctuation">;</span></code></pre><p>据此，也可以知道deque迭代器的使用的是随机访问迭代器：<code>random_access_iterator_tag</code>。</p><p>而vector使用的迭代器也是这个，根据侯捷老师所讲，连续的buffer是vector，这与迭代器的tag类型不谋而合。</p><p>下面来看一下这个强大的迭代器的一些操作符重载：</p><p>具体的讲解在代码里面说。</p><blockquote><p>取值操作符</p></blockquote><pre class=" language-cpp"><code class="language-cpp">reference<span class="token keyword">operator</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>_GLIBCXX_NOEXCEPT<span class="token punctuation">{</span>    <span class="token keyword">return</span><span class="token punctuation">(</span><span class="token operator">*</span>_M_cur<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>pointer<span class="token keyword">operator</span><span class="token operator">-</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>_GLIBCXX_NOEXCEPT<span class="token punctuation">{</span>    <span class="token keyword">return</span><span class="token punctuation">(</span>_M_cur<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>当然上述的<code>-&gt;</code>也可以直接调用<code>*</code>操作符来实现，例如：</p><pre class=" language-cpp"><code class="language-cpp">pointer<span class="token keyword">operator</span><span class="token operator">-</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>_GLIBCXX_NOEXCEPT<span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token keyword">operator</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><blockquote><p>++与–操作符</p></blockquote><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 前置++操作符</span>_Self <span class="token operator">&amp;</span><span class="token keyword">operator</span><span class="token operator">++</span><span class="token punctuation">(</span><span class="token punctuation">)</span>_GLIBCXX_NOEXCEPT<span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 先++，判断是否到了buffer的末尾，如果到了末尾，就要跳到下一个buffer。</span>    <span class="token operator">++</span>_M_cur<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span> _M_cur <span class="token operator">==</span> _M_last <span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// _M_last指向的不是有效元素，保留节点  </span>    <span class="token punctuation">{</span>        <span class="token function">_M_set_node</span><span class="token punctuation">(</span> _M_node <span class="token operator">+</span> <span class="token number">1</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>        _M_cur <span class="token operator">=</span> _M_first<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 后置++操作符</span>_Self<span class="token keyword">operator</span><span class="token operator">++</span><span class="token punctuation">(</span> <span class="token keyword">int</span> <span class="token punctuation">)</span>_GLIBCXX_NOEXCEPT<span class="token punctuation">{</span>    _Self __tmp <span class="token operator">=</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>    <span class="token operator">++</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>    <span class="token keyword">return</span><span class="token punctuation">(</span>__tmp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 前置--操作符</span>_Self <span class="token operator">&amp;</span><span class="token keyword">operator</span><span class="token operator">--</span><span class="token punctuation">(</span><span class="token punctuation">)</span>_GLIBCXX_NOEXCEPT<span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 先判断是否到了起始位置，如果到了，由于需要进行--操作，那么就应该进入前一个buffer</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span> _M_cur <span class="token operator">==</span> _M_first <span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">_M_set_node</span><span class="token punctuation">(</span> _M_node <span class="token operator">-</span> <span class="token number">1</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>        _M_cur <span class="token operator">=</span> _M_last<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token operator">--</span>_M_cur<span class="token punctuation">;</span>    <span class="token keyword">return</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">//先在容器头部插入与第一个元素相同的元素</span><span class="token comment" spellcheck="true">// 后置--操作符</span>_Self<span class="token keyword">operator</span><span class="token operator">--</span><span class="token punctuation">(</span> <span class="token keyword">int</span> <span class="token punctuation">)</span>_GLIBCXX_NOEXCEPT<span class="token punctuation">{</span>    _Self __tmp <span class="token operator">=</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 定义一个副本 */</span>    <span class="token operator">--</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">/* 迭代器自减操作 */</span>    <span class="token keyword">return</span><span class="token punctuation">(</span>__tmp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><blockquote><p>跳跃n个距离操作符</p></blockquote><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">/** 实现随机取,迭代器可以直接跳跃n个距离* 将迭代器前移n个距离,当n负值时就为下面的operator-=操作*/</span>_Self <span class="token operator">&amp;</span><span class="token keyword">operator</span><span class="token operator">+</span><span class="token operator">=</span><span class="token punctuation">(</span> difference_type __n <span class="token punctuation">)</span>_GLIBCXX_NOEXCEPT<span class="token punctuation">{</span>    <span class="token keyword">const</span> difference_type __offset <span class="token operator">=</span> __n <span class="token operator">+</span> <span class="token punctuation">(</span>_M_cur <span class="token operator">-</span> _M_first<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/*        * 若前移n个距离后，目标依然在同一个缓冲区        * 则直接前移n个距离        */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span> __offset <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> __offset <span class="token operator">&lt;</span> <span class="token function">difference_type</span><span class="token punctuation">(</span> <span class="token function">_S_buffer_size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token punctuation">)</span>        _M_cur <span class="token operator">+</span><span class="token operator">=</span> __n<span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/*            * 若前移n个距离后,目标超出了缓冲区范围            * __offset>0   __offset / difference_type(_S_buffer_size())计算向后移动多少个缓冲区            * __offset&lt;=0  -difference_type((-__offset - 1) / _S_buffer_size()) - 1计算向前移动多少个缓冲区            */</span>        <span class="token keyword">const</span> difference_type __node_offset <span class="token operator">=</span>            __offset <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">?</span> __offset <span class="token operator">/</span> <span class="token function">difference_type</span><span class="token punctuation">(</span> <span class="token function">_S_buffer_size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span>            <span class="token operator">:</span> <span class="token operator">-</span><span class="token function">difference_type</span><span class="token punctuation">(</span> <span class="token punctuation">(</span><span class="token operator">-</span>__offset <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>                        <span class="token operator">/</span> <span class="token function">_S_buffer_size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/* 调整到正确的缓冲区,此时_M_first已经修改了 */</span>        <span class="token function">_M_set_node</span><span class="token punctuation">(</span> _M_node <span class="token operator">+</span> __node_offset <span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/* 修改为正确的指针位置 */</span>        _M_cur <span class="token operator">=</span> _M_first <span class="token operator">+</span> <span class="token punctuation">(</span>__offset <span class="token operator">-</span> __node_offset                        <span class="token operator">*</span> <span class="token function">difference_type</span><span class="token punctuation">(</span> <span class="token function">_S_buffer_size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>下面这几个操作符都是调用上面的<code>+=</code>操作符实现：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">/*    * 操作符+重载    * 返回操作之后的副本    */</span>_Self<span class="token keyword">operator</span><span class="token operator">+</span><span class="token punctuation">(</span> difference_type __n <span class="token punctuation">)</span> <span class="token keyword">const</span>_GLIBCXX_NOEXCEPT<span class="token punctuation">{</span>    _Self __tmp <span class="token operator">=</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 调用operator+=操作 */</span>    <span class="token keyword">return</span><span class="token punctuation">(</span>__tmp <span class="token operator">+</span><span class="token operator">=</span> __n<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/* 利用operator+=操作实现 */</span>_Self <span class="token operator">&amp;</span><span class="token keyword">operator</span><span class="token operator">-</span><span class="token operator">=</span><span class="token punctuation">(</span> difference_type __n <span class="token punctuation">)</span>_GLIBCXX_NOEXCEPT<span class="token punctuation">{</span>    <span class="token keyword">return</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token keyword">this</span> <span class="token operator">+</span><span class="token operator">=</span> <span class="token operator">-</span>__n<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/*    * 操作符-重载    * 返回操作之后的副本    */</span>_Self<span class="token keyword">operator</span><span class="token operator">-</span><span class="token punctuation">(</span> difference_type __n <span class="token punctuation">)</span> <span class="token keyword">const</span>_GLIBCXX_NOEXCEPT<span class="token punctuation">{</span>    _Self __tmp <span class="token operator">=</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/*  保存副本 */</span>    <span class="token keyword">return</span><span class="token punctuation">(</span>__tmp <span class="token operator">-</span><span class="token operator">=</span> __n<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">/* 调用operator-=操作符 */</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/* 返回指定位置的元素，即实现随机存取 */</span>reference<span class="token keyword">operator</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span> difference_type __n <span class="token punctuation">)</span> <span class="token keyword">const</span>_GLIBCXX_NOEXCEPT<span class="token punctuation">{</span>    <span class="token keyword">return</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token keyword">this</span> <span class="token operator">+</span> __n<span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 该函数调用operator+,operator* */</span><span class="token punctuation">}</span></code></pre><blockquote><p>buffer跳跃</p></blockquote><p>前面的++与–等操作符，会调用到<code>_M_set_node</code>函数，该函数的作用是能够进行buffer之间的跳跃，修改<code>_M_node</code>、<code>_M_first</code>、<code>_M_last</code>的指向。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">/**    *  Prepares to traverse new_node.  Sets everything except    *  _M_cur, which should therefore be set by the caller    *  immediately afterwards, based on _M_first and _M_last.    */</span><span class="token keyword">void</span><span class="token function">_M_set_node</span><span class="token punctuation">(</span> _Map_pointer __new_node <span class="token punctuation">)</span>_GLIBCXX_NOEXCEPT<span class="token punctuation">{</span>    _M_node        <span class="token operator">=</span> __new_node<span class="token punctuation">;</span>                                           <span class="token comment" spellcheck="true">/* 指向新的节点 */</span>    _M_first    <span class="token operator">=</span> <span class="token operator">*</span>__new_node<span class="token punctuation">;</span>                                          <span class="token comment" spellcheck="true">/* 指向新节点的头部 */</span>    _M_last        <span class="token operator">=</span> _M_first <span class="token operator">+</span> <span class="token function">difference_type</span><span class="token punctuation">(</span> <span class="token function">_S_buffer_size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">/* 指向新节点的尾部 */</span><span class="token punctuation">}</span></code></pre><p>据此，我们就把deque的迭代器实现细节讲解完毕了。</p><h2 id="3-deque"><a href="#3-deque" class="headerlink" title="3.deque"></a>3.deque</h2><blockquote><p>begin()函数</p></blockquote><p>返回<code>_M_start</code>。</p><pre class=" language-cpp"><code class="language-cpp">iterator<span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span>_GLIBCXX_NOEXCEPT<span class="token punctuation">{</span>    <span class="token keyword">return</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_start<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><blockquote><p>end()函数</p></blockquote><p>返回<code>_M_finish</code>。</p><pre class=" language-cpp"><code class="language-cpp">iterator<span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span>_GLIBCXX_NOEXCEPT<span class="token punctuation">{</span>    <span class="token keyword">return</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_finish<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><blockquote><p>size()函数</p></blockquote><pre class=" language-cpp"><code class="language-cpp">size_type<span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>_GLIBCXX_NOEXCEPT<span class="token punctuation">{</span>    <span class="token keyword">return</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_finish <span class="token operator">-</span> <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_start<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><blockquote><p>resize()函数</p></blockquote><p>根据传递进来的大小，如果超过了总size，就重新分配扩充<code>__new_size-size()</code>空间，否则删除从<code>size()-__new_size</code>数据，例如现在有20个空间，resize(12)，就会把后面8个空间数据删除及空间释放。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">void</span><span class="token function">resize</span><span class="token punctuation">(</span> size_type __new_size <span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">const</span> size_type __len <span class="token operator">=</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span> __new_size <span class="token operator">></span> __len <span class="token punctuation">)</span>        <span class="token function">_M_default_append</span><span class="token punctuation">(</span> __new_size <span class="token operator">-</span> __len <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span> __new_size <span class="token operator">&lt;</span> __len <span class="token punctuation">)</span>        <span class="token function">_M_erase_at_end</span><span class="token punctuation">(</span> <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_start                    <span class="token operator">+</span> <span class="token function">difference_type</span><span class="token punctuation">(</span> __new_size <span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><blockquote><p>empty()函数</p></blockquote><p>判断两个指针位置即可。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">bool</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>_GLIBCXX_NOEXCEPT<span class="token punctuation">{</span>    <span class="token keyword">return</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_finish <span class="token operator">==</span> <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_start<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><blockquote><p>back函数</p></blockquote><pre class=" language-cpp"><code class="language-cpp">reference<span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span>_GLIBCXX_NOEXCEPT       <span class="token comment" spellcheck="true">// 指向finish的前一个位置</span><span class="token punctuation">{</span>    iterator __tmp <span class="token operator">=</span> <span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">--</span>__tmp<span class="token punctuation">;</span>    <span class="token keyword">return</span><span class="token punctuation">(</span><span class="token operator">*</span>__tmp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><blockquote><p>push_front函数</p></blockquote><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">void</span><span class="token function">push_front</span><span class="token punctuation">(</span> <span class="token keyword">const</span> value_type <span class="token operator">&amp;</span>__x <span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//若当前缓冲区存在可用空间</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_start<span class="token punctuation">.</span>_M_cur <span class="token operator">!=</span> <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_start<span class="token punctuation">.</span>_M_first <span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span><span class="token function">construct</span><span class="token punctuation">(</span> <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_start<span class="token punctuation">.</span>_M_cur <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> __x <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 直接构造对象</span>        <span class="token operator">--</span><span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_start<span class="token punctuation">.</span>_M_cur<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 调整指针所指位置</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span>        <span class="token function">_M_push_front_aux</span><span class="token punctuation">(</span> __x <span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 需分配一段新的连续空间</span><span class="token punctuation">}</span></code></pre><blockquote><p>push_back函数</p></blockquote><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">void</span><span class="token function">push_back</span><span class="token punctuation">(</span> <span class="token keyword">const</span> value_type <span class="token operator">&amp;</span>__x <span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//若当前缓冲区存在可用空间</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_finish<span class="token punctuation">.</span>_M_cur            <span class="token operator">!=</span> <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_finish<span class="token punctuation">.</span>_M_last <span class="token operator">-</span> <span class="token number">1</span> <span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span><span class="token function">construct</span><span class="token punctuation">(</span> <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_finish<span class="token punctuation">.</span>_M_cur<span class="token punctuation">,</span> __x <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 直接构造对象</span>        <span class="token operator">++</span><span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_finish<span class="token punctuation">.</span>_M_cur<span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">//调整指针所指位置</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span>     <span class="token comment" spellcheck="true">// 若当前缓冲区不存在可用空间</span>    <span class="token comment" spellcheck="true">// 需分配一段新的连续空间</span>        <span class="token function">_M_push_back_aux</span><span class="token punctuation">(</span> __x <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>上述对应的pop动作与之相反。</p><blockquote><p>insert()函数</p></blockquote><p>insert函数比较有意思，根据传递进来的迭代器位置，看是不在开头与结尾，如果是在开头直接调用<code>push_front</code>函数，结尾直接调<code>push_back</code>函数，否则在容器中直接插入元素。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> _Tp<span class="token punctuation">,</span> <span class="token keyword">typename</span> _Alloc<span class="token operator">></span><span class="token keyword">typename</span> deque<span class="token operator">&lt;</span>_Tp<span class="token punctuation">,</span> _Alloc<span class="token operator">></span><span class="token operator">::</span>iteratordeque<span class="token operator">&lt;</span>_Tp<span class="token punctuation">,</span> _Alloc<span class="token operator">></span><span class="token operator">::</span><span class="token function">insert</span><span class="token punctuation">(</span>iterator __position<span class="token punctuation">,</span> <span class="token keyword">const</span> value_type<span class="token operator">&amp;</span> __x<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>__position<span class="token punctuation">.</span>_M_cur <span class="token operator">==</span> <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_start<span class="token punctuation">.</span>_M_cur<span class="token punctuation">)</span>       <span class="token punctuation">{</span>        <span class="token function">push_front</span><span class="token punctuation">(</span>__x<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_start<span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>__position<span class="token punctuation">.</span>_M_cur <span class="token operator">==</span> <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_finish<span class="token punctuation">.</span>_M_cur<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">push_back</span><span class="token punctuation">(</span>__x<span class="token punctuation">)</span><span class="token punctuation">;</span>        iterator __tmp <span class="token operator">=</span> <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_finish<span class="token punctuation">;</span>        <span class="token operator">--</span>__tmp<span class="token punctuation">;</span>        <span class="token keyword">return</span> __tmp<span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token keyword">else</span>  <span class="token comment" spellcheck="true">//否则在容器直接插入数据</span>        <span class="token keyword">return</span> <span class="token function">_M_insert_aux</span><span class="token punctuation">(</span>__position<span class="token punctuation">.</span><span class="token function">_M_const_cast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> __x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>而上述在容器中直接插入元素函数，会计算插入点，如果比较靠前面，就在前面插入，靠近后面就在后面插入：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _Tp<span class="token punctuation">,</span> <span class="token keyword">typename</span> _Alloc<span class="token operator">></span><span class="token keyword">typename</span> deque<span class="token operator">&lt;</span>_Tp<span class="token punctuation">,</span> _Alloc<span class="token operator">></span><span class="token operator">::</span>iteratordeque<span class="token operator">&lt;</span>_Tp<span class="token punctuation">,</span> _Alloc<span class="token operator">></span><span class="token operator">::</span><span class="token function">_M_insert_aux</span><span class="token punctuation">(</span>iterator __pos<span class="token punctuation">,</span> <span class="token keyword">const</span> value_type<span class="token operator">&amp;</span> __x<span class="token punctuation">)</span><span class="token punctuation">{</span>    value_type __x_copy <span class="token operator">=</span> __x<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// XXX copy</span>    difference_type __index <span class="token operator">=</span> __pos <span class="token operator">-</span> <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_start<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//计算插入点之前元素个数</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">static_cast</span><span class="token operator">&lt;</span>size_type<span class="token operator">></span><span class="token punctuation">(</span>__index<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">//若插入点之前的元素较少</span>        <span class="token punctuation">{</span>        <span class="token function">push_front</span><span class="token punctuation">(</span><span class="token function">_GLIBCXX_MOVE</span><span class="token punctuation">(</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//先在容器头部插入与第一个元素相同的元素</span>        iterator __front1 <span class="token operator">=</span> <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_start<span class="token punctuation">;</span>        <span class="token operator">++</span>__front1<span class="token punctuation">;</span>        iterator __front2 <span class="token operator">=</span> __front1<span class="token punctuation">;</span>        <span class="token operator">++</span>__front2<span class="token punctuation">;</span>        __pos <span class="token operator">=</span> <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_start <span class="token operator">+</span> __index<span class="token punctuation">;</span>        iterator __pos1 <span class="token operator">=</span> __pos<span class="token punctuation">;</span>        <span class="token operator">++</span>__pos1<span class="token punctuation">;</span>        <span class="token function">_GLIBCXX_MOVE3</span><span class="token punctuation">(</span>__front2<span class="token punctuation">,</span> __pos1<span class="token punctuation">,</span> __front1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 元素搬移</span>        <span class="token punctuation">}</span>    <span class="token keyword">else</span>    <span class="token punctuation">{</span>        <span class="token function">push_back</span><span class="token punctuation">(</span><span class="token function">_GLIBCXX_MOVE</span><span class="token punctuation">(</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        iterator __back1 <span class="token operator">=</span> <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_finish<span class="token punctuation">;</span>        <span class="token operator">--</span>__back1<span class="token punctuation">;</span>        iterator __back2 <span class="token operator">=</span> __back1<span class="token punctuation">;</span>        <span class="token operator">--</span>__back2<span class="token punctuation">;</span>        __pos <span class="token operator">=</span> <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_start <span class="token operator">+</span> __index<span class="token punctuation">;</span>        <span class="token function">_GLIBCXX_MOVE_BACKWARD3</span><span class="token punctuation">(</span>__pos<span class="token punctuation">,</span> __back2<span class="token punctuation">,</span> __back1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token operator">*</span>__pos <span class="token operator">=</span> <span class="token function">_GLIBCXX_MOVE</span><span class="token punctuation">(</span>__x_copy<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// 在安插点上设定新值</span>    <span class="token keyword">return</span> __pos<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> STL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ STL源码剖析之容器配接器stack与queue、priority_queue</title>
      <link href="/2019/10/16/queue-stack/"/>
      <url>/2019/10/16/queue-stack/</url>
      
        <content type="html"><![CDATA[<h1 id="C-STL源码剖析之容器配接器stack与queue、priority-queue"><a href="#C-STL源码剖析之容器配接器stack与queue、priority-queue" class="headerlink" title="C++ STL源码剖析之容器配接器stack与queue、priority_queue"></a>C++ STL源码剖析之容器配接器stack与queue、priority_queue</h1><h2 id="0-导语"><a href="#0-导语" class="headerlink" title="0.导语"></a>0.导语</h2><p>为何stack与queue不被称为容器呢？</p><p>下面本节带着这个问题来深入源码分析。</p><h2 id="1-stack"><a href="#1-stack" class="headerlink" title="1.stack"></a>1.stack</h2><p>在stack的源码中我们关注两点：</p><ul><li>默认<code>_Sequence</code>为<code>deque</code></li><li>内部函数实现是调用<code>_Sequence</code>对应容器的函数。</li></ul><p><img src="https://raw.githubusercontent.com/Light-City/cloudimg/master/stack.png" alt="stack.png"></p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _Tp<span class="token punctuation">,</span> <span class="token keyword">typename</span> _Sequence <span class="token operator">=</span> deque<span class="token operator">&lt;</span>_Tp<span class="token operator">></span> <span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">stack</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">typedef</span> <span class="token keyword">typename</span> _Sequence<span class="token operator">::</span>value_type                value_type<span class="token punctuation">;</span>    <span class="token keyword">typedef</span> <span class="token keyword">typename</span> _Sequence<span class="token operator">::</span>reference                 reference<span class="token punctuation">;</span>    <span class="token keyword">typedef</span> <span class="token keyword">typename</span> _Sequence<span class="token operator">::</span>const_reference           const_reference<span class="token punctuation">;</span>    <span class="token keyword">typedef</span> <span class="token keyword">typename</span> _Sequence<span class="token operator">::</span>size_type                 size_type<span class="token punctuation">;</span>    <span class="token keyword">typedef</span>          _Sequence                            container_type<span class="token punctuation">;</span><span class="token keyword">protected</span><span class="token operator">:</span>    <span class="token comment" spellcheck="true">//  See queue::c for notes on this name.</span>    _Sequence c<span class="token punctuation">;</span><span class="token keyword">public</span><span class="token operator">:</span>     reference      <span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token punctuation">{</span>        <span class="token function">__glibcxx_requires_nonempty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> c<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token keyword">void</span>      <span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">const</span> value_type<span class="token operator">&amp;</span> __x<span class="token punctuation">)</span>      <span class="token punctuation">{</span> c<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>__x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p>测试stack底层容器</p></blockquote><p>对于stack来说，底层容器可以是<code>vector</code>、<code>deque</code>、<code>list</code>，但不可以是<code>map</code>、<code>set</code>。<br>由于编译器不会做全面性检查，当调用函数不存在的时候，就编译不通过，所以对于像set虽然不能作为底层容器，但如果具有某些函数，调用仍然是成功的，直到调用的函数不存在。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">test_stack</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    cout<span class="token operator">&lt;&lt;</span><span class="token string">"============test_stack============="</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    clock_t timeStart <span class="token operator">=</span> <span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    stack<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> c<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">long</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        c<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"stack.size()= "</span> <span class="token operator">&lt;&lt;</span> c<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"stack.top()= "</span> <span class="token operator">&lt;&lt;</span> c<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    c<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"stack.size()= "</span> <span class="token operator">&lt;&lt;</span> c<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"stack.top()= "</span> <span class="token operator">&lt;&lt;</span> c<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"use stack milli-seconds : "</span> <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span><span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> timeStart<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    timeStart<span class="token operator">=</span><span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    stack<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> deque<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> c1<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">long</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        c1<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"stack.size()= "</span> <span class="token operator">&lt;&lt;</span> c1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"stack.top()= "</span> <span class="token operator">&lt;&lt;</span> c1<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    c1<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"stack.size()= "</span> <span class="token operator">&lt;&lt;</span> c1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"stack.top()= "</span> <span class="token operator">&lt;&lt;</span> c1<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"use stack milli-seconds : "</span> <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span><span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> timeStart<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// vector可以作为stack的底层容器</span>    stack<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> c2<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">long</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        c2<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"stack.size()= "</span> <span class="token operator">&lt;&lt;</span> c2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"stack.top()= "</span> <span class="token operator">&lt;&lt;</span> c2<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    c2<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"stack.size()= "</span> <span class="token operator">&lt;&lt;</span> c2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"stack.top()= "</span> <span class="token operator">&lt;&lt;</span> c2<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"use stack milli-seconds : "</span> <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span><span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> timeStart<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="2-queue"><a href="#2-queue" class="headerlink" title="2.queue"></a>2.queue</h2><p>在queue的源码中我们关注两点：</p><ul><li>默认<code>_Sequence</code>为<code>deque</code></li><li>内部函数实现是调用<code>_Sequence</code>对应容器的函数。</li></ul><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _Tp<span class="token punctuation">,</span> <span class="token keyword">typename</span> _Sequence <span class="token operator">=</span> deque<span class="token operator">&lt;</span>_Tp<span class="token operator">></span> <span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">queue</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">typedef</span> <span class="token keyword">typename</span> _Sequence<span class="token operator">::</span>value_type                value_type<span class="token punctuation">;</span>    <span class="token keyword">typedef</span> <span class="token keyword">typename</span> _Sequence<span class="token operator">::</span>reference                 reference<span class="token punctuation">;</span>    <span class="token keyword">typedef</span> <span class="token keyword">typename</span> _Sequence<span class="token operator">::</span>const_reference           const_reference<span class="token punctuation">;</span>    <span class="token keyword">typedef</span> <span class="token keyword">typename</span> _Sequence<span class="token operator">::</span>size_type                 size_type<span class="token punctuation">;</span>    <span class="token keyword">typedef</span>          _Sequence                            container_type<span class="token punctuation">;</span><span class="token keyword">protected</span><span class="token operator">:</span>    _Sequence c<span class="token punctuation">;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">const</span> value_type<span class="token operator">&amp;</span> __x<span class="token punctuation">)</span>    <span class="token punctuation">{</span> c<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>__x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>         <span class="token function">__glibcxx_requires_nonempty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      c<span class="token punctuation">.</span><span class="token function">pop_front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>其对应的UML类图如下：</p><p><img src="https://raw.githubusercontent.com/Light-City/cloudimg/master/queue_.png" alt="queue_.png"></p><p>同理，优先队列则是使用<code>vector</code>作为默认容器。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _Tp<span class="token punctuation">,</span> <span class="token keyword">typename</span> _Sequence <span class="token operator">=</span> vector<span class="token operator">&lt;</span>_Tp<span class="token operator">></span><span class="token punctuation">,</span><span class="token keyword">typename</span> _Compare  <span class="token operator">=</span> less<span class="token operator">&lt;</span><span class="token keyword">typename</span> _Sequence<span class="token operator">::</span>value_type<span class="token operator">></span> <span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">priority_queue</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">typedef</span> <span class="token keyword">typename</span> _Sequence<span class="token operator">::</span>value_type                value_type<span class="token punctuation">;</span>    <span class="token keyword">typedef</span> <span class="token keyword">typename</span> _Sequence<span class="token operator">::</span>reference                 reference<span class="token punctuation">;</span>    <span class="token keyword">typedef</span> <span class="token keyword">typename</span> _Sequence<span class="token operator">::</span>const_reference           const_reference<span class="token punctuation">;</span>    <span class="token keyword">typedef</span> <span class="token keyword">typename</span> _Sequence<span class="token operator">::</span>size_type                 size_type<span class="token punctuation">;</span>    <span class="token keyword">typedef</span>          _Sequence                            container_type<span class="token punctuation">;</span><span class="token keyword">protected</span><span class="token operator">:</span>    <span class="token comment" spellcheck="true">//  See queue::c for notes on these names.</span>    _Sequence  c<span class="token punctuation">;</span>    _Compare   comp<span class="token punctuation">;</span><span class="token keyword">public</span><span class="token operator">:</span>    reference    <span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span>     <span class="token punctuation">{</span>        <span class="token function">__glibcxx_requires_nonempty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> c<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span>    <span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">const</span> value_type<span class="token operator">&amp;</span> __x<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        c<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>__x<span class="token punctuation">)</span><span class="token punctuation">;</span>        std<span class="token operator">::</span><span class="token function">push_heap</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> c<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> comp<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><img src="https://raw.githubusercontent.com/Light-City/cloudimg/master/priority_queue.png" alt="priority_queue.png"></p><p>测试这两个容器配接器支持的底层容器：</p><blockquote><p>queue</p></blockquote><p>对于queue底层容器可以是<code>deque</code>，也可以是<code>list</code>，但不能是<code>vector</code>,<code>map</code>,<code>set</code>，使用默认的deque效率在插入方面比其他容器作为底层要快！</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">test_queue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    cout<span class="token operator">&lt;&lt;</span><span class="token string">"============test_queue============="</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    clock_t timeStart <span class="token operator">=</span> <span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    queue<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> c<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">long</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        c<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"stack.size()= "</span> <span class="token operator">&lt;&lt;</span> c<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"stack.front()= "</span> <span class="token operator">&lt;&lt;</span> c<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    c<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"stack.size()= "</span> <span class="token operator">&lt;&lt;</span> c<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"stack.front()= "</span> <span class="token operator">&lt;&lt;</span> c<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"use list milli-seconds : "</span> <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span><span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> timeStart<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    timeStart<span class="token operator">=</span><span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    queue<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> deque<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> c1<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">long</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        c1<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"stack.size()= "</span> <span class="token operator">&lt;&lt;</span> c1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"stack.front()= "</span> <span class="token operator">&lt;&lt;</span> c1<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    c1<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"stack.size()= "</span> <span class="token operator">&lt;&lt;</span> c1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"stack.front()= "</span> <span class="token operator">&lt;&lt;</span> c1<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"use deque milli-seconds : "</span> <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span><span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> timeStart<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><blockquote><p>priority_queue</p></blockquote><p>对于优先队列来说，测试结果发现，采用<code>deque</code>要比默认的<code>vector</code>插入速度快！<br>底层支持vector、deque容器，但不支持list、map、set。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">test_priority_queue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    cout<span class="token operator">&lt;&lt;</span><span class="token string">"============test_priority_queue============="</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    clock_t timeStart <span class="token operator">=</span> <span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    priority_queue<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> deque<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> c1<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">long</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        c1<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"stack.size()= "</span> <span class="token operator">&lt;&lt;</span> c1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"stack.top()= "</span> <span class="token operator">&lt;&lt;</span> c1<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    c1<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"stack.size()= "</span> <span class="token operator">&lt;&lt;</span> c1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"stack.top()= "</span> <span class="token operator">&lt;&lt;</span> c1<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"use deque milli-seconds : "</span> <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span><span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> timeStart<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    priority_queue<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> c2<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">long</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        c2<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"stack.size()= "</span> <span class="token operator">&lt;&lt;</span> c2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"stack.top()= "</span> <span class="token operator">&lt;&lt;</span> c2<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    c2<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"stack.size()= "</span> <span class="token operator">&lt;&lt;</span> c2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"stack.top()= "</span> <span class="token operator">&lt;&lt;</span> c2<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"use stack milli-seconds : "</span> <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span><span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> timeStart<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><strong>因此，stack、queue、priority_queue不被称为容器， 把它称为容器配接器。</strong></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> STL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ STL源码剖析 tr1与std array</title>
      <link href="/2019/10/15/array/"/>
      <url>/2019/10/15/array/</url>
      
        <content type="html"><![CDATA[<h1 id="C-STL源码剖析-tr1与std-array"><a href="#C-STL源码剖析-tr1与std-array" class="headerlink" title="C++ STL源码剖析 tr1与std array"></a>C++ STL源码剖析 tr1与std array</h1><h2 id="0-导语"><a href="#0-导语" class="headerlink" title="0.导语"></a>0.导语</h2><p>源码剖析版本为gcc4.9.1。</p><p>C++ tr1全称Technical Report 1，是针对C++标准库的第一次扩展。即将到来的下一个版本的C++标准c++0x会包括它，以及一些语言本身的扩充。tr1包括大家期待已久的smart pointer，正则表达式以及其他一些支持范型编程的内容。草案阶段，新增的类和模板的名字空间是std::tr1。</p><h2 id="1-std-tr1-array"><a href="#1-std-tr1-array" class="headerlink" title="1.std::tr1::array"></a>1.std::tr1::array</h2><p>使用：</p><pre><code>#include &lt;tr1/array&gt;std::tr1::array&lt;int ,10&gt; a;</code></pre><p>tr1中的array比较简单，模拟语言本身的数组，并且让其支持迭代器操作，使其同其他容器一样，能够调用算法。对于tr1中array没有构造与析构。迭代器是直接使用传递进来的类型定义指针。</p><p>简单的看一下这个静态数组array源码：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _Tp<span class="token punctuation">,</span> std<span class="token operator">::</span>size_t _Nm<span class="token operator">></span><span class="token keyword">struct</span> array<span class="token punctuation">{</span>    <span class="token keyword">typedef</span> _Tp                           value_type<span class="token punctuation">;</span>    <span class="token keyword">typedef</span> value_type<span class="token operator">&amp;</span>                             reference<span class="token punctuation">;</span>    <span class="token keyword">typedef</span> <span class="token keyword">const</span> value_type<span class="token operator">&amp;</span>                       const_reference<span class="token punctuation">;</span>    <span class="token keyword">typedef</span> value_type<span class="token operator">*</span>                        iterator<span class="token punctuation">;</span>    <span class="token keyword">typedef</span> <span class="token keyword">const</span> value_type<span class="token operator">*</span>                  const_iterator<span class="token punctuation">;</span>    <span class="token keyword">typedef</span> std<span class="token operator">::</span>size_t                              size_type<span class="token punctuation">;</span>    <span class="token keyword">typedef</span> std<span class="token operator">::</span>ptrdiff_t                          difference_type<span class="token punctuation">;</span>    <span class="token keyword">typedef</span> std<span class="token operator">::</span>reverse_iterator<span class="token operator">&lt;</span>iterator<span class="token operator">></span>          reverse_iterator<span class="token punctuation">;</span>    <span class="token keyword">typedef</span> std<span class="token operator">::</span>reverse_iterator<span class="token operator">&lt;</span>const_iterator<span class="token operator">></span>   const_reverse_iterator<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>里面使用<code>reverse_iterator</code>作为rbegin与rend操作的迭代器。<br>看上去上面一个迭代器，实际上两个，还有一个iterator,这个直接使用传递进来的类型定义指针，作为迭代器。</p><p>可以将其对比为vector中的正向与反向迭代器。</p><p>值得注意的是，在tr1::array中，支持传递数组大小为0，例如我们使用如下：</p><pre><code>std::tr1::array&lt;int,0&gt; a;</code></pre><p>对于这样的写法，会对应到下面：</p><pre><code>// Support for zero-sized arrays mandatory.value_type _M_instance[_Nm ? _Nm : 1];</code></pre><p>根据传递进来的大小，如果不为0，就是传递进来的大小，否则为1。</p><h2 id="2-std-array"><a href="#2-std-array" class="headerlink" title="2.std::array"></a>2.std::array</h2><p>使用</p><pre><code>std::array&lt;int ,10&gt; a;</code></pre><p>std中的array包含了</p><p><img src="https://raw.githubusercontent.com/Light-City/cloudimg/master/std_array.png" alt="std_array.png"></p><p>对比tr1与std的array</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _Tp<span class="token punctuation">,</span> std<span class="token operator">::</span>size_t _Nm<span class="token operator">></span><span class="token keyword">struct</span> array<span class="token punctuation">{</span>    <span class="token keyword">typedef</span> _Tp                           value_type<span class="token punctuation">;</span>    <span class="token keyword">typedef</span> value_type<span class="token operator">*</span>                  pointer<span class="token punctuation">;</span>    <span class="token keyword">typedef</span> <span class="token keyword">const</span> value_type<span class="token operator">*</span>                       const_pointer<span class="token punctuation">;</span>    <span class="token keyword">typedef</span> value_type<span class="token operator">&amp;</span>                             reference<span class="token punctuation">;</span>    <span class="token keyword">typedef</span> <span class="token keyword">const</span> value_type<span class="token operator">&amp;</span>                       const_reference<span class="token punctuation">;</span>    <span class="token keyword">typedef</span> value_type<span class="token operator">*</span>                        iterator<span class="token punctuation">;</span>    <span class="token keyword">typedef</span> <span class="token keyword">const</span> value_type<span class="token operator">*</span>                  const_iterator<span class="token punctuation">;</span>    <span class="token keyword">typedef</span> std<span class="token operator">::</span>size_t                              size_type<span class="token punctuation">;</span>    <span class="token keyword">typedef</span> std<span class="token operator">::</span>ptrdiff_t                             difference_type<span class="token punctuation">;</span>    <span class="token keyword">typedef</span> std<span class="token operator">::</span>reverse_iterator<span class="token operator">&lt;</span>iterator<span class="token operator">></span>          reverse_iterator<span class="token punctuation">;</span>    <span class="token keyword">typedef</span> std<span class="token operator">::</span>reverse_iterator<span class="token operator">&lt;</span>const_iterator<span class="token operator">></span>   const_reverse_iterator<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// Support for zero-sized arrays mandatory.</span>    <span class="token keyword">typedef</span> _GLIBCXX_STD_C<span class="token operator">::</span>__array_traits<span class="token operator">&lt;</span>_Tp<span class="token punctuation">,</span> _Nm<span class="token operator">></span> _AT_Type<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// # define _GLIBCXX_STD_C std</span>    <span class="token keyword">typename</span> _AT_Type<span class="token operator">::</span>_Type                         _M_elems<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>发现array里面有两处值得注意的地方：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// Support for zero-sized arrays mandatory.</span><span class="token keyword">typedef</span> _GLIBCXX_STD_C<span class="token operator">::</span>__array_traits<span class="token operator">&lt;</span>_Tp<span class="token punctuation">,</span> _Nm<span class="token operator">></span> _AT_Type<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// # define _GLIBCXX_STD_C std</span><span class="token keyword">typename</span> _AT_Type<span class="token operator">::</span>_Type                         _M_elems<span class="token punctuation">;</span></code></pre><p>在源码中去找__array_traits，看到：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _Tp<span class="token punctuation">,</span> std<span class="token operator">::</span>size_t _Nm<span class="token operator">></span><span class="token keyword">struct</span> __array_traits<span class="token punctuation">{</span>    <span class="token keyword">typedef</span> _Tp _Type<span class="token punctuation">[</span>_Nm<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token keyword">constexpr</span> _Tp<span class="token operator">&amp;</span>    <span class="token function">_S_ref</span><span class="token punctuation">(</span><span class="token keyword">const</span> _Type<span class="token operator">&amp;</span> __t<span class="token punctuation">,</span> std<span class="token operator">::</span>size_t __n<span class="token punctuation">)</span> <span class="token keyword">noexcept</span>    <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token keyword">const_cast</span><span class="token operator">&lt;</span>_Tp<span class="token operator">&amp;</span><span class="token operator">></span><span class="token punctuation">(</span>__t<span class="token punctuation">[</span>__n<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>上面两行的代码可以理解为下面：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">typedef</span> _Tp _Type<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">typedef</span> _Type _M_elems<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 一个含有100个元素的数组。</span></code></pre><p>在实际写代码的时候，如果要定义一个数组，我们可以这样写：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//或者</span><span class="token keyword">typedef</span> <span class="token keyword">int</span> T<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">typedef</span> T a<span class="token punctuation">;</span></code></pre><p>针对传进来的size处理，相比于tr1，更加复杂，使用了模板偏特化来处理传递size为0情况。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _Tp<span class="token punctuation">,</span> std<span class="token operator">::</span>size_t _Nm<span class="token operator">></span><span class="token keyword">struct</span> __array_traits<span class="token punctuation">{</span>    <span class="token keyword">typedef</span> _Tp _Type<span class="token punctuation">[</span>_Nm<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token keyword">constexpr</span> _Tp<span class="token operator">&amp;</span>    <span class="token function">_S_ref</span><span class="token punctuation">(</span><span class="token keyword">const</span> _Type<span class="token operator">&amp;</span> __t<span class="token punctuation">,</span> std<span class="token operator">::</span>size_t __n<span class="token punctuation">)</span> <span class="token keyword">noexcept</span>    <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token keyword">const_cast</span><span class="token operator">&lt;</span>_Tp<span class="token operator">&amp;</span><span class="token operator">></span><span class="token punctuation">(</span>__t<span class="token punctuation">[</span>__n<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _Tp<span class="token operator">></span><span class="token keyword">struct</span> __array_traits<span class="token operator">&lt;</span>_Tp<span class="token punctuation">,</span> <span class="token number">0</span><span class="token operator">></span><span class="token punctuation">{</span>    <span class="token keyword">struct</span> _Type <span class="token punctuation">{</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token keyword">constexpr</span> _Tp<span class="token operator">&amp;</span>    <span class="token function">_S_ref</span><span class="token punctuation">(</span><span class="token keyword">const</span> _Type<span class="token operator">&amp;</span><span class="token punctuation">,</span> std<span class="token operator">::</span>size_t<span class="token punctuation">)</span> <span class="token keyword">noexcept</span>    <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">static_cast</span><span class="token operator">&lt;</span>_Tp<span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> STL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于二分搜索法的floor与ceil</title>
      <link href="/2019/10/13/er-fen-cha-zhao-fa/"/>
      <url>/2019/10/13/er-fen-cha-zhao-fa/</url>
      
        <content type="html"><![CDATA[<h1 id="基于二分搜索法的floor与ceil"><a href="#基于二分搜索法的floor与ceil" class="headerlink" title="基于二分搜索法的floor与ceil"></a>基于二分搜索法的floor与ceil</h1><h2 id="1-基本的二分搜索"><a href="#1-基本的二分搜索" class="headerlink" title="1.基本的二分搜索"></a>1.基本的二分搜索</h2><p>在闭区间[left,right]范围内查找target。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">search1</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> right <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// left与right均不会越界，可以取等</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;=</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> mid <span class="token operator">=</span>left<span class="token operator">+</span> <span class="token punctuation">(</span>right<span class="token operator">-</span>left<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> mid<span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    left <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// mid处理过了，需要mid+1</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">></span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>                right <span class="token operator">=</span> mid<span class="token number">-1</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// mid处理过了,需要mid-1</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>如果上述right改为nums.size()，判断与right均会发生变化：</p><p>此时处理的范围为[left,right)</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">search2</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> right <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// right会越界</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> mid <span class="token operator">=</span>left<span class="token operator">+</span> <span class="token punctuation">(</span>right<span class="token operator">-</span>left<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> mid<span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    left <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// mid处理过了，需要mid+1 left不会越界</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">></span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>                right <span class="token operator">=</span> mid<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 处理范围为[left,right)，right为开区间，不可取得right，一定要维护[left,right)这个条件不变</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>上述都比较简单，现在我们考虑有如下例子：</p><pre class=" language-cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> nums<span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> target<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span></code></pre><p>此时使用上述二分查找算法，搜索出来的index为3。那如果我想要获取最左侧等于target的index或最右侧等于target的index呢？此时上述算法失效！</p><h2 id="2-最左侧index"><a href="#2-最左侧index" class="headerlink" title="2.最左侧index"></a>2.最左侧index</h2><p>所谓最左侧index为第一个等于target对应的index</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">search3</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> right <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;=</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> mid <span class="token operator">=</span>left<span class="token operator">+</span> <span class="token punctuation">(</span>right<span class="token operator">-</span>left<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>                right<span class="token operator">=</span>mid<span class="token number">-1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>                left <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">></span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>                right <span class="token operator">=</span> mid<span class="token number">-1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>left<span class="token operator">==</span>nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 如果最后left==nums.size()，表示nums中的所有元素都小于target,查找失败！</span>        <span class="token keyword">return</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">==</span> target <span class="token operator">?</span> left <span class="token operator">:</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><h2 id="3-最右侧index"><a href="#3-最右侧index" class="headerlink" title="3.最右侧index"></a>3.最右侧index</h2><p>所谓最右侧index为最后一个等于target对应的index</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">search4</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> right <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;=</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> mid <span class="token operator">=</span>left<span class="token operator">+</span> <span class="token punctuation">(</span>right<span class="token operator">-</span>left<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>                left <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 注意</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>                left <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">></span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>                right <span class="token operator">=</span> mid<span class="token number">-1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>right<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 或者写if(left==0) return -1; 如果right&lt;0，那么此时nums中所有元素均大于target</span>        <span class="token keyword">return</span> nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">==</span> target <span class="token operator">?</span> right <span class="token operator">:</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>测试上述算法：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> nums<span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> target<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>    cout<span class="token operator">&lt;&lt;</span><span class="token function">Solution</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">search1</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span>target<span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// 3</span>    cout<span class="token operator">&lt;&lt;</span><span class="token function">Solution</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">search2</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span>target<span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// 3</span>    <span class="token comment" spellcheck="true">// 寻找第一个等于target的index,最左侧index</span>    cout<span class="token operator">&lt;&lt;</span><span class="token function">Solution</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">search3</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span>target<span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// 1</span>    cout<span class="token operator">&lt;&lt;</span><span class="token function">Solution</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">search4</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span>target<span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// 4</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>测试成功。</p><h2 id="4-floor"><a href="#4-floor" class="headerlink" title="4.floor"></a>4.floor</h2><p>对于上述最左侧index，我们可以将这个算法的返回值进行修改，这样就得到了我们想要的floor函数，floor函数定义是：<strong>当存在大量重复元素时，floor找的是第一个，当不存在指定的元素时，floor找的是比其小最大的一个。</strong></p><p>注意边界，当所有元素小于target时，返回的index为最后一个index，当所有元素大于target时，返回-1.</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">floor1</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> right <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;=</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> mid <span class="token operator">=</span>left<span class="token operator">+</span> <span class="token punctuation">(</span>right<span class="token operator">-</span>left<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>                right<span class="token operator">=</span>mid<span class="token number">-1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>                left <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">></span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>                right <span class="token operator">=</span> mid<span class="token number">-1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 所有元素均大于target</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>right <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 所有元素均小于target</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">==</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> left <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">==</span> target <span class="token operator">?</span> left <span class="token operator">:</span> left<span class="token number">-1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>将该算法使用另外一种写法：</p><p>使用(left,right]定义</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">floor2</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 寻找比target小的最大索引</span>    <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> right <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// (left,right]</span>    <span class="token keyword">while</span><span class="token punctuation">(</span> left <span class="token operator">&lt;</span> right <span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 使用向上取整避免死循环</span>        <span class="token keyword">int</span> mid <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token punctuation">(</span>right<span class="token operator">-</span>left<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span> nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">>=</span> target <span class="token punctuation">)</span>            right <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">else</span>            left <span class="token operator">=</span> mid<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 如果该索引+1就是target本身, 该索引+1即为返回值</span>    <span class="token keyword">if</span><span class="token punctuation">(</span> left <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>left<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> target <span class="token punctuation">)</span>        <span class="token keyword">return</span> left <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 否则, 该索引即为返回值</span>    <span class="token keyword">return</span> left<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="5-ceil"><a href="#5-ceil" class="headerlink" title="5.ceil"></a>5.ceil</h2><p>对于上述最右侧index，我们可以将这个算法的返回值进行修改，这样就得到了我们想要的ceil函数，ceil函数定义是：<strong>当存在大量重复的元素时，ceil找的是第一个。当不存在指定的元素时，ceil是比其大最小的一个。</strong></p><p>注意边界，当所有元素小于target时，返回的index为最后一个index，当所有元素大于target时，返回0.</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">ceil1</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> right <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;=</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> mid <span class="token operator">=</span>left<span class="token operator">+</span> <span class="token punctuation">(</span>right<span class="token operator">-</span>left<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>                left <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 注意</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>                left <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">></span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>                right <span class="token operator">=</span> mid<span class="token number">-1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 所有元素均大于target</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>right <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 所有元素均小于target</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">==</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> left <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">==</span> target <span class="token operator">?</span> right <span class="token operator">:</span> right<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>将该算法使用另外一种写法：</p><p>使用(left,right]定义</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">ceil2</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 寻找比target大的最小索引值</span>    <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> right <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span> left <span class="token operator">&lt;</span> right <span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 使用普通的向下取整即可避免死循环</span>        <span class="token keyword">int</span> mid <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token punctuation">(</span>right<span class="token operator">-</span>left<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span> nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> target <span class="token punctuation">)</span>            left <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token comment" spellcheck="true">// arr[mid] > target</span>            right <span class="token operator">=</span> mid<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 如果该索引-1就是target本身, 该索引+1即为返回值</span>    <span class="token keyword">if</span><span class="token punctuation">(</span> right <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>right<span class="token number">-1</span><span class="token punctuation">]</span> <span class="token operator">==</span> target <span class="token punctuation">)</span>        <span class="token keyword">return</span> right<span class="token number">-1</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 否则, 该索引即为返回值</span>    <span class="token keyword">return</span> right<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="6-全部算法测试"><a href="#6-全部算法测试" class="headerlink" title="6.全部算法测试"></a>6.全部算法测试</h2><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> nums <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> target <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token function">Solution</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">search1</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> target<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// 3</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token function">Solution</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">search2</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> target<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// 3</span>    <span class="token comment" spellcheck="true">// 寻找第一个等于target的index,最左侧index</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token function">Solution</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">search3</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> target<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// 1</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token function">Solution</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">search4</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> target<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// 4</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token function">Solution</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ceil1</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 0</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token function">Solution</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ceil2</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 0</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token function">Solution</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ceil1</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 5</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token function">Solution</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ceil2</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 5</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token function">Solution</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ceil1</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 6</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token function">Solution</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ceil2</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 6</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token function">Solution</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">floor1</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// -1</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token function">Solution</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">floor2</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// -1</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token function">Solution</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">floor1</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 5</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token function">Solution</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">floor2</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 5</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token function">Solution</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">floor1</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 6</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token function">Solution</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">floor2</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 6</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 二分搜索法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ STL源码剖析之动态数组vector</title>
      <link href="/2019/10/13/vector/"/>
      <url>/2019/10/13/vector/</url>
      
        <content type="html"><![CDATA[<h1 id="STL源码剖析之动态数组vector"><a href="#STL源码剖析之动态数组vector" class="headerlink" title="STL源码剖析之动态数组vector"></a>STL源码剖析之动态数组vector</h1><h2 id="0-导语"><a href="#0-导语" class="headerlink" title="0.导语"></a>0.导语</h2><p>vector的数据安排以及操作方式，与array非常相似。两者的唯一差别在于空间的运用的灵活性，array是静态的，一旦配置了就不能改变，而 vector是动态空间，随着元素的加入，它的内部机制会自行扩充空间以容纳新元素。下面一起来看一下vector的”内部机制”，怎么来实现空间配置策略的。</p><h2 id="1-vector"><a href="#1-vector" class="headerlink" title="1.vector"></a>1.vector</h2><p>在<code>_Vector_base</code>中开头有两行比较难理解，下面一个一个分析：</p><h3 id="1-1-Tp-alloc-type"><a href="#1-1-Tp-alloc-type" class="headerlink" title="1.1 _Tp_alloc_type"></a>1.1 _Tp_alloc_type</h3><p>开头处定义：</p><pre><code> typedef typename __gnu_cxx::__alloc_traits&lt;_Alloc&gt;::template rebind&lt;_Tp&gt;::other _Tp_alloc_type;</code></pre><p>在<code>__gnu_cxx::__alloc_traits</code>中：对应文件为：<code>ext/alloc_traits.h</code></p><pre class=" language-cpp"><code class="language-cpp"> <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _Tp<span class="token operator">></span>      <span class="token keyword">struct</span> rebind      <span class="token punctuation">{</span> <span class="token keyword">typedef</span> <span class="token keyword">typename</span> _Base_type<span class="token operator">::</span><span class="token keyword">template</span> rebind_alloc<span class="token operator">&lt;</span>_Tp<span class="token operator">></span> other<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>等价于</p><pre><code>typename __gnu_cxx::__alloc_traits&lt;_Alloc&gt;::template rebind&lt;_Tp&gt;::other </code></pre><p>等价于：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">typename</span> _Base_type<span class="token operator">::</span><span class="token keyword">template</span> rebind_alloc<span class="token operator">&lt;</span>_Tp<span class="token operator">></span></code></pre><p>而<code>_Base_type</code>是：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">typedef</span> std<span class="token operator">::</span>allocator_traits<span class="token operator">&lt;</span>_Alloc<span class="token operator">></span>           _Base_type<span class="token punctuation">;</span></code></pre><p>所以上述等价于：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">typename</span> std<span class="token operator">::</span>allocator_traits<span class="token operator">&lt;</span>_Alloc<span class="token operator">></span><span class="token operator">::</span><span class="token keyword">template</span> rebind_alloc<span class="token operator">&lt;</span>_Tp<span class="token operator">></span></code></pre><p>继续到<code>allocator_traits</code>中寻找</p><p>找到了：</p><pre class=" language-cpp"><code class="language-cpp">  <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _Up<span class="token operator">></span>    <span class="token keyword">using</span> rebind_alloc <span class="token operator">=</span> allocator<span class="token operator">&lt;</span>_Up<span class="token operator">></span><span class="token punctuation">;</span></code></pre><p>于是：</p><pre class=" language-cpp"><code class="language-cpp">std<span class="token operator">::</span>allocator_traits<span class="token operator">&lt;</span>_Alloc<span class="token operator">></span><span class="token operator">::</span><span class="token keyword">template</span> rebind_alloc<span class="token operator">&lt;</span>_Tp<span class="token operator">></span></code></pre><p>等价于：</p><pre class=" language-cpp"><code class="language-cpp">allocator<span class="token operator">&lt;</span>_Tp<span class="token operator">></span></code></pre><blockquote><p>小结</p></blockquote><pre class=" language-cpp"><code class="language-cpp"> <span class="token keyword">typedef</span> <span class="token keyword">typename</span> __gnu_cxx<span class="token operator">::</span>__alloc_traits<span class="token operator">&lt;</span>_Alloc<span class="token operator">></span><span class="token operator">::</span><span class="token keyword">template</span> rebind<span class="token operator">&lt;</span>_Tp<span class="token operator">></span><span class="token operator">::</span>other _Tp_alloc_type<span class="token punctuation">;</span></code></pre><p>等价于：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">typedef</span> allocator<span class="token operator">&lt;</span>_Tp<span class="token operator">></span> _Tp_alloc_type</code></pre><h3 id="1-2-pointer"><a href="#1-2-pointer" class="headerlink" title="1.2 pointer"></a>1.2 pointer</h3><p>而<code>pointer</code>：</p><pre class=" language-cpp"><code class="language-cpp"> <span class="token keyword">typedef</span> <span class="token keyword">typename</span> __gnu_cxx<span class="token operator">::</span>__alloc_traits<span class="token operator">&lt;</span>_Tp_alloc_type<span class="token operator">></span><span class="token operator">::</span>pointer           pointer<span class="token punctuation">;</span></code></pre><p>等价于：</p><pre class=" language-cpp"><code class="language-cpp"> <span class="token keyword">typedef</span> <span class="token keyword">typename</span> __gnu_cxx<span class="token operator">::</span>__alloc_traits<span class="token operator">&lt;</span>allocator<span class="token operator">&lt;</span>_Tp<span class="token operator">>></span><span class="token operator">::</span>pointer           pointer<span class="token punctuation">;</span></code></pre><p>根据下面两行：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">typedef</span> std<span class="token operator">::</span>allocator_traits<span class="token operator">&lt;</span>_Alloc<span class="token operator">></span>           _Base_type<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">typename</span> _Base_type<span class="token operator">::</span>pointer            pointer<span class="token punctuation">;</span></code></pre><p>又等价于：</p><pre><code> typedef std::allocator_traits&lt;_Alloc&gt;::pointer           pointer;</code></pre><p>在<code>allocator_traits</code>中找到下面：</p><pre class=" language-cpp"><code class="language-cpp">  <span class="token comment" spellcheck="true">/**   * @brief   The allocator's pointer type.   *   * @c Alloc::pointer if that type exists, otherwise @c value_type*  */</span>  <span class="token keyword">typedef</span> __pointer pointer<span class="token punctuation">;</span></code></pre><p>注释中说了如果存在就是<code>Alloc::pointer</code>，否则为<code>value_type *</code>。</p><blockquote><p>小结</p></blockquote><pre class=" language-cpp"><code class="language-cpp"> <span class="token keyword">typedef</span> <span class="token keyword">typename</span> __gnu_cxx<span class="token operator">::</span>__alloc_traits<span class="token operator">&lt;</span>_Tp_alloc_type<span class="token operator">></span><span class="token operator">::</span>pointer           pointer<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 或者</span> <span class="token keyword">typedef</span> <span class="token keyword">typename</span> __gnu_cxx<span class="token operator">::</span>__alloc_traits<span class="token operator">&lt;</span>allocator<span class="token operator">&lt;</span>_Tp<span class="token operator">>></span><span class="token operator">::</span>pointer           pointer<span class="token punctuation">;</span></code></pre><p>等价于</p><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">/*** @brief   The allocator's pointer type.** @c Alloc::pointer if that type exists, otherwise @c value_type**/</span><span class="token keyword">typedef</span> __pointer pointer<span class="token punctuation">;</span></code></pre><p>如果存在<code>_Tp_alloc_type::pointer</code>也就是<code>allocator&lt;_Tp&gt;</code>存在就是<code>allocator&lt;_Tp&gt;::pointer</code>，</p><p>这个看<code>allocator.h</code>源码：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">typedef</span> _Tp<span class="token operator">*</span>       pointer<span class="token punctuation">;</span></code></pre><p>否则为<code>value_type*</code>。而<code>value_type</code>为：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">typedef</span> <span class="token keyword">typename</span> _Alloc<span class="token operator">::</span>value_type value_type<span class="token punctuation">;</span></code></pre><p>所以<code>value_type*</code>推导出为：</p><pre class=" language-cpp"><code class="language-cpp">_Tp<span class="token operator">::</span>value_type<span class="token operator">*</span></code></pre><h3 id="1-3-vector的内存管理"><a href="#1-3-vector的内存管理" class="headerlink" title="1.3 vector的内存管理"></a>1.3 vector的内存管理</h3><p><code>_Vector_base</code>中有一个<strong>内存管理器</strong><code>_Vector_impl</code>类，该结构体继承<code>allocator</code>(根据上述1.1等价条件得出)。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _Tp<span class="token punctuation">,</span> <span class="token keyword">typename</span> _Alloc<span class="token operator">></span><span class="token keyword">struct</span> _Vector_base <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//__alloc_traits -> allocator_traits</span>    <span class="token comment" spellcheck="true">// typedef allocator&lt;_Tp> _Tp_alloc_type</span>    <span class="token keyword">typedef</span> <span class="token keyword">typename</span> __gnu_cxx<span class="token operator">::</span>__alloc_traits<span class="token operator">&lt;</span>_Alloc<span class="token operator">></span><span class="token operator">::</span><span class="token keyword">template</span>    rebind<span class="token operator">&lt;</span>_Tp<span class="token operator">></span><span class="token operator">::</span>other _Tp_alloc_type<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//  _Tp::value_type* or _Tp*</span>    <span class="token keyword">typedef</span> <span class="token keyword">typename</span> __gnu_cxx<span class="token operator">::</span>__alloc_traits<span class="token operator">&lt;</span>_Tp_alloc_type<span class="token operator">></span><span class="token operator">::</span>pointer            pointer<span class="token punctuation">;</span>    <span class="token keyword">struct</span> _Vector_impl            <span class="token operator">:</span> <span class="token keyword">public</span> _Tp_alloc_type <span class="token punctuation">{</span>        pointer _M_start<span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// 使用空间起始位置    </span>        pointer _M_finish<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 使用空间结束位置</span>        pointer _M_end_of_storage<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 可使用空间结束位置 </span>        <span class="token function">_Vector_impl</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token operator">:</span> <span class="token function">_Tp_alloc_type</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">_M_start</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">_M_finish</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">_M_end_of_storage</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>        <span class="token function">_Vector_impl</span><span class="token punctuation">(</span>_Tp_alloc_type <span class="token keyword">const</span> <span class="token operator">&amp;</span>__a<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">// vector数据交换，只交换内存地址，不交换数据</span>        <span class="token keyword">void</span> <span class="token function">_M_swap_data</span><span class="token punctuation">(</span>_Vector_impl <span class="token operator">&amp;</span>__x<span class="token punctuation">)</span>        _GLIBCXX_NOEXCEPT        <span class="token punctuation">{</span>            std<span class="token operator">::</span><span class="token function">swap</span><span class="token punctuation">(</span>_M_start<span class="token punctuation">,</span> __x<span class="token punctuation">.</span>_M_start<span class="token punctuation">)</span><span class="token punctuation">;</span>            std<span class="token operator">::</span><span class="token function">swap</span><span class="token punctuation">(</span>_M_finish<span class="token punctuation">,</span> __x<span class="token punctuation">.</span>_M_finish<span class="token punctuation">)</span><span class="token punctuation">;</span>            std<span class="token operator">::</span><span class="token function">swap</span><span class="token punctuation">(</span>_M_end_of_storage<span class="token punctuation">,</span> __x<span class="token punctuation">.</span>_M_end_of_storage<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">typedef</span> _Alloc allocator_type<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 前面我们知道_Vector_impl继承自allocator分配器，而这个又是_Tp_alloc_type，所以这里返回的就是_M_impl的基类。</span>    _Tp_alloc_type <span class="token operator">&amp;</span>    <span class="token function">_M_get_Tp_allocator</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    _GLIBCXX_NOEXCEPT    <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">static_cast</span><span class="token operator">&lt;</span>_Tp_alloc_type <span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token keyword">const</span> _Tp_alloc_type <span class="token operator">&amp;</span>    <span class="token function">_M_get_Tp_allocator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>    _GLIBCXX_NOEXCEPT    <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">static_cast</span><span class="token operator">&lt;</span><span class="token keyword">const</span> _Tp_alloc_type <span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    allocator_type    <span class="token comment" spellcheck="true">// 获取传递进来的分配器      </span>    <span class="token function">get_allocator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>    _GLIBCXX_NOEXCEPT    <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token function">allocator_type</span><span class="token punctuation">(</span><span class="token function">_M_get_Tp_allocator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token function">_Vector_base</span><span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token operator">:</span> <span class="token function">_M_impl</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token function">_Vector_base</span><span class="token punctuation">(</span><span class="token keyword">const</span> allocator_type <span class="token operator">&amp;</span>__a<span class="token punctuation">)</span>    _GLIBCXX_NOEXCEPT            <span class="token operator">:</span> <span class="token function">_M_impl</span><span class="token punctuation">(</span>__a<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token function">_Vector_base</span><span class="token punctuation">(</span>size_t __n<span class="token punctuation">)</span>            <span class="token operator">:</span> <span class="token function">_M_impl</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">_M_create_storage</span><span class="token punctuation">(</span>__n<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token function">_Vector_base</span><span class="token punctuation">(</span>size_t __n<span class="token punctuation">,</span> <span class="token keyword">const</span> allocator_type <span class="token operator">&amp;</span>__a<span class="token punctuation">)</span>            <span class="token operator">:</span> <span class="token function">_M_impl</span><span class="token punctuation">(</span>__a<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">_M_create_storage</span><span class="token punctuation">(</span>__n<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token macro property">#<span class="token directive keyword">if</span> __cplusplus >= 201103L</span>    <span class="token function">_Vector_base</span><span class="token punctuation">(</span>_Tp_alloc_type<span class="token operator">&amp;&amp;</span> __a<span class="token punctuation">)</span> <span class="token keyword">noexcept</span>    <span class="token operator">:</span> <span class="token function">_M_impl</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>__a<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 移动构造函数，只交换3个指针，不copy数据</span>    <span class="token function">_Vector_base</span><span class="token punctuation">(</span>_Vector_base<span class="token operator">&amp;&amp;</span> __x<span class="token punctuation">)</span> <span class="token keyword">noexcept</span>    <span class="token operator">:</span> <span class="token function">_M_impl</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>__x<span class="token punctuation">.</span><span class="token function">_M_get_Tp_allocator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span> <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span><span class="token function">_M_swap_data</span><span class="token punctuation">(</span>__x<span class="token punctuation">.</span>_M_impl<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token function">_Vector_base</span><span class="token punctuation">(</span>_Vector_base<span class="token operator">&amp;&amp;</span> __x<span class="token punctuation">,</span> <span class="token keyword">const</span> allocator_type<span class="token operator">&amp;</span> __a<span class="token punctuation">)</span>    <span class="token operator">:</span> <span class="token function">_M_impl</span><span class="token punctuation">(</span>__a<span class="token punctuation">)</span>    <span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>__x<span class="token punctuation">.</span><span class="token function">get_allocator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> __a<span class="token punctuation">)</span>    <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span><span class="token function">_M_swap_data</span><span class="token punctuation">(</span>__x<span class="token punctuation">.</span>_M_impl<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">else</span>    <span class="token punctuation">{</span>      size_t __n <span class="token operator">=</span> __x<span class="token punctuation">.</span>_M_impl<span class="token punctuation">.</span>_M_finish <span class="token operator">-</span> __x<span class="token punctuation">.</span>_M_impl<span class="token punctuation">.</span>_M_start<span class="token punctuation">;</span>      <span class="token function">_M_create_storage</span><span class="token punctuation">(</span>__n<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token macro property">#<span class="token directive keyword">endif</span></span>    <span class="token operator">~</span><span class="token function">_Vector_base</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    _GLIBCXX_NOEXCEPT    <span class="token punctuation">{</span>        <span class="token function">_M_deallocate</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_start<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_end_of_storage                                              <span class="token operator">-</span> <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_start<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">public</span><span class="token operator">:</span>    _Vector_impl _M_impl<span class="token punctuation">;</span>    pointer <span class="token function">_M_allocate</span><span class="token punctuation">(</span>size_t __n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">typedef</span> __gnu_cxx<span class="token operator">::</span>__alloc_traits <span class="token operator">&lt;</span>_Tp_alloc_type<span class="token operator">></span> _Tr<span class="token punctuation">;</span>        <span class="token keyword">return</span> __n <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">?</span> _Tr<span class="token operator">::</span><span class="token function">allocate</span><span class="token punctuation">(</span>_M_impl<span class="token punctuation">,</span> __n<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 同_M_deallocate，一直往后调用的就是malloc函数</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">_M_deallocate</span><span class="token punctuation">(</span>pointer __p<span class="token punctuation">,</span> size_t __n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">typedef</span> __gnu_cxx<span class="token operator">::</span>__alloc_traits <span class="token operator">&lt;</span>_Tp_alloc_type<span class="token operator">></span> _Tr<span class="token punctuation">;</span>         <span class="token keyword">if</span> <span class="token punctuation">(</span>__p<span class="token punctuation">)</span>            _Tr<span class="token operator">::</span><span class="token function">deallocate</span><span class="token punctuation">(</span>_M_impl<span class="token punctuation">,</span> __p<span class="token punctuation">,</span> __n<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 最后调用allocator_traits的deallocate,而该函数又是根据传递进来的_M_impl进行deallocate,一直往后，最后调用的就是free函数</span>    <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">_M_create_storage</span><span class="token punctuation">(</span>size_t __n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_start <span class="token operator">=</span> <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">_M_allocate</span><span class="token punctuation">(</span>__n<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_finish <span class="token operator">=</span> <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_start<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_end_of_storage <span class="token operator">=</span> <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_start <span class="token operator">+</span> __n<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>小结：<code>_Vector_base</code>专门负责<code>vector</code>的内存管理，内部类<code>_M_impl</code>通过继承<code>_Tp_alloc_type</code>(也就是allocator)得到内存分配释放的功能，<em>M</em>allocate和<em>M</em>deallocate分别分配和释放vector所用内存，vector只需要负责元素构造和析构。</p><p>在vector中，默认内存分配器为<code>std::allocator&lt;_Tp&gt;</code></p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _Tp<span class="token punctuation">,</span> <span class="token keyword">typename</span> _Alloc <span class="token operator">=</span> std<span class="token operator">::</span>allocator<span class="token operator">&lt;</span>_Tp<span class="token operator">>></span><span class="token keyword">class</span> <span class="token class-name">vector</span> <span class="token operator">:</span> <span class="token keyword">protected</span> _Vector_base<span class="token operator">&lt;</span>_Tp<span class="token punctuation">,</span> _Alloc<span class="token operator">></span> <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><p>vector代码中使用基类的内存函数及typedef等：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _Tp<span class="token punctuation">,</span> <span class="token keyword">typename</span> _Alloc <span class="token operator">=</span> std<span class="token operator">::</span>allocator<span class="token operator">&lt;</span>_Tp<span class="token operator">>></span><span class="token keyword">class</span> <span class="token class-name">vector</span> <span class="token operator">:</span> <span class="token keyword">protected</span> _Vector_base<span class="token operator">&lt;</span>_Tp<span class="token punctuation">,</span> _Alloc<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">typedef</span> _Vector_base<span class="token operator">&lt;</span>_Tp<span class="token punctuation">,</span> _Alloc<span class="token operator">></span> _Base<span class="token punctuation">;</span>    <span class="token keyword">typedef</span> <span class="token keyword">typename</span> _Base<span class="token operator">::</span>_Tp_alloc_type _Tp_alloc_type<span class="token punctuation">;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">typedef</span> <span class="token keyword">typename</span> _Base<span class="token operator">::</span>pointer pointer<span class="token punctuation">;</span><span class="token keyword">protected</span><span class="token operator">:</span>    <span class="token keyword">using</span> _Base<span class="token operator">::</span>_M_allocate<span class="token punctuation">;</span>    <span class="token keyword">using</span> _Base<span class="token operator">::</span>_M_deallocate<span class="token punctuation">;</span>    <span class="token keyword">using</span> _Base<span class="token operator">::</span>_M_impl<span class="token punctuation">;</span>    <span class="token keyword">using</span> _Base<span class="token operator">::</span>_M_get_Tp_allocator<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="2-vector迭代器"><a href="#2-vector迭代器" class="headerlink" title="2.vector迭代器"></a>2.vector迭代器</h2><p>在vector中使用了两种迭代器，分别是正向<code>__normal_iterator</code>与反向迭代器<code>reverse_iterator</code>:</p><p>正向：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">typedef</span> __gnu_cxx<span class="token operator">::</span>__normal_iterator <span class="token operator">&lt;</span>pointer<span class="token punctuation">,</span> vector<span class="token operator">></span> iterator<span class="token punctuation">;</span><span class="token keyword">typedef</span> __gnu_cxx<span class="token operator">::</span>__normal_iterator <span class="token operator">&lt;</span>const_pointer<span class="token punctuation">,</span> vector<span class="token operator">></span> const_iterator<span class="token punctuation">;</span></code></pre><p>反向：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">typedef</span> std<span class="token operator">::</span>reverse_iterator<span class="token operator">&lt;</span>const_iterator<span class="token operator">></span> const_reverse_iterator<span class="token punctuation">;</span><span class="token keyword">typedef</span> std<span class="token operator">::</span>reverse_iterator<span class="token operator">&lt;</span>iterator<span class="token operator">></span> reverse_iterator<span class="token punctuation">;</span></code></pre><p><code>__normal_iterator</code>与<code>reverse_iterator</code>都定义于stl_iterator.h，封装了vector元素的指针。</p><h3 id="2-1-正向"><a href="#2-1-正向" class="headerlink" title="2.1 正向"></a>2.1 正向</h3><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _Iterator<span class="token punctuation">,</span> <span class="token keyword">typename</span> _Container<span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">__normal_iterator</span><span class="token punctuation">{</span><span class="token keyword">protected</span><span class="token operator">:</span>    _Iterator _M_current<span class="token punctuation">;</span>    <span class="token keyword">typedef</span> iterator_traits<span class="token operator">&lt;</span>_Iterator<span class="token operator">></span>        __traits_type<span class="token punctuation">;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">typedef</span> _Iterator                    iterator_type<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// iterator必须包含的五种typedef</span>    <span class="token keyword">typedef</span> <span class="token keyword">typename</span> __traits_type<span class="token operator">::</span>iterator_category iterator_category<span class="token punctuation">;</span>    <span class="token keyword">typedef</span> <span class="token keyword">typename</span> __traits_type<span class="token operator">::</span>value_type      value_type<span class="token punctuation">;</span>    <span class="token keyword">typedef</span> <span class="token keyword">typename</span> __traits_type<span class="token operator">::</span>difference_type     difference_type<span class="token punctuation">;</span>    <span class="token keyword">typedef</span> <span class="token keyword">typename</span> __traits_type<span class="token operator">::</span>reference     reference<span class="token punctuation">;</span>    <span class="token keyword">typedef</span> <span class="token keyword">typename</span> __traits_type<span class="token operator">::</span>pointer       pointer<span class="token punctuation">;</span>    _GLIBCXX_CONSTEXPR <span class="token function">__normal_iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> _GLIBCXX_NOEXCEPT    <span class="token operator">:</span> <span class="token function">_M_current</span><span class="token punctuation">(</span><span class="token function">_Iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>    <span class="token keyword">explicit</span>    <span class="token function">__normal_iterator</span><span class="token punctuation">(</span><span class="token keyword">const</span> _Iterator<span class="token operator">&amp;</span> __i<span class="token punctuation">)</span> _GLIBCXX_NOEXCEPT    <span class="token operator">:</span> <span class="token function">_M_current</span><span class="token punctuation">(</span>__i<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// Allow iterator to const_iterator conversion</span>    <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _Iter<span class="token operator">></span>    <span class="token function">__normal_iterator</span><span class="token punctuation">(</span><span class="token keyword">const</span> __normal_iterator<span class="token operator">&lt;</span>_Iter<span class="token punctuation">,</span>            <span class="token keyword">typename</span> __enable_if<span class="token operator">&lt;</span>            <span class="token punctuation">(</span>std<span class="token operator">::</span>__are_same<span class="token operator">&lt;</span>_Iter<span class="token punctuation">,</span> <span class="token keyword">typename</span> _Container<span class="token operator">::</span>pointer<span class="token operator">></span><span class="token operator">::</span>__value<span class="token punctuation">)</span><span class="token punctuation">,</span>            _Container<span class="token operator">></span><span class="token operator">::</span>__type<span class="token operator">></span><span class="token operator">&amp;</span> __i<span class="token punctuation">)</span> _GLIBCXX_NOEXCEPT    <span class="token operator">:</span> <span class="token function">_M_current</span><span class="token punctuation">(</span>__i<span class="token punctuation">.</span><span class="token function">base</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// Forward iterator requirements</span>    reference    <span class="token keyword">operator</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> _GLIBCXX_NOEXCEPT    <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token operator">*</span>_M_current<span class="token punctuation">;</span> <span class="token punctuation">}</span>    pointer    <span class="token keyword">operator</span><span class="token operator">-</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> _GLIBCXX_NOEXCEPT    <span class="token punctuation">{</span> <span class="token keyword">return</span> _M_current<span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 前置++</span>    __normal_iterator<span class="token operator">&amp;</span>    <span class="token keyword">operator</span><span class="token operator">++</span><span class="token punctuation">(</span><span class="token punctuation">)</span> _GLIBCXX_NOEXCEPT    <span class="token punctuation">{</span>        <span class="token operator">++</span>_M_current<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 后置++</span>    __normal_iterator    <span class="token keyword">operator</span><span class="token operator">++</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> _GLIBCXX_NOEXCEPT    <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token function">__normal_iterator</span><span class="token punctuation">(</span>_M_current<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 前置--</span>    <span class="token comment" spellcheck="true">// Bidirectional iterator requirements</span>    __normal_iterator<span class="token operator">&amp;</span>    <span class="token keyword">operator</span><span class="token operator">--</span><span class="token punctuation">(</span><span class="token punctuation">)</span> _GLIBCXX_NOEXCEPT    <span class="token punctuation">{</span>        <span class="token operator">--</span>_M_current<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 后置--</span>    __normal_iterator    <span class="token keyword">operator</span><span class="token operator">--</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> _GLIBCXX_NOEXCEPT    <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token function">__normal_iterator</span><span class="token punctuation">(</span>_M_current<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 随机访问迭代器都要重载[]操作符</span>    <span class="token comment" spellcheck="true">// Random access iterator requirements</span>    reference    <span class="token keyword">operator</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>difference_type __n<span class="token punctuation">)</span> <span class="token keyword">const</span> _GLIBCXX_NOEXCEPT    <span class="token punctuation">{</span> <span class="token keyword">return</span> _M_current<span class="token punctuation">[</span>__n<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// +=操作符 跳跃n个difference_type</span>    __normal_iterator<span class="token operator">&amp;</span>    <span class="token keyword">operator</span><span class="token operator">+</span><span class="token operator">=</span><span class="token punctuation">(</span>difference_type __n<span class="token punctuation">)</span> _GLIBCXX_NOEXCEPT    <span class="token punctuation">{</span> _M_current <span class="token operator">+</span><span class="token operator">=</span> __n<span class="token punctuation">;</span> <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// +操作符 跳跃n个difference_type</span>    __normal_iterator    <span class="token keyword">operator</span><span class="token operator">+</span><span class="token punctuation">(</span>difference_type __n<span class="token punctuation">)</span> <span class="token keyword">const</span> _GLIBCXX_NOEXCEPT    <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token function">__normal_iterator</span><span class="token punctuation">(</span>_M_current <span class="token operator">+</span> __n<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// -=操作符 后退n个difference_type</span>    __normal_iterator<span class="token operator">&amp;</span>    <span class="token keyword">operator</span><span class="token operator">-</span><span class="token operator">=</span><span class="token punctuation">(</span>difference_type __n<span class="token punctuation">)</span> _GLIBCXX_NOEXCEPT    <span class="token punctuation">{</span> _M_current <span class="token operator">-</span><span class="token operator">=</span> __n<span class="token punctuation">;</span> <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// -操作符 后退n个difference_type</span>    __normal_iterator    <span class="token keyword">operator</span><span class="token operator">-</span><span class="token punctuation">(</span>difference_type __n<span class="token punctuation">)</span> <span class="token keyword">const</span> _GLIBCXX_NOEXCEPT    <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token function">__normal_iterator</span><span class="token punctuation">(</span>_M_current <span class="token operator">-</span> __n<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token keyword">const</span> _Iterator<span class="token operator">&amp;</span>    <span class="token function">base</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> _GLIBCXX_NOEXCEPT    <span class="token punctuation">{</span> <span class="token keyword">return</span> _M_current<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p><em>M</em>current是指向迭代器位置的指针，这是一个随机访问型指针，operator+和operator-等移动操作可以直接移动到目的地，非随机访问型指针只能一步步移动。</p><h3 id="2-2-反向"><a href="#2-2-反向" class="headerlink" title="2.2 反向"></a>2.2 反向</h3><p>vector还会使用reverse_iterator，即逆序迭代器，顾名思义，其移动方向与普通迭代器相反</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _Iterator<span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">reverse_iterator</span><span class="token operator">:</span> <span class="token keyword">public</span> iterator<span class="token operator">&lt;</span><span class="token keyword">typename</span> iterator_traits<span class="token operator">&lt;</span>_Iterator<span class="token operator">></span><span class="token operator">::</span>iterator_category<span class="token punctuation">,</span>            <span class="token keyword">typename</span> iterator_traits<span class="token operator">&lt;</span>_Iterator<span class="token operator">></span><span class="token operator">::</span>value_type<span class="token punctuation">,</span>            <span class="token keyword">typename</span> iterator_traits<span class="token operator">&lt;</span>_Iterator<span class="token operator">></span><span class="token operator">::</span>difference_type<span class="token punctuation">,</span>            <span class="token keyword">typename</span> iterator_traits<span class="token operator">&lt;</span>_Iterator<span class="token operator">></span><span class="token operator">::</span>pointer<span class="token punctuation">,</span>                    <span class="token keyword">typename</span> iterator_traits<span class="token operator">&lt;</span>_Iterator<span class="token operator">></span><span class="token operator">::</span>reference<span class="token operator">></span><span class="token punctuation">{</span><span class="token keyword">protected</span><span class="token operator">:</span>    _Iterator current<span class="token punctuation">;</span>    <span class="token keyword">typedef</span> iterator_traits<span class="token operator">&lt;</span>_Iterator<span class="token operator">></span>        __traits_type<span class="token punctuation">;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">typedef</span> _Iterator                    iterator_type<span class="token punctuation">;</span>    <span class="token keyword">typedef</span> <span class="token keyword">typename</span> __traits_type<span class="token operator">::</span>difference_type    difference_type<span class="token punctuation">;</span>    <span class="token keyword">typedef</span> <span class="token keyword">typename</span> __traits_type<span class="token operator">::</span>pointer        pointer<span class="token punctuation">;</span>    <span class="token keyword">typedef</span> <span class="token keyword">typename</span> __traits_type<span class="token operator">::</span>reference        reference<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 省略不重要的代码</span>    <span class="token comment" spellcheck="true">// 该迭代器是从后面end()开始，需要往前一步，才可以获取到有效的迭代器位置</span>    reference    <span class="token keyword">operator</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>    <span class="token punctuation">{</span>        _Iterator __tmp <span class="token operator">=</span> current<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">*</span><span class="token operator">--</span>__tmp<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 通过调用上述*操作符直接实现</span>    pointer    <span class="token keyword">operator</span><span class="token operator">-</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>    <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token keyword">operator</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 前置++操作符完成后退任务</span>    reverse_iterator<span class="token operator">&amp;</span>    <span class="token keyword">operator</span><span class="token operator">++</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token operator">--</span>current<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 后置++</span>    reverse_iterator    <span class="token keyword">operator</span><span class="token operator">++</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        reverse_iterator __tmp <span class="token operator">=</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>        <span class="token operator">--</span>current<span class="token punctuation">;</span>        <span class="token keyword">return</span> __tmp<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 前置--操作符完成前进任务</span>    reverse_iterator<span class="token operator">&amp;</span>    <span class="token keyword">operator</span><span class="token operator">--</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token operator">++</span>current<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 后置--</span>    reverse_iterator    <span class="token keyword">operator</span><span class="token operator">--</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        reverse_iterator __tmp <span class="token operator">=</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>        <span class="token operator">++</span>current<span class="token punctuation">;</span>        <span class="token keyword">return</span> __tmp<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// +操作符</span>    reverse_iterator    <span class="token keyword">operator</span><span class="token operator">+</span><span class="token punctuation">(</span>difference_type __n<span class="token punctuation">)</span> <span class="token keyword">const</span>    <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token function">reverse_iterator</span><span class="token punctuation">(</span>current <span class="token operator">-</span> __n<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// +=操作符</span>    reverse_iterator<span class="token operator">&amp;</span>    <span class="token keyword">operator</span><span class="token operator">+</span><span class="token operator">=</span><span class="token punctuation">(</span>difference_type __n<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        current <span class="token operator">-</span><span class="token operator">=</span> __n<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// -操作符</span>    reverse_iterator    <span class="token keyword">operator</span><span class="token operator">-</span><span class="token punctuation">(</span>difference_type __n<span class="token punctuation">)</span> <span class="token keyword">const</span>    <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token function">reverse_iterator</span><span class="token punctuation">(</span>current <span class="token operator">+</span> __n<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// -=操作符</span>    reverse_iterator<span class="token operator">&amp;</span>    <span class="token keyword">operator</span><span class="token operator">-</span><span class="token operator">=</span><span class="token punctuation">(</span>difference_type __n<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        current <span class="token operator">+</span><span class="token operator">=</span> __n<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// []操作符</span>    reference    <span class="token keyword">operator</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>difference_type __n<span class="token punctuation">)</span> <span class="token keyword">const</span>    <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token keyword">this</span> <span class="token operator">+</span> __n<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><h2 id="3-vector的数据结构"><a href="#3-vector的数据结构" class="headerlink" title="3.vector的数据结构"></a>3.vector的数据结构</h2><p>vector内存由<em>M</em>impl中的M_start，<em>M</em>finish，<em>M</em>end_of_storage三个指针管理，所有关于地址，容量大小等操作都需要用到这三个指针：</p><pre class=" language-cpp"><code class="language-cpp">iterator <span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> _GLIBCXX_NOEXCEPT    <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token function">iterator</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_start<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>iterator <span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span> _GLIBCXX_NOEXCEPT    <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token function">iterator</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_finish<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>reverse_iterator  <span class="token function">rbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span>    <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token function">reverse_iterator</span><span class="token punctuation">(</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>reverse_iterator <span class="token function">rend</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span>    <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token function">reverse_iterator</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>size_type <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> _GLIBCXX_NOEXCEPT    <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token function">size_type</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_finish <span class="token operator">-</span> <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_start<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>size_type <span class="token function">capacity</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> _GLIBCXX_NOEXCEPT    <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token function">size_type</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_end_of_storage <span class="token operator">-</span> <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_start<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">bool</span> <span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> _GLIBCXX_NOEXCEPT    <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre><p><img src="https://raw.githubusercontent.com/Light-City/cloudimg/master/vector_1.png" alt="vector_1.png"></p><p><em>M</em>finish和<em>M</em>end_of_storage之间的空间没有数据，有时候这是一种浪费，c++11提供了一个很有用的函数shrink_to_fit()，将这段未使用空间释放，主要调用了下面代码，</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _Alloc<span class="token operator">></span><span class="token keyword">bool</span> vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token punctuation">,</span> _Alloc<span class="token operator">></span><span class="token operator">::</span><span class="token function">_M_shrink_to_fit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">capacity</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token keyword">int</span><span class="token punctuation">(</span>_S_word_bit<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 64位系统为64bytes</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    __try    <span class="token punctuation">{</span>        <span class="token function">_M_reallocate</span><span class="token punctuation">(</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">__catch</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>         <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-cpp"><code class="language-cpp"> <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _Alloc<span class="token operator">></span><span class="token keyword">void</span> vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token punctuation">,</span> _Alloc<span class="token operator">></span><span class="token operator">::</span><span class="token function">_M_reallocate</span><span class="token punctuation">(</span>size_type __n<span class="token punctuation">)</span><span class="token punctuation">{</span>    _Bit_type<span class="token operator">*</span> __q <span class="token operator">=</span> <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">_M_allocate</span><span class="token punctuation">(</span>__n<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_finish <span class="token operator">=</span> <span class="token function">_M_copy_aligned</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                    <span class="token function">iterator</span><span class="token punctuation">(</span>__q<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">_M_deallocate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_start <span class="token operator">=</span> <span class="token function">iterator</span><span class="token punctuation">(</span>__q<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_end_of_storage <span class="token operator">=</span> __q <span class="token operator">+</span> <span class="token function">_S_nword</span><span class="token punctuation">(</span>__n<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>而<code>_M_copy_aligned</code>通过两个std::copy实现:</p><p>第一次swap把<code>__first</code>的指针与<code>__last</code>的指针之间的数据拷贝到<code>__result</code>指针所指向的起始位置。<br>第二次swap获得<code>__last</code>的指针对应的迭代器。</p><pre class=" language-cpp"><code class="language-cpp">iterator<span class="token function">_M_copy_aligned</span><span class="token punctuation">(</span>const_iterator __first<span class="token punctuation">,</span> const_iterator __last<span class="token punctuation">,</span>        iterator __result<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// _Bit_type * _M_p; _Bit_type为unsigned long类型</span>    _Bit_type<span class="token operator">*</span> __q <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">copy</span><span class="token punctuation">(</span>__first<span class="token punctuation">.</span>_M_p<span class="token punctuation">,</span> __last<span class="token punctuation">.</span>_M_p<span class="token punctuation">,</span> __result<span class="token punctuation">.</span>_M_p<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> std<span class="token operator">::</span><span class="token function">copy</span><span class="token punctuation">(</span><span class="token function">const_iterator</span><span class="token punctuation">(</span>__last<span class="token punctuation">.</span>_M_p<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> __last<span class="token punctuation">,</span>            <span class="token function">iterator</span><span class="token punctuation">(</span>__q<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>先分配size()大小的内存空间，用于存储<code>begin()</code>与<code>end()</code>之间的数据，释放原来的vector空间，新的vector只包含size()数量的数据，并修改<code>_M_start</code>与<code>_M_end_of_storage</code>指向。</p><h2 id="4-vector构造与析构"><a href="#4-vector构造与析构" class="headerlink" title="4.vector构造与析构"></a>4.vector构造与析构</h2><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//使用默认内存分配器</span><span class="token function">vector</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">_Base</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span> <span class="token comment" spellcheck="true">//指定内存分配器</span><span class="token keyword">explicit</span> <span class="token function">vector</span><span class="token punctuation">(</span><span class="token keyword">const</span> allocator_type<span class="token operator">&amp;</span> __a<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">_Base</span><span class="token punctuation">(</span>__a<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//初始化为n个__value值，如果没指定就使用该类型默认值</span><span class="token keyword">explicit</span> <span class="token function">vector</span><span class="token punctuation">(</span>size_type __n<span class="token punctuation">,</span> <span class="token keyword">const</span> value_type<span class="token operator">&amp;</span> __value <span class="token operator">=</span> <span class="token function">value_type</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>             <span class="token keyword">const</span> allocator_type<span class="token operator">&amp;</span> __a <span class="token operator">=</span> <span class="token function">allocator_type</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token function">_Base</span><span class="token punctuation">(</span>__n<span class="token punctuation">,</span> __a<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token function">_M_fill_initialize</span><span class="token punctuation">(</span>__n<span class="token punctuation">,</span> __value<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//拷贝构造函数</span><span class="token function">vector</span><span class="token punctuation">(</span><span class="token keyword">const</span> vector<span class="token operator">&amp;</span> __x<span class="token punctuation">)</span>    <span class="token operator">:</span> <span class="token function">_Base</span><span class="token punctuation">(</span>__x<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    _Alloc_traits<span class="token operator">::</span><span class="token function">_S_select_on_copy</span><span class="token punctuation">(</span>__x<span class="token punctuation">.</span><span class="token function">_M_get_Tp_allocator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_finish <span class="token operator">=</span>    std<span class="token operator">::</span><span class="token function">__uninitialized_copy_a</span><span class="token punctuation">(</span>__x<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> __x<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                                <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_start<span class="token punctuation">,</span>                                <span class="token function">_M_get_Tp_allocator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//c++11的移动构造函数，获取__x的M_start，_M_finish，_M_end_of_storage，并不需要数据拷贝</span><span class="token function">vector</span><span class="token punctuation">(</span>vector<span class="token operator">&amp;&amp;</span> <span class="token punctuation">)</span> <span class="token keyword">noexcept</span>    <span class="token operator">:</span> <span class="token function">_Base</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>__x<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//从list中拷贝数据，也是c++11才有的</span> <span class="token function">vector</span><span class="token punctuation">(</span>initializer_list<span class="token operator">&lt;</span>value_type<span class="token operator">></span> __l<span class="token punctuation">,</span>        <span class="token keyword">const</span> allocator_type<span class="token operator">&amp;</span> __a <span class="token operator">=</span> <span class="token function">allocator_type</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token function">_Base</span><span class="token punctuation">(</span>__a<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">_M_range_initialize</span><span class="token punctuation">(</span>__l<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> __l<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">random_access_iterator_tag</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//支持vector使用两个迭代器范围内的值初始化，除了stl的迭代器，也可以是数组地址</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _InputIterator<span class="token punctuation">,</span>        <span class="token keyword">typename</span> <span class="token operator">=</span> std<span class="token operator">::</span>_RequireInputIter<span class="token operator">&lt;</span>_InputIterator<span class="token operator">>></span><span class="token function">vector</span><span class="token punctuation">(</span>_InputIterator __first<span class="token punctuation">,</span> _InputIterator __last<span class="token punctuation">,</span>        <span class="token keyword">const</span> allocator_type<span class="token operator">&amp;</span> __a <span class="token operator">=</span> <span class="token function">allocator_type</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token function">_Base</span><span class="token punctuation">(</span>__a<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token function">_M_initialize_dispatch</span><span class="token punctuation">(</span>__first<span class="token punctuation">,</span> __last<span class="token punctuation">,</span> <span class="token function">__false_type</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//只析构所有元素，释放内存由vector_base完成</span><span class="token operator">~</span><span class="token function">vector</span><span class="token punctuation">(</span><span class="token punctuation">)</span> _GLIBCXX_NOEXCEPT<span class="token punctuation">{</span> std<span class="token operator">::</span><span class="token function">_Destroy</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_start<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_finish<span class="token punctuation">,</span><span class="token function">_M_get_Tp_allocator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre><h2 id="5-vector"><a href="#5-vector" class="headerlink" title="5.vector"></a>5.vector</h2><p>插入涉及到内存分配，动态调整，与一开始提到的vector与array区别，就在下面体现出：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">typename</span> vector<span class="token operator">&lt;</span>_Tp<span class="token punctuation">,</span> _Alloc<span class="token operator">></span><span class="token operator">::</span>iteratorvector<span class="token operator">&lt;</span>_Tp<span class="token punctuation">,</span> _Alloc<span class="token operator">></span><span class="token operator">::</span><span class="token function">insert</span><span class="token punctuation">(</span>iterator __position<span class="token punctuation">,</span> <span class="token keyword">const</span> value_type<span class="token operator">&amp;</span> __x<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">const</span> size_type __n <span class="token operator">=</span> __position – <span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//插入到最后一个位置，相当于push_back</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_finish <span class="token operator">!=</span> <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_end_of_storage        <span class="token operator">&amp;&amp;</span> __position <span class="token operator">==</span> <span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        _Alloc_traits<span class="token operator">::</span><span class="token function">construct</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_finish<span class="token punctuation">,</span> __x<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">++</span><span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_finish<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span>    <span class="token punctuation">{</span>        <span class="token function">_M_insert_aux</span><span class="token punctuation">(</span>__position<span class="token punctuation">,</span> __x<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token function">iterator</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_start <span class="token operator">+</span> __n<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>其中<code>_M_insert_aux</code>实现：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _Tp<span class="token punctuation">,</span> <span class="token keyword">typename</span> _Alloc<span class="token operator">></span><span class="token keyword">void</span> vector<span class="token operator">&lt;</span>_Tp<span class="token punctuation">,</span> _Alloc<span class="token operator">></span><span class="token operator">::</span><span class="token function">_M_insert_aux</span><span class="token punctuation">(</span>iterator __position<span class="token punctuation">,</span> <span class="token keyword">const</span> _Tp<span class="token operator">&amp;</span> __x<span class="token punctuation">)</span><span class="token punctuation">{</span>       <span class="token comment" spellcheck="true">//内存空间足够</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_finish <span class="token operator">!=</span> <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_end_of_storage<span class="token punctuation">)</span>    <span class="token punctuation">{</span>         _Alloc_traits<span class="token operator">::</span><span class="token function">construct</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_finish<span class="token punctuation">,</span>                                <span class="token function">_GLIBCXX_MOVE</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_finish                                                <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">++</span><span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_finish<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//__position后的元素依次向后移动一个位置</span>        <span class="token function">_GLIBCXX_MOVE_BACKWARD3</span><span class="token punctuation">(</span>__position<span class="token punctuation">.</span><span class="token function">base</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                                <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_finish <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">,</span>                                <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_finish – <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//目标地址赋值</span>        <span class="token operator">*</span>__position <span class="token operator">=</span> <span class="token function">_Tp</span><span class="token punctuation">(</span>std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>_Args<span class="token operator">></span><span class="token punctuation">(</span>__args<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span>    <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//内存加倍</span>        <span class="token keyword">const</span> size_type __len <span class="token operator">=</span>        <span class="token function">_M_check_len</span><span class="token punctuation">(</span><span class="token function">size_type</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"vector::_M_insert_aux"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">const</span> size_type __elems_before <span class="token operator">=</span> __position <span class="token operator">-</span> <span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        pointer <span class="token function">__new_start</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">_M_allocate</span><span class="token punctuation">(</span>__len<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        pointer <span class="token function">__new_finish</span><span class="token punctuation">(</span>__new_start<span class="token punctuation">)</span><span class="token punctuation">;</span>        __try        <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//给position位置赋值</span>            _Alloc_traits<span class="token operator">::</span><span class="token function">construct</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">,</span>                                    __new_start <span class="token operator">+</span> __elems_before<span class="token punctuation">,</span>                                    std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>_Args<span class="token operator">></span><span class="token punctuation">(</span>__args<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                    __x<span class="token punctuation">)</span><span class="token punctuation">;</span>            __new_finish <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//拷贝position位置前元素</span>            __new_finish <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">__uninitialized_move_if_noexcept_a</span>            <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_start<span class="token punctuation">,</span> __position<span class="token punctuation">.</span><span class="token function">base</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                __new_start<span class="token punctuation">,</span> <span class="token function">_M_get_Tp_allocator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token operator">++</span>__new_finish<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//拷贝position位置后元素</span>            __new_finish            <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">__uninitialized_move_if_noexcept_a</span>            <span class="token punctuation">(</span>__position<span class="token punctuation">.</span><span class="token function">base</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_finish<span class="token punctuation">,</span>                __new_finish<span class="token punctuation">,</span> <span class="token function">_M_get_Tp_allocator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token function">__catch</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>__new_finish<span class="token punctuation">)</span>            _Alloc_traits<span class="token operator">::</span><span class="token function">destroy</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">,</span>                                    __new_start <span class="token operator">+</span> __elems_before<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">else</span>            std<span class="token operator">::</span><span class="token function">_Destroy</span><span class="token punctuation">(</span>__new_start<span class="token punctuation">,</span> __new_finish<span class="token punctuation">,</span> <span class="token function">_M_get_Tp_allocator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">_M_deallocate</span><span class="token punctuation">(</span>__new_start<span class="token punctuation">,</span> __len<span class="token punctuation">)</span><span class="token punctuation">;</span>            __throw_exception_again<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//析构原vector所有元素</span>        std<span class="token operator">::</span><span class="token function">_Destroy</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_start<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_finish<span class="token punctuation">,</span>                    <span class="token function">_M_get_Tp_allocator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//释放原vector内存空间</span>        <span class="token function">_M_deallocate</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_start<span class="token punctuation">,</span>                    <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_end_of_storage，<span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_start<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//vector内存地址指向新空间</span>        <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_start <span class="token operator">=</span> __new_start<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_finish <span class="token operator">=</span> __new_finish<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_end_of_storage <span class="token operator">=</span> __new_start <span class="token operator">+</span> __len<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>其中<code>_M_check_len</code>：</p><pre class=" language-cpp"><code class="language-cpp">size_type<span class="token function">_M_check_len</span><span class="token punctuation">(</span>size_type __n<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> __s<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">max_size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> __n<span class="token punctuation">)</span>        <span class="token function">__throw_length_error</span><span class="token punctuation">(</span><span class="token function">__N</span><span class="token punctuation">(</span>__s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> size_type __len <span class="token operator">=</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> std<span class="token operator">::</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> __n<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//如果n小于当前size，内存加倍，否则内存增长n。</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>__len <span class="token operator">&lt;</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> __len <span class="token operator">></span> <span class="token function">max_size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token function">max_size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> __len<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>内存分配策略并不是简单的加倍，如果n小于当前size，内存加倍，否则内存增长n。</p><p>学习资料：</p><blockquote><p>侯捷《STL源码剖析》</p></blockquote><blockquote><p><a href="https://www.cnblogs.com/coderkian/p/3888429.html" target="_blank" rel="noopener">https://www.cnblogs.com/coderkian/p/3888429.html</a></p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> STL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>主题修改</title>
      <link href="/2019/10/12/zhu-ti-pei-zhi/"/>
      <url>/2019/10/12/zhu-ti-pei-zhi/</url>
      
        <content type="html"><![CDATA[<p>看板娘添加：</p><pre><code>npm install --save hexo-helper-live2d</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 主题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>测试高亮</title>
      <link href="/2019/10/12/ce-shi-gao-liang/"/>
      <url>/2019/10/12/ce-shi-gao-liang/</url>
      
        <content type="html"><![CDATA[<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c<span class="token punctuation">,</span>d<span class="token punctuation">;</span>    <span class="token keyword">int</span> s<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span> flag <span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1000</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">10000</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span>i<span class="token operator">/</span><span class="token number">1000</span><span class="token punctuation">;</span>    s<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>i<span class="token operator">%</span><span class="token number">1000</span><span class="token operator">/</span><span class="token number">100</span><span class="token punctuation">;</span>    s<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">=</span>i<span class="token operator">%</span><span class="token number">100</span><span class="token operator">/</span><span class="token number">10</span><span class="token punctuation">;</span>    s<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token operator">=</span>i<span class="token operator">%</span><span class="token number">10</span><span class="token punctuation">;</span>    flag <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>https://github.com/blinkfox<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>tooltipped<span class="token punctuation">"</span></span> <span class="token attr-name">target</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>_blank<span class="token punctuation">"</span></span> <span class="token attr-name">data-tooltip</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>访问我的GitHub<span class="token punctuation">"</span></span> <span class="token attr-name">data-position</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>top<span class="token punctuation">"</span></span> <span class="token attr-name">data-delay</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>50<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>i</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>fa fa-github<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>i</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span></code></pre><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span>  </span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token comment" spellcheck="true">// main 入口函数  </span><span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Hello,World!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// printf 函数打印  </span>  <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>               <span class="token comment" spellcheck="true">// 函数返回值  </span><span class="token punctuation">}</span>  </code></pre><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span>              </span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span>                </span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Hello,World!--Way 1\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//printf 语句打印  </span>  <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"Hello,World!--Way 2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//puts 语句  </span>  <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"Hello,"</span> <span class="token string">" "</span> <span class="token string">"World!--Way 3"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//字符串拼接  </span>  std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Hello,World!--Way 4"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//C++ 教科书上写法  </span>  <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>                                        <span class="token comment" spellcheck="true">//作为注释  </span><span class="token punctuation">}</span> </code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> C </category>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ STL源码剖析之实现一个简单的iterator_category</title>
      <link href="/2019/10/08/iterator/"/>
      <url>/2019/10/08/iterator/</url>
      
        <content type="html"><![CDATA[<h1 id="C-STL源码剖析之实现一个简单的iterator-category"><a href="#C-STL源码剖析之实现一个简单的iterator-category" class="headerlink" title="C++ STL源码剖析之实现一个简单的iterator_category"></a>C++ STL源码剖析之实现一个简单的iterator_category</h1><h2 id="0-导语"><a href="#0-导语" class="headerlink" title="0.导语"></a>0.导语</h2><p>本节使用上节Traits特性，研究iterator源码，来实现一个简单的iterator_category，同时对iterator的源码结构进行分析。</p><p><strong>知其然，知其所以然，源码面前了无秘密！</strong></p><h2 id="1-利用萃取机实现一个简单的iterator-category识别"><a href="#1-利用萃取机实现一个简单的iterator-category识别" class="headerlink" title="1.利用萃取机实现一个简单的iterator_category识别"></a>1.利用萃取机实现一个简单的iterator_category识别</h2><p>上一节指出了迭代器的作用，依旧如下图所示：</p><p><img src="https://raw.githubusercontent.com/Light-City/cloudimg/master/rela.png" alt=""></p><p>迭代器是指向序列元素的指针的一种抽象。通过使用迭代器，我们可以访问序列中的某个元素、改变序列中的某个元素的值、使迭代器向前或向后行走等等。</p><p>迭代器有常见有五种类型: value_type, difference_type, reference_type, pointer_type都比较容易在 traits 和相应偏特化中提取。</p><p>但是，iterator_category一般也有5个，这个相应型别会引发较大规模的写代码工程。</p><ul><li>单向移动只读迭代器 Input Iterator</li><li>单向移动只写迭代器 Output Iterator</li><li>单向移动读写迭代器 Forward Iterator</li><li>双向移动读写迭代器 Bidirectional Iterator</li></ul><p><img src="https://raw.githubusercontent.com/Light-City/cloudimg/master/iterator.png" alt=""></p><p>例如：我们实现了 advanceII, advanceBI, advanceRAI 分别代表迭代器类型是Input Iterator，Bidirectional Iterator和Random Access Iterator的对应实现。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">Iterator</span><span class="token operator">></span><span class="token keyword">void</span> <span class="token function">advance</span><span class="token punctuation">(</span>Iterator<span class="token operator">&amp;</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">is_random_access_iterator</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token function">advanceRAI</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">is_bidirectional_iterator</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token function">advanceBI</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>        <span class="token function">advanceII</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>但这样在执行时期才决定使用哪一个版本，会<strong>影响程序效率</strong>。最好能够在编译期就选择正确的版本。</p><p>而<strong>重载</strong>这个函数机制可以达成这个目标。</p><p>而对于<code>advanceXX()</code>都有两个函数参数，型别都未定(因为都是模板参数)。为了令其同名，形成重载函数，我们必须加上一个型别已确定的函数参数，使函数重载机制得以有效运作起来。</p><p>设计如下：如果<strong>traits</strong>有能力萃取出迭代器的种类，我们便可利用这个”迭代器类型”相应型别作为advancexx的第三个参数，而这个相应型别必须是一个class type，不能只是数值号码类的东西，因为编译器需依赖它来进行<strong>重载决议</strong>。</p><p>下面来进行实现，首先给出一个总体结构图：</p><p><img src="https://raw.githubusercontent.com/Light-City/cloudimg/master/itera.png" alt=""></p><p>定义出下面tag：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> input_iterator_tag <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> output_iterator_tag <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> forward_iterator_tag <span class="token operator">:</span> <span class="token keyword">public</span> input_iterator_tag <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> bidirectional_iterator_tag <span class="token operator">:</span> <span class="token keyword">public</span> forward_iterator_tag <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> random_access_iterator_tag <span class="token operator">:</span> <span class="token keyword">public</span> bidirectional_iterator_tag <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 继承的好处就是，当函数需要用 input_iterator_tag 的时候</span><span class="token comment" spellcheck="true">// 假设你传进一个forward_iterator_tag，它会沿继承向上找，知道符合条件</span></code></pre><p>声明了一些列 tag 之后，我们就可以重载 advance函数，我们把这些函数用下滑线来定义，表示在内部使用，外部不可见。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 继承的好处就是，当函数需要用 input_iterator_tag 的时候</span><span class="token comment" spellcheck="true">// 假设你传进一个forward_iterator_tag，它会沿继承向上找，知道符合条件</span><span class="token comment" spellcheck="true">// input iterator</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">inputIterator</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">distance</span><span class="token operator">></span><span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">__advance</span><span class="token punctuation">(</span>inputIterator<span class="token operator">&amp;</span>i<span class="token punctuation">,</span> distance n<span class="token punctuation">,</span>                      input_iterator_tag<span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"input tag"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// output iterator</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">outputIterator</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">distance</span><span class="token operator">></span><span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">__advance</span><span class="token punctuation">(</span>outputIterator<span class="token operator">&amp;</span>i<span class="token punctuation">,</span> distance n<span class="token punctuation">,</span>                      output_iterator_tag<span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"output tag"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// forward iterator</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">ForwardIterator</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Distance</span><span class="token operator">></span><span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">__advance</span><span class="token punctuation">(</span>ForwardIterator <span class="token operator">&amp;</span>i<span class="token punctuation">,</span> Distance n<span class="token punctuation">,</span>                      forward_iterator_tag<span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"forward tag"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// bidrectional iterator</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">BidiectionalIterator</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Distance</span><span class="token operator">></span><span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">__advance</span><span class="token punctuation">(</span>BidiectionalIterator <span class="token operator">&amp;</span>i<span class="token punctuation">,</span> Distance n<span class="token punctuation">,</span>                      bidiectional_iterator_tag<span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"bidrectional tag"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// RandomAccess iterator</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">RandomAccessIterator</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Distance</span><span class="token operator">></span><span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">__advance</span><span class="token punctuation">(</span>RandomAccessIterator <span class="token operator">&amp;</span>i<span class="token punctuation">,</span> Distance n<span class="token punctuation">,</span>                      random_access_iterator_tag<span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"randomaccess tag"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>定义萃取机：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// traits 型别</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">I</span><span class="token operator">></span><span class="token keyword">struct</span> Iterator_traits <span class="token punctuation">{</span>    <span class="token keyword">typedef</span> <span class="token keyword">typename</span> I<span class="token operator">::</span>iterator_category iterator_category<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 针对原生指针设计的"偏特化版"</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">I</span><span class="token operator">></span><span class="token keyword">struct</span> Iterator_traits<span class="token operator">&lt;</span>I <span class="token operator">*</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">typedef</span> random_access_iterator_tag iterator_category<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">I</span><span class="token operator">></span><span class="token keyword">struct</span> Iterator_traits<span class="token operator">&lt;</span><span class="token keyword">const</span> I <span class="token operator">*</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">typedef</span> random_access_iterator_tag iterator_category<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>对外暴露接口：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 对外接口</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">InputIterator</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Distance</span><span class="token operator">></span><span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">advance</span><span class="token punctuation">(</span>InputIterator <span class="token operator">&amp;</span>i<span class="token punctuation">,</span> Distance n<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 通过Ierator_traits询问它的iterator_category是谁</span>    <span class="token keyword">typedef</span> <span class="token keyword">typename</span> Iterator_traits<span class="token operator">&lt;</span>InputIterator<span class="token operator">></span><span class="token operator">::</span>iterator_category category<span class="token punctuation">;</span>    <span class="token function">__advance</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> n<span class="token punctuation">,</span> <span class="token function">category</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 各型别的重载</span><span class="token punctuation">}</span></code></pre><p>定义class type：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// class type</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">Category</span><span class="token operator">></span><span class="token keyword">struct</span> iterator <span class="token punctuation">{</span>    <span class="token keyword">typedef</span> Category iterator_category<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>开始测试，我们使用上述定义的class type与原生指针来测试，分别进入萃取机的普通萃取机与偏特化萃取机，看看是否得到相应的Tag。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    iterator<span class="token operator">&lt;</span>input_iterator_tag<span class="token operator">></span> input<span class="token punctuation">;</span>    iterator<span class="token operator">&lt;</span>output_iterator_tag<span class="token operator">></span> output<span class="token punctuation">;</span>    iterator<span class="token operator">&lt;</span>forward_iterator_tag<span class="token operator">></span> forward<span class="token punctuation">;</span>    iterator<span class="token operator">&lt;</span>bidiectional_iterator_tag<span class="token operator">></span> bidect<span class="token punctuation">;</span>    iterator<span class="token operator">&lt;</span>random_access_iterator_tag<span class="token operator">></span> random<span class="token punctuation">;</span>    <span class="token function">advance</span><span class="token punctuation">(</span>input<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">advance</span><span class="token punctuation">(</span>output<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">advance</span><span class="token punctuation">(</span>forward<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">advance</span><span class="token punctuation">(</span>bidect<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">advance</span><span class="token punctuation">(</span>random<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token function">advance</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>输出结果：</p><pre class=" language-cpp"><code class="language-cpp">input tagoutput tagforward tagbidrectional tagrandomaccess tagrandomaccess tag</code></pre><p>一切如我们预期一样，通过萃取机，我们获得了每个迭代器的tag，以及原生指针的tag。</p><p>我们再想得复杂一些，如果我们想知道advance的返回类型，那如何做呢？</p><p>首先修改<code>advance</code>返回：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 对外接口</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">InputIterator</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Distance</span><span class="token operator">></span><span class="token keyword">inline</span> <span class="token keyword">typename</span> Iterator_traits<span class="token operator">&lt;</span>InputIterator<span class="token operator">></span><span class="token operator">::</span>iterator_category<span class="token function">advance</span><span class="token punctuation">(</span>InputIterator <span class="token operator">&amp;</span>i<span class="token punctuation">,</span> Distance n<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 通过Ierator_traits询问它的iterator_category是谁</span>    <span class="token keyword">typedef</span> <span class="token keyword">typename</span> Iterator_traits<span class="token operator">&lt;</span>InputIterator<span class="token operator">></span><span class="token operator">::</span>iterator_category category<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">__advance</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> n<span class="token punctuation">,</span> <span class="token function">category</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 各型别的重载</span><span class="token punctuation">}</span></code></pre><p>紧接着修改<code>__advance</code>返回：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// input iterator</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">inputIterator</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">distance</span><span class="token operator">></span><span class="token keyword">inline</span> <span class="token keyword">typename</span> Iterator_traits<span class="token operator">&lt;</span>inputIterator<span class="token operator">></span><span class="token operator">::</span>iterator_category<span class="token function">__advance</span><span class="token punctuation">(</span>inputIterator <span class="token operator">&amp;</span>i<span class="token punctuation">,</span> distance n<span class="token punctuation">,</span>          input_iterator_tag<span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"input tag"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">input_iterator_tag</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// output iterator</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">outputIterator</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">distance</span><span class="token operator">></span><span class="token keyword">inline</span> <span class="token keyword">typename</span> Iterator_traits<span class="token operator">&lt;</span>outputIterator<span class="token operator">></span><span class="token operator">::</span>iterator_category<span class="token function">__advance</span><span class="token punctuation">(</span>outputIterator <span class="token operator">&amp;</span>i<span class="token punctuation">,</span> distance n<span class="token punctuation">,</span>          output_iterator_tag<span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"output tag"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">output_iterator_tag</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// forward iterator</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">ForwardIterator</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Distance</span><span class="token operator">></span><span class="token keyword">inline</span> <span class="token keyword">typename</span> Iterator_traits<span class="token operator">&lt;</span>ForwardIterator<span class="token operator">></span><span class="token operator">::</span>iterator_category<span class="token function">__advance</span><span class="token punctuation">(</span>ForwardIterator <span class="token operator">&amp;</span>i<span class="token punctuation">,</span> Distance n<span class="token punctuation">,</span>          forward_iterator_tag<span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"forward tag"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">forward_iterator_tag</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// bidrectional iterator</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">BidiectionalIterator</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Distance</span><span class="token operator">></span><span class="token keyword">inline</span> <span class="token keyword">typename</span> Iterator_traits<span class="token operator">&lt;</span>BidiectionalIterator<span class="token operator">></span><span class="token operator">::</span>iterator_category<span class="token function">__advance</span><span class="token punctuation">(</span>BidiectionalIterator <span class="token operator">&amp;</span>i<span class="token punctuation">,</span> Distance n<span class="token punctuation">,</span>          bidiectional_iterator_tag<span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"bidrectional tag"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">bidiectional_iterator_tag</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// RandomAccess iterator</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">RandomAccessIterator</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Distance</span><span class="token operator">></span><span class="token keyword">inline</span> <span class="token keyword">typename</span> Iterator_traits<span class="token operator">&lt;</span>RandomAccessIterator<span class="token operator">></span><span class="token operator">::</span>iterator_category<span class="token function">__advance</span><span class="token punctuation">(</span>RandomAccessIterator <span class="token operator">&amp;</span>i<span class="token punctuation">,</span> Distance n<span class="token punctuation">,</span>          random_access_iterator_tag<span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"randomaccess tag"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">random_access_iterator_tag</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>只需要把<code>void</code>修改为相应的萃取机即可。</p><p>最后测试修改，添加上返回：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    iterator<span class="token operator">&lt;</span>input_iterator_tag<span class="token operator">></span> input<span class="token punctuation">;</span>    iterator<span class="token operator">&lt;</span>output_iterator_tag<span class="token operator">></span> output<span class="token punctuation">;</span>    iterator<span class="token operator">&lt;</span>forward_iterator_tag<span class="token operator">></span> forward<span class="token punctuation">;</span>    iterator<span class="token operator">&lt;</span>bidiectional_iterator_tag<span class="token operator">></span> bidect<span class="token punctuation">;</span>    iterator<span class="token operator">&lt;</span>random_access_iterator_tag<span class="token operator">></span> random<span class="token punctuation">;</span>    input_iterator_tag inputIteratorTag <span class="token operator">=</span> <span class="token function">advance</span><span class="token punctuation">(</span>input<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    output_iterator_tag outputIteratorTag <span class="token operator">=</span> <span class="token function">advance</span><span class="token punctuation">(</span>output<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    forward_iterator_tag forwardIteratorTag <span class="token operator">=</span> <span class="token function">advance</span><span class="token punctuation">(</span>forward<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    bidiectional_iterator_tag bidiectionalIteratorTag <span class="token operator">=</span> <span class="token function">advance</span><span class="token punctuation">(</span>bidect<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    random_access_iterator_tag randomAccessIteratorTag <span class="token operator">=</span> <span class="token function">advance</span><span class="token punctuation">(</span>random<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    random_access_iterator_tag v <span class="token operator">=</span> <span class="token function">advance</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>至此，一个简单的迭代器类型在编译器判别实现完毕。</p><h2 id="2-STL源码剖析Iterator"><a href="#2-STL源码剖析Iterator" class="headerlink" title="2.STL源码剖析Iterator"></a>2.STL源码剖析Iterator</h2><p>在<code>bits/stl_iterator_base_types.h</code>中也是如上述所示(实际上，上面就是STL源码的简单版，很接近)，来我们一起来看。</p><p>（1）<code>tag</code></p><pre class=" language-cpp"><code class="language-cpp"> <span class="token comment" spellcheck="true">///  Marking input iterators.</span>  <span class="token keyword">struct</span> input_iterator_tag <span class="token punctuation">{</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">///  Marking output iterators.</span>  <span class="token keyword">struct</span> output_iterator_tag <span class="token punctuation">{</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/// Forward iterators support a superset of input iterator operations.</span>  <span class="token keyword">struct</span> forward_iterator_tag <span class="token operator">:</span> <span class="token keyword">public</span> input_iterator_tag <span class="token punctuation">{</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/// Bidirectional iterators support a superset of forward iterator</span>  <span class="token comment" spellcheck="true">/// operations.</span>  <span class="token keyword">struct</span> bidirectional_iterator_tag <span class="token operator">:</span> <span class="token keyword">public</span> forward_iterator_tag <span class="token punctuation">{</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/// Random-access iterators support a superset of bidirectional</span>  <span class="token comment" spellcheck="true">/// iterator operations.</span>  <span class="token keyword">struct</span> random_access_iterator_tag <span class="token operator">:</span> <span class="token keyword">public</span> bidirectional_iterator_tag <span class="token punctuation">{</span> <span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>与我上面用的一样。</p><p>（2）<code>iterator_traits</code>萃取机，里面包含五种，而上面只是实现其中的一种：<code>iterator_category</code>。所以在STL中容器与算法之间的桥梁iterator必须包含下面五种 typedef。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _Iterator<span class="token operator">></span><span class="token keyword">struct</span> iterator_traits<span class="token punctuation">{</span>  <span class="token keyword">typedef</span> <span class="token keyword">typename</span> _Iterator<span class="token operator">::</span>iterator_category iterator_category<span class="token punctuation">;</span>  <span class="token keyword">typedef</span> <span class="token keyword">typename</span> _Iterator<span class="token operator">::</span>value_type        value_type<span class="token punctuation">;</span>  <span class="token keyword">typedef</span> <span class="token keyword">typename</span> _Iterator<span class="token operator">::</span>difference_type   difference_type<span class="token punctuation">;</span>  <span class="token keyword">typedef</span> <span class="token keyword">typename</span> _Iterator<span class="token operator">::</span>pointer           pointer<span class="token punctuation">;</span>  <span class="token keyword">typedef</span> <span class="token keyword">typename</span> _Iterator<span class="token operator">::</span>reference         reference<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>（3）<code>iterator</code></p><p>上面提到的class type为下面的简单版，对比一下，没有啥区别，就是模板参数多了一些，typedef多了。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _Category<span class="token punctuation">,</span> <span class="token keyword">typename</span> _Tp<span class="token punctuation">,</span> <span class="token keyword">typename</span> _Distance <span class="token operator">=</span> ptrdiff_t<span class="token punctuation">,</span>       <span class="token keyword">typename</span> _Pointer <span class="token operator">=</span> _Tp<span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> _Reference <span class="token operator">=</span> _Tp<span class="token operator">&amp;</span><span class="token operator">></span><span class="token keyword">struct</span> iterator<span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">/// One of the @link iterator_tags tag types@endlink.</span>  <span class="token keyword">typedef</span> _Category  iterator_category<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/// The type "pointed to" by the iterator.</span>  <span class="token keyword">typedef</span> _Tp        value_type<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/// Distance between iterators is represented as this type.</span>  <span class="token keyword">typedef</span> _Distance  difference_type<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/// This type represents a pointer-to-value_type.</span>  <span class="token keyword">typedef</span> _Pointer   pointer<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/// This type represents a reference-to-value_type.</span>  <span class="token keyword">typedef</span> _Reference reference<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>至此，iterator与traits特性分析完毕。欢迎与我共同探讨STL源码奥秘，如侯捷老师所说：<strong>源码面前了无秘密。</strong></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> STL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ STL 源码剖析之 Traits 编程技法</title>
      <link href="/2019/10/07/traits/"/>
      <url>/2019/10/07/traits/</url>
      
        <content type="html"><![CDATA[<h1 id="C-STL-源码剖析之-Traits-编程技法"><a href="#C-STL-源码剖析之-Traits-编程技法" class="headerlink" title="C++ STL 源码剖析之 Traits 编程技法"></a>C++ STL 源码剖析之 Traits 编程技法</h1><h2 id="0-导语"><a href="#0-导语" class="headerlink" title="0.导语"></a>0.导语</h2><p>在 STL 编程中，容器和算法是独立设计的，即数据结构和算法是独立设计的，连接容器和算法的桥梁就是迭代器了，迭代器使其独立设计成为可能。如下图所示：</p><p><img src="https://raw.githubusercontent.com/Light-City/cloudimg/master/rela.png" alt=""></p><p>上图给出了 STL 的目标就是要把数据和算法分开，分别对其进行设计，之后通过一种名为 iterator 的东西，把这二者再粘接到一起。</p><p>设计模式中，关于 iterator 的描述为：<strong>一种能够顺序访问容器中每个元素的方法，使用该方法不能暴露容器内部的表达方式。而类型萃取技术就是为了要解决和 iterator 有关的问题的。</strong></p><p>它将范型算法(find, count, find_if)用于某个容器中,最重要的是要给算法提供一个访问容器元素的工具，iterator 就扮演着这个重要的角色。</p><p>而在算法中我们可能会定义简单的中间变量或者设定算法的返回变量类型，这时候需要知道迭代器所指元素的类型是什么，但是由于没有 typeof 这类判断类型的函数,我们无法直接获取，那该如何是好？本文就来具体阐述。</p><p>对于迭代器来说就是一种智能指针，因此，它也就拥有了一般指针的所有特点——能够对其进行*和-&gt;操作。但是在遍历容器的时候，不可避免的要对遍历的容器内部有所了解，所以，干脆把迭代器的开发工作交给容器的设计者好了，如此以来，所有实现细节反而得以封装起来不被使用者看到，这正是为什么每一种 STL 容器都提供有专属迭代器的缘故。</p><p>而 Traits 在<code>bits/stl_iterator_base_types.h</code>中：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">_Tp</span><span class="token operator">></span><span class="token keyword">struct</span> iterator_traits<span class="token operator">&lt;</span>_Tp<span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">{</span>    <span class="token keyword">typedef</span> ptrdiff_t difference_type<span class="token punctuation">;</span>    <span class="token keyword">typedef</span> <span class="token keyword">typename</span> _Tp<span class="token operator">::</span>value_type value_type<span class="token punctuation">;</span>    <span class="token keyword">typedef</span> <span class="token keyword">typename</span> _Tp<span class="token operator">::</span>pointer pointer<span class="token punctuation">;</span>    <span class="token keyword">typedef</span> <span class="token keyword">typename</span> _Tp<span class="token operator">::</span>reference reference<span class="token punctuation">;</span>    <span class="token keyword">typedef</span> <span class="token keyword">typename</span> _Tp<span class="token operator">::</span>iterator_category iterator_category<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>看的一脸懵逼吧，没事，看完本节，入门 STL，哈哈~</p><h2 id="1-template-参数推导"><a href="#1-template-参数推导" class="headerlink" title="1.template 参数推导"></a>1.template 参数推导</h2><p>首先，在算法中运用迭代器时，很可能会用到<strong>其相应型别（associated type）</strong>（迭代器所指之物的型别）。假设算法中有必要声明一个变量，以”迭代器所指对象的型别”为型别，该<strong>怎么办呢？</strong></p><p><strong>解决方法是：利用 function template 的参数推导机制。</strong></p><p>例如：</p><p>如果 T 是某个指向特定对象的指针，那么在 func 中需要指针所指向对象的型别的时候，怎么办呢？这个还比较容易，模板的参数推导机制可以完成任务，</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">I</span><span class="token operator">></span><span class="token keyword">inline</span><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span>I iter<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">func_impl</span><span class="token punctuation">(</span>iter<span class="token punctuation">,</span> <span class="token operator">*</span>iter<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 传入iter和iter所指的值，class自动推导</span><span class="token punctuation">}</span></code></pre><p>通过模板的推导机制，我们轻而易举的或得了指针所指向的对象的类型。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">I</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">void</span> <span class="token function">func_impl</span><span class="token punctuation">(</span>I iter<span class="token punctuation">,</span> T t<span class="token punctuation">)</span> <span class="token punctuation">{</span>        T tmp<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 这里就是迭代器所指物的类别</span>        <span class="token comment" spellcheck="true">// ... 功能实现</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    <span class="token function">func</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>但是，<strong>函数的”template 参数推导机制”推导的只是参数，无法推导函数的返回值类型。万一需要推导函数的传回值，就无能为力了</strong>。因此，我们引出下面的方法。</p><h2 id="2-声明内嵌型别"><a href="#2-声明内嵌型别" class="headerlink" title="2.声明内嵌型别"></a>2.声明内嵌型别</h2><p><strong>迭代器所指对象的型别，称之为迭代器的 value type。</strong></p><p>尽管在 func_impl 中我们可以把 T 作为函数的返回值，但是问题是用户需要调用的是 func。</p><pre><code>template &lt;class I, class T&gt;T func_impl(I iter, T t) {        T tmp; // 这里就是迭代器所指物的类别        // ... 功能实现}template &lt;class T&gt;(*T) func(T t) { // !!!Wrong code    return func_impl(t, *t); // forward the task to func_impl}int main() {    int i  =10;    cout&lt;&lt;func(&amp;i)&lt;&lt;endl; // !!! Can’t pass compile}</code></pre><p>如果去编译上述代码，编译失败！</p><p>这个问题解决起来也不难，声明内嵌型别似乎是个好主意，这样我们就可以直接获取。只要做一个 iterator，然后在定义的时候为其指向的对象类型制定一个别名，就好了，像下面这样：</p><pre><code>template &lt;class T&gt;struct MyIter {    typedef T value_type; // 内嵌型别声明    T* ptr;    MyIter(T* p = 0) : ptr(p) {}    T&amp; operator*() const { return *ptr; }};template &lt;class I&gt;typename I::value_typefunc(I ite) {    std::cout &lt;&lt; "class version" &lt;&lt; std::endl;    return *ite;}int main() {    // ...    MyIter&lt;int&gt; ite(new int(8));    cout &lt;&lt; func(ite);    // 输出8}</code></pre><p>很漂亮的解决方案，看上去一切都很完美。但是，实际上还是有问题，因为 func 如果是一个泛型算法，那么它也绝对要接受一个原生指针作为迭代器，但是显然，你无法让下面的代码编译通过：</p><pre><code>int *p = new int(5);cout&lt;&lt;func(p)&lt;&lt;endl; // error</code></pre><p>我们的 func 无法支持原生指针，这显然是不能接受的。此时，template partial specialization 就派上了用场。</p><h2 id="3-救世主-Traits"><a href="#3-救世主-Traits" class="headerlink" title="3.救世主 Traits"></a>3.救世主 Traits</h2><p>前面也提到了，如果直接使用<code>typename I::value_type</code>，算法就无法接收原生指针，因为原生指针根本就没有 value_type 这个内嵌类型。</p><p>因此，我们还需要加入一个中间层对其进行判断，看它是不是原生指针，注意，这就是 traits 技法的妙处所在。</p><p>如果我们只使用上面的做法，也就是内嵌 value_type，那么对于没有 value_type 的指针，我们只能对其进行偏特化，这种偏特化是针对可调用函数 func 的偏特化，假如 func 有 100 万行行代码，那么就会造成极大的视觉污染。</p><p><strong>（1）函数偏特化</strong></p><p>函数偏特化：</p><pre><code>template &lt;class T&gt;struct MyIter {    typedef T value_type; // 内嵌型别声明    T* ptr;    MyIter(T* p = 0) : ptr(p) {}    T&amp; operator*() const { return *ptr; }};template &lt;class I&gt;typename I::value_typefunc(I ite) {    std::cout &lt;&lt; "class version" &lt;&lt; std::endl;    return *ite;}template &lt;class I&gt;Ifunc(I* ite) {    std::cout &lt;&lt; "pointer version" &lt;&lt; std::endl;    return *ite;}template &lt;class I&gt;I func(const I* ite) {    std::cout &lt;&lt; "const pointer version" &lt;&lt; std::endl;    return *ite;}int main() {    // ...    MyIter&lt;int&gt; ite(new int(8));    cout &lt;&lt; func(ite)&lt;&lt;endl;    int *p = new int(52);    cout&lt;&lt;func(p)&lt;&lt;endl;    const int k = 3;    cout&lt;&lt;func(&amp;k)&lt;&lt;endl;}</code></pre><p>输出：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">version</span><span class="token number">8</span>pointer version<span class="token number">52</span><span class="token keyword">const</span> pointer version<span class="token number">3</span></code></pre><p><strong>（2）加入中间层</strong></p><p>在 STL 中 Traits 是什么呢？看下图：</p><p><img src="https://raw.githubusercontent.com/Light-City/cloudimg/master/trai.png" alt=""></p><p>利用一个中间层<code>iterator_traits</code>固定了<code>func</code>的形式，使得重复的代码大量减少，唯一要做的就是稍稍特化一下 iterator_tartis 使其支持 pointer 和 const pointer:)</p><pre><code>#include &lt;iostream&gt;template &lt;class T&gt;struct MyIter {    typedef T value_type; // 内嵌型别声明    T* ptr;    MyIter(T* p = 0) : ptr(p) {}    T&amp; operator*() const { return *ptr; }};// class typetemplate &lt;class T&gt;struct iterator_traits {    typedef typename T::value_type value_type;};// 偏特化1template &lt;class T&gt;struct iterator_traits&lt;T*&gt; {    typedef T value_type;};// 偏特化2template &lt;class T&gt;struct iterator_traits&lt;const T*&gt; {    typedef T value_type;};template &lt;class I&gt;typename iterator_traits&lt;I&gt;::value_type// 首先询问iterator_traits&lt;I&gt;::value_type,如果传递的I为指针,则进入特化版本,iterator_traits直接回答;如果传递进来的I为class type,就去询问T::value_type.func(I ite) {    std::cout &lt;&lt; "normal version" &lt;&lt; std::endl;    return *ite;}int main() {    // ...    MyIter&lt;int&gt; ite(new int(8));    std::cout &lt;&lt; func(ite)&lt;&lt;std::endl;    int *p = new int(52);    std::cout&lt;&lt;func(p)&lt;&lt;std::endl;    const int k = 3;    std::cout&lt;&lt;func(&amp;k)&lt;&lt;std::endl;}</code></pre><p>上述的过程是首先询问<code>iterator_traits&lt;I&gt;::value_type</code>，如果传递的 I 为指针,则进入特化版本,<code>iterator_traits</code>直接回答<code>T</code>;如果传递进来的<code>I</code>为<code>class type</code>,就去询问<code>T::value_type</code>.</p><p>上述的通俗解释为算法(func)问 iterator_traits(我)，但是 iterator_traits(我)发现手上是指针的时候，就由我来替它回答。如果是 class type，iterator_traits(我)就继续问(他—T::value_type)。</p><p><strong>总结：通过定义内嵌类型，我们获得了知晓 iterator 所指元素类型的方法，通过 traits 技法，我们将函数模板对于原生指针和自定义 iterator 的定义都统一起来，我们使用 traits 技法主要是为了解决原生指针和自定义 iterator 之间的不同所造成的代码冗余，这就是 traits 技法的妙处所在。</strong></p><p>学习书籍：</p><blockquote><p>侯捷《 STL 源码剖析》</p></blockquote><p>学习文章：</p><blockquote><p><a href="https://juejin.im/post/5b1a43fb51882513bf1795c6" target="_blank" rel="noopener">https://juejin.im/post/5b1a43fb51882513bf1795c6</a></p></blockquote><blockquote><p><a href="https://www.cnblogs.com/mangoyuan/p/6446046.html" target="_blank" rel="noopener">https://www.cnblogs.com/mangoyuan/p/6446046.html</a></p></blockquote><blockquote><p><a href="http://www.cppblog.com/nacci/archive/2005/11/03/911.aspx" target="_blank" rel="noopener">http://www.cppblog.com/nacci/archive/2005/11/03/911.aspx</a></p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> STL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ STL源码剖析之双向环形链表list</title>
      <link href="/2019/10/06/list/"/>
      <url>/2019/10/06/list/</url>
      
        <content type="html"><![CDATA[<h1 id="C-STL源码剖析之双向环形链表list"><a href="#C-STL源码剖析之双向环形链表list" class="headerlink" title="C++ STL源码剖析之双向环形链表list"></a>C++ STL源码剖析之双向环形链表list</h1><h2 id="0-导语"><a href="#0-导语" class="headerlink" title="0. 导语"></a>0. 导语</h2><p>源码对应的版本为<strong>gcc-4.9.1</strong></p><h3 id="1-list"><a href="#1-list" class="headerlink" title="1.list"></a>1.list</h3><p>list为双向环形链表，其结构为：</p><p><img src="https://raw.githubusercontent.com/Light-City/cloudimg/master/list_1.png" alt=""></p><p>自己绘制的图如下：</p><p><img src="https://raw.githubusercontent.com/Light-City/cloudimg/master/list_a.png" alt="list_all"></p><p>双向环状链表从节点值为3开始插入，红色框表示最后一个节点(end()指向的节点)。黄色线条表示指向前驱节点，黑色线条表示指向后继节点。</p><h3 id="1-1-list源码"><a href="#1-1-list源码" class="headerlink" title="1.1 list源码"></a>1.1 list源码</h3><h4 id="1-1-1-类结构"><a href="#1-1-1-类结构" class="headerlink" title="1.1.1 类结构"></a>1.1.1 类结构</h4><pre class=" language-cpp"><code class="language-cpp"> <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _Tp<span class="token punctuation">,</span> <span class="token keyword">typename</span> _Alloc <span class="token operator">=</span> std<span class="token operator">::</span>allocator<span class="token operator">&lt;</span>_Tp<span class="token operator">></span> <span class="token operator">></span> <span class="token keyword">class</span> <span class="token class-name">list</span> <span class="token operator">:</span> <span class="token keyword">protected</span> _List_base<span class="token operator">&lt;</span>_Tp<span class="token punctuation">,</span> _Alloc<span class="token operator">></span>  <span class="token punctuation">{</span> <span class="token punctuation">}</span></code></pre><p><code>list</code>继承<code>_List_base</code>。</p><h4 id="1-1-2-双向环形链表实现"><a href="#1-1-2-双向环形链表实现" class="headerlink" title="1.1.2 双向环形链表实现"></a>1.1.2 双向环形链表实现</h4><p>【<strong>构造函数</strong>】</p><p><strong>（1）不带任何元素的list</strong></p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">explicit</span><span class="token function">list</span><span class="token punctuation">(</span><span class="token keyword">const</span> allocator_type <span class="token operator">&amp;</span>__a<span class="token punctuation">)</span> _GLIBCXX_NOEXCEPT<span class="token operator">:</span> <span class="token function">_Base</span><span class="token punctuation">(</span><span class="token function">_Node_alloc_type</span><span class="token punctuation">(</span>__a<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><p><strong>（2）带n个元素且赋予初值的list</strong></p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">explicit</span> <span class="token function">list</span><span class="token punctuation">(</span>size_type __n<span class="token punctuation">,</span> <span class="token keyword">const</span> value_type <span class="token operator">&amp;</span>__value <span class="token operator">=</span> <span class="token function">value_type</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token keyword">const</span> allocator_type <span class="token operator">&amp;</span>__a <span class="token operator">=</span> <span class="token function">allocator_type</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">_Base</span><span class="token punctuation">(</span><span class="token function">_Node_alloc_type</span><span class="token punctuation">(</span>__a<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">_M_fill_initialize</span><span class="token punctuation">(</span>__n<span class="token punctuation">,</span> __value<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre><p><strong>（3）从一个范围中进行初始化list</strong></p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _InputIterator<span class="token operator">></span><span class="token function">list</span><span class="token punctuation">(</span>_InputIterator __first<span class="token punctuation">,</span> _InputIterator __last<span class="token punctuation">,</span>     <span class="token keyword">const</span> allocator_type <span class="token operator">&amp;</span>__a <span class="token operator">=</span> <span class="token function">allocator_type</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token operator">:</span> <span class="token function">_Base</span><span class="token punctuation">(</span><span class="token function">_Node_alloc_type</span><span class="token punctuation">(</span>__a<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// Check whether it's an integral type.  If so, it's not an iterator.</span>    <span class="token keyword">typedef</span> <span class="token keyword">typename</span> std<span class="token operator">::</span>__is_integer<span class="token operator">&lt;</span>_InputIterator<span class="token operator">></span><span class="token operator">::</span>__type _Integral<span class="token punctuation">;</span>    <span class="token function">_M_initialize_dispatch</span><span class="token punctuation">(</span>__first<span class="token punctuation">,</span> __last<span class="token punctuation">,</span> <span class="token function">_Integral</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>【<strong>创建节点</strong>】</p><p>做的事情：创建一个新的节点并动态分配内存，返回节点。</p><pre class=" language-cpp"><code class="language-cpp">_Node <span class="token operator">*</span><span class="token function">_M_create_node</span><span class="token punctuation">(</span><span class="token keyword">const</span> value_type <span class="token operator">&amp;</span>__x<span class="token punctuation">)</span> <span class="token punctuation">{</span>    _Node <span class="token operator">*</span>__p <span class="token operator">=</span> <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">_M_get_node</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    __try    <span class="token punctuation">{</span>        <span class="token function">_M_get_Tp_allocator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">construct</span>                <span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">__addressof</span><span class="token punctuation">(</span>__p<span class="token operator">-</span><span class="token operator">></span>_M_data<span class="token punctuation">)</span><span class="token punctuation">,</span> __x<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">__catch</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">_M_put_node</span><span class="token punctuation">(</span>__p<span class="token punctuation">)</span><span class="token punctuation">;</span>        __throw_exception_again<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> __p<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>注意到里面有两个重要的函数<code>_M_get_node</code>与<code>_M_put_node</code>，我们来查看后发现这些方法来自基类，源码为：</p><pre class=" language-cpp"><code class="language-cpp">_List_node<span class="token operator">&lt;</span>_Tp<span class="token operator">></span> <span class="token operator">*</span> <span class="token function">_M_get_node</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> _M_impl<span class="token punctuation">.</span>_Node_alloc_type<span class="token operator">::</span><span class="token function">allocate</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">_M_put_node</span><span class="token punctuation">(</span>_List_node<span class="token operator">&lt;</span>_Tp<span class="token operator">></span> <span class="token operator">*</span>__p<span class="token punctuation">)</span>   _GLIBCXX_NOEXCEPT<span class="token punctuation">{</span> _M_impl<span class="token punctuation">.</span>_Node_alloc_type<span class="token operator">::</span><span class="token function">deallocate</span><span class="token punctuation">(</span>__p<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre><p>对应的就是创建节点动态分配内存，若创建过程中抛出异常，则释放内存。</p><p>【<strong>插入节点</strong>】</p><p>插入节点包括：</p><ul><li>尾部插入n个指定节点值的节点，对应的函数<code>_M_fill_initialize</code></li></ul><p>在list的构造函数中使用：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">explicit</span> <span class="token function">list</span><span class="token punctuation">(</span>size_type __n<span class="token punctuation">,</span> <span class="token keyword">const</span> value_type <span class="token operator">&amp;</span>__value <span class="token operator">=</span> <span class="token function">value_type</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token keyword">const</span> allocator_type <span class="token operator">&amp;</span>__a <span class="token operator">=</span> <span class="token function">allocator_type</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">_Base</span><span class="token punctuation">(</span><span class="token function">_Node_alloc_type</span><span class="token punctuation">(</span>__a<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">_M_fill_initialize</span><span class="token punctuation">(</span>__n<span class="token punctuation">,</span> __value<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre><ul><li>指定位置插入指定节点值的节点，对应的函数<code>_M_insert</code></li></ul><p>其中大家经常使用的<code>push_back</code>与<code>push_front</code>底层就是调用<code>_M_insert</code>函数。</p><p>两者函数区别是：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">_M_insert</span><span class="token punctuation">(</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> __x<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// push_back   尾部插入  </span><span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">_M_insert</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> __x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// push_front 头部插入</span></code></pre><ul><li><strong>双向环形链表插入函数</strong><code>_M_hook</code>   <strong>(最重要！！！)</strong></li></ul><p>像前面提到的<code>push_back</code>、<code>push_front</code>、<code>_M_insert</code>，还有<code>insert</code>都是使用最基础的双向链表插入函数<code>_M_hook</code>实现的。</p><p><strong>下面来深入研究一下：</strong></p><p>其中<code>_M_fill_initialize</code>源码如下：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">_M_fill_initialize</span><span class="token punctuation">(</span>size_type __n<span class="token punctuation">,</span> <span class="token keyword">const</span> value_type <span class="token operator">&amp;</span>__x<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> __n<span class="token punctuation">;</span> <span class="token operator">--</span>__n<span class="token punctuation">)</span>        <span class="token function">push_back</span><span class="token punctuation">(</span>__x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>其中<code>push_back</code>源码如下：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">push_back</span><span class="token punctuation">(</span><span class="token keyword">const</span> value_type <span class="token operator">&amp;</span>__x<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">_M_insert</span><span class="token punctuation">(</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> __x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre><p>其中<code>_M_insert</code>，在指定的位置插入初始值为x的节点。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">_M_insert</span><span class="token punctuation">(</span>iterator __position<span class="token punctuation">,</span> <span class="token keyword">const</span> value_type <span class="token operator">&amp;</span>__x<span class="token punctuation">)</span> <span class="token punctuation">{</span>    _Node <span class="token operator">*</span>__tmp <span class="token operator">=</span> <span class="token function">_M_create_node</span><span class="token punctuation">(</span>__x<span class="token punctuation">)</span><span class="token punctuation">;</span>    __tmp<span class="token operator">-</span><span class="token operator">></span><span class="token function">_M_hook</span><span class="token punctuation">(</span>__position<span class="token punctuation">.</span>_M_node<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>其中<code>_M_hook</code>实现在<code>gcc-4.9.1/libstdc++-v3/src/c++98/list.cc</code>中,当然<code>_List_node_base</code>的其他函数，例如：<code>_M_unhook</code>也在这个文件中。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 在指定的位置前插入this指向的节点</span>void_List_node_base<span class="token operator">::</span><span class="token function">_M_hook</span><span class="token punctuation">(</span>_List_node_base<span class="token operator">*</span> <span class="token keyword">const</span> __position<span class="token punctuation">)</span> _GLIBCXX_USE_NOEXCEPT<span class="token punctuation">{</span>  <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_next <span class="token operator">=</span> __position<span class="token punctuation">;</span>          <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_prev <span class="token operator">=</span> __position<span class="token operator">-</span><span class="token operator">></span>_M_prev<span class="token punctuation">;</span>  __position<span class="token operator">-</span><span class="token operator">></span>_M_prev<span class="token operator">-</span><span class="token operator">></span>_M_next <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>  __position<span class="token operator">-</span><span class="token operator">></span>_M_prev <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>所以上述细分为两个函数：我们把上述代码进行总结：</p><p>（1）在指定的位置插入初始值为x的节点</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">_M_insert</span><span class="token punctuation">(</span>iterator __position<span class="token punctuation">,</span> <span class="token keyword">const</span> value_type <span class="token operator">&amp;</span>__x<span class="token punctuation">)</span> <span class="token punctuation">{</span>    _Node <span class="token operator">*</span>__tmp <span class="token operator">=</span> <span class="token function">_M_create_node</span><span class="token punctuation">(</span>__x<span class="token punctuation">)</span><span class="token punctuation">;</span>    __tmp<span class="token operator">-</span><span class="token operator">></span>_M_next <span class="token operator">=</span> __position<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 第一步</span>    __tmp<span class="token operator">-</span><span class="token operator">></span>_M_prev <span class="token operator">=</span> __position<span class="token operator">-</span><span class="token operator">></span>_M_prev<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 第二步</span>    __position<span class="token operator">-</span><span class="token operator">></span>_M_prev<span class="token operator">-</span><span class="token operator">></span>_M_next <span class="token operator">=</span> __tmp<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 第三步</span>    __position<span class="token operator">-</span><span class="token operator">></span>_M_prev <span class="token operator">=</span> __tmp<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 第四步</span><span class="token punctuation">}</span></code></pre><p>这种插入是在指定位置前插入，(对应到代码就是)例如实现在指定<code>__position</code>节点为7前插入节点值9的节点(对应到代码就是__tmp)，下面阐述了具体的插入流程。</p><p><img src="https://raw.githubusercontent.com/Light-City/cloudimg/master/list_insert.png" alt="list_insert"></p><p>（2）在末尾依次插入n个节点值为x的节点</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">_M_fill_initialize</span><span class="token punctuation">(</span>size_type __n<span class="token punctuation">,</span> <span class="token keyword">const</span> value_type <span class="token operator">&amp;</span>__x<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> __n<span class="token punctuation">;</span> <span class="token operator">--</span>__n<span class="token punctuation">)</span>        <span class="token function">_M_insert</span><span class="token punctuation">(</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> __x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>对于上述的代码大家或许会联想到<code>insert</code>,它有三个。<code>insert</code>实现文件在<code>libstdc++-v3/include/bits/list.tcc</code>。</p><ul><li><strong>第一：在指定迭代器之前插入指定元素值节点。</strong></li></ul><p>实现是调用前面的<code>_M_hook</code>函数。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _Tp<span class="token punctuation">,</span> <span class="token keyword">typename</span> _Alloc<span class="token operator">></span><span class="token keyword">typename</span> list<span class="token operator">&lt;</span>_Tp<span class="token punctuation">,</span> _Alloc<span class="token operator">></span><span class="token operator">::</span>iteratorlist<span class="token operator">&lt;</span>_Tp<span class="token punctuation">,</span> _Alloc<span class="token operator">></span><span class="token operator">::</span><span class="token macro property">#<span class="token directive keyword">if</span> __cplusplus >= 201103L</span><span class="token function">insert</span><span class="token punctuation">(</span>const_iterator __position<span class="token punctuation">,</span> <span class="token keyword">const</span> value_type<span class="token operator">&amp;</span> __x<span class="token punctuation">)</span><span class="token macro property">#<span class="token directive keyword">else</span></span><span class="token function">insert</span><span class="token punctuation">(</span>iterator __position<span class="token punctuation">,</span> <span class="token keyword">const</span> value_type<span class="token operator">&amp;</span> __x<span class="token punctuation">)</span><span class="token macro property">#<span class="token directive keyword">endif</span></span><span class="token punctuation">{</span>  _Node<span class="token operator">*</span> __tmp <span class="token operator">=</span> <span class="token function">_M_create_node</span><span class="token punctuation">(</span>__x<span class="token punctuation">)</span><span class="token punctuation">;</span>  __tmp<span class="token operator">-</span><span class="token operator">></span><span class="token function">_M_hook</span><span class="token punctuation">(</span>__position<span class="token punctuation">.</span><span class="token function">_M_const_cast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>_M_node<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token function">iterator</span><span class="token punctuation">(</span>__tmp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><ul><li><strong>第二：在指定迭代器之前插入n个指定节点值的节点。</strong></li></ul><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">insert</span><span class="token punctuation">(</span>iterator __position<span class="token punctuation">,</span> size_type __n<span class="token punctuation">,</span> <span class="token keyword">const</span> value_type <span class="token operator">&amp;</span>__x<span class="token punctuation">)</span> <span class="token punctuation">{</span>    list <span class="token function">__tmp</span><span class="token punctuation">(</span>__n<span class="token punctuation">,</span> __x<span class="token punctuation">,</span> <span class="token function">get_allocator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">splice</span><span class="token punctuation">(</span>__position<span class="token punctuation">,</span> __tmp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>实现是先调用list构造函数，完成创建一个拥有n个指定节点值的list。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">explicit</span> <span class="token function">list</span><span class="token punctuation">(</span>size_type __n<span class="token punctuation">,</span> <span class="token keyword">const</span> value_type <span class="token operator">&amp;</span>__value <span class="token operator">=</span> <span class="token function">value_type</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token keyword">const</span> allocator_type <span class="token operator">&amp;</span>__a <span class="token operator">=</span> <span class="token function">allocator_type</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">_Base</span><span class="token punctuation">(</span><span class="token function">_Node_alloc_type</span><span class="token punctuation">(</span>__a<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">_M_fill_initialize</span><span class="token punctuation">(</span>__n<span class="token punctuation">,</span> __value<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre><p>然后使用<code>splice</code>函数完成从另一个list中来插入当前list。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">splice</span><span class="token punctuation">(</span>iterator __position<span class="token punctuation">,</span> list <span class="token operator">&amp;</span>__x<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>__x<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">_M_check_equal_allocators</span><span class="token punctuation">(</span>__x<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">_M_transfer</span><span class="token punctuation">(</span>__position<span class="token punctuation">.</span><span class="token function">_M_const_cast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                          __x<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> __x<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>其中<code>_M_transfer</code>追踪代码，可以知道：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// Moves the elements from [first,last) before position.</span><span class="token keyword">void</span><span class="token function">_M_transfer</span><span class="token punctuation">(</span>iterator __position<span class="token punctuation">,</span> iterator __first<span class="token punctuation">,</span> iterator __last<span class="token punctuation">)</span> <span class="token punctuation">{</span>    __position<span class="token punctuation">.</span>_M_node<span class="token operator">-</span><span class="token operator">></span><span class="token function">_M_transfer</span><span class="token punctuation">(</span>__first<span class="token punctuation">.</span>_M_node<span class="token punctuation">,</span> __last<span class="token punctuation">.</span>_M_node<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>再次分析得到其来自list的基类<code>_List_node_base</code>，而<code>_M_transfer</code>实现文件在<code>gcc-4.9.1/libstdc++-v3/src/c++98/list.cc</code>中：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">void</span> _List_node_base<span class="token operator">::</span><span class="token function">_M_transfer</span><span class="token punctuation">(</span>_List_node_base <span class="token operator">*</span> <span class="token keyword">const</span> __first<span class="token punctuation">,</span>    _List_node_base <span class="token operator">*</span> <span class="token keyword">const</span> __last<span class="token punctuation">)</span> _GLIBCXX_USE_NOEXCEPT<span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">!=</span> __last<span class="token punctuation">)</span>  <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// Remove [first, last) from its old position.</span>      __last<span class="token operator">-</span><span class="token operator">></span>_M_prev<span class="token operator">-</span><span class="token operator">></span>_M_next  <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>      __first<span class="token operator">-</span><span class="token operator">></span>_M_prev<span class="token operator">-</span><span class="token operator">></span>_M_next <span class="token operator">=</span> __last<span class="token punctuation">;</span>      <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_prev<span class="token operator">-</span><span class="token operator">></span>_M_next    <span class="token operator">=</span> __first<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// Splice [first, last) into its new position.</span>      _List_node_base<span class="token operator">*</span> <span class="token keyword">const</span> __tmp <span class="token operator">=</span> <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_prev<span class="token punctuation">;</span>      <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_prev                <span class="token operator">=</span> __last<span class="token operator">-</span><span class="token operator">></span>_M_prev<span class="token punctuation">;</span>      __last<span class="token operator">-</span><span class="token operator">></span>_M_prev              <span class="token operator">=</span> __first<span class="token operator">-</span><span class="token operator">></span>_M_prev<span class="token punctuation">;</span>      __first<span class="token operator">-</span><span class="token operator">></span>_M_prev             <span class="token operator">=</span> __tmp<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>仍然是上述的图：</p><p><img src="https://raw.githubusercontent.com/Light-City/cloudimg/master/list_a.png" alt="list_all"></p><p>经过前面分析，我们知道<code>splice</code>是将上述图的所代表的整个list插入指定迭代器前面，例如，我们想要在下面两个节点前面插入，具体图形步骤如下：</p><p><code>this</code>代表的节点为值为8的节点，下图描述的就是在节点10与节点8中间插入整个list。</p><p><code>__last</code>代表的是红色框节点，该节点为<code>end()</code>指向的节点，我们是不需要该节点的，所以在后面处理中，会把该节点从整个list中去除掉。</p><p><code>__first</code>代表的是图中节点值为3的节点。</p><p><strong>第一步：先将最后一个有效节点，也就是红色框的前一个节点的next指针指向指定的节点8。</strong></p><p><img src="https://raw.githubusercontent.com/Light-City/cloudimg/master/step1.png" alt=""></p><p>对应代码为：</p><pre><code>__last-&gt;_M_prev-&gt;_M_next  = this;    </code></pre><p><strong>第二步：<code>_last</code>的next指针指向自己。</strong></p><p><img src="https://raw.githubusercontent.com/Light-City/cloudimg/master/step2.png" alt=""></p><p>对应的代码为：</p><pre><code>__first-&gt;_M_prev-&gt;_M_next = __last;</code></pre><p><strong>第三步：让指定迭代器之前的节点的nex指向原先list的第一个节点(<code>__first</code>)。</strong></p><p><img src="https://raw.githubusercontent.com/Light-City/cloudimg/master/step3.png" alt=""></p><p>对应的代码为：</p><pre><code>this-&gt;_M_prev-&gt;_M_next    = __first;</code></pre><p><strong>第四步：保存指定迭代器的前驱节点(对应到哪图中的节点值为10的节点)。</strong></p><pre><code>_List_node_base* const __tmp = this-&gt;_M_prev;</code></pre><p><strong>第五步：指定迭代器的前驱节点指向原list中实际最后一个节点(end()前一节点)。</strong></p><p><img src="https://raw.githubusercontent.com/Light-City/cloudimg/master/step5.png" alt=""></p><p>对应的代码为：</p><pre><code>this-&gt;_M_prev                = __last-&gt;_M_prev;</code></pre><p><strong>第六步：让原list的最后一个节点(end()指向的节点)的prev指向自己。</strong></p><p><img src="https://raw.githubusercontent.com/Light-City/cloudimg/master/step6.png" alt=""></p><p>对应的代码为：</p><pre><code>__last-&gt;_M_prev              = __first-&gt;_M_prev;</code></pre><p><strong>第七步：让原list第一个节点的prev指向第四步保存的节点。</strong></p><p><img src="https://raw.githubusercontent.com/Light-City/cloudimg/master/step7.png" alt=""></p><p>对应的代码为：</p><pre><code>__first-&gt;_M_prev             = __tmp;</code></pre><p>这样经过以上七步操作，完成了在节点8与节点10之前插入一个list。</p><ul><li><strong>第三：从一个list范围把数据插入到指定迭代器前面。</strong></li></ul><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _InputIterator<span class="token operator">></span><span class="token keyword">void</span><span class="token function">insert</span><span class="token punctuation">(</span>iterator __position<span class="token punctuation">,</span> _InputIterator __first<span class="token punctuation">,</span>       _InputIterator __last<span class="token punctuation">)</span> <span class="token punctuation">{</span>    list <span class="token function">__tmp</span><span class="token punctuation">(</span>__first<span class="token punctuation">,</span> __last<span class="token punctuation">,</span> <span class="token function">get_allocator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">splice</span><span class="token punctuation">(</span>__position<span class="token punctuation">,</span> __tmp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>原理同上，只不过这个<code>__tmp</code>是调用另外一个构造函数。</p><p>【<strong>删除节点</strong>】</p><ul><li>删除指定节点</li></ul><p>删除指定节点分为两个，第一个通过迭代器删除，第二个是通过元素值删除。</p><p><strong>（1）通过迭代器删除，对应函数为erase</strong></p><p>其中<code>pop_front</code>与<code>pop_back</code>、<code>erase</code>、<code>remove</code>底层实现基于<code>_M_erase</code>函数。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">_M_erase</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// pop_front 不断删除起点的元素</span><span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">_M_erase</span><span class="token punctuation">(</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_node<span class="token punctuation">.</span>_M_prev<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// pop_back移除最后一个元素</span></code></pre><p>在<code>libstdc++-v3/include/bits/list.tcc</code>中：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token function">erase</span><span class="token punctuation">(</span>iterator __position<span class="token punctuation">)</span><span class="token macro property">#<span class="token directive keyword">endif</span></span><span class="token punctuation">{</span>  iterator __ret <span class="token operator">=</span> <span class="token function">iterator</span><span class="token punctuation">(</span>__position<span class="token punctuation">.</span>_M_node<span class="token operator">-</span><span class="token operator">></span>_M_next<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">_M_erase</span><span class="token punctuation">(</span>__position<span class="token punctuation">.</span><span class="token function">_M_const_cast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> __ret<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><strong>（2）通过元素值删除，对应函数为remove</strong></p><p>特殊情况处理，当删除元素的地址与迭代器的地址一样的时候，先保存起来，最后判断保存的迭代器是不是end()，如果不是，就删除掉。底层仍旧是通过<code>_M_erase</code>删除。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _Tp<span class="token punctuation">,</span> <span class="token keyword">typename</span> _Alloc<span class="token operator">></span><span class="token keyword">void</span> list<span class="token operator">&lt;</span>_Tp<span class="token punctuation">,</span> _Alloc<span class="token operator">></span><span class="token operator">::</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token keyword">const</span> value_type<span class="token operator">&amp;</span> __value<span class="token punctuation">)</span><span class="token punctuation">{</span>  iterator __first <span class="token operator">=</span> <span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  iterator __last <span class="token operator">=</span> <span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  iterator __extra <span class="token operator">=</span> __last<span class="token punctuation">;</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span>__first <span class="token operator">!=</span> __last<span class="token punctuation">)</span>  <span class="token punctuation">{</span>      iterator __next <span class="token operator">=</span> __first<span class="token punctuation">;</span>      <span class="token operator">++</span>__next<span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>__first <span class="token operator">==</span> __value<span class="token punctuation">)</span>        <span class="token punctuation">{</span>          <span class="token comment" spellcheck="true">// _GLIBCXX_RESOLVE_LIB_DEFECTS</span>          <span class="token comment" spellcheck="true">// 526. Is it undefined if a function in the standard changes</span>          <span class="token comment" spellcheck="true">// in parameters?</span>          <span class="token keyword">if</span> <span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">__addressof</span><span class="token punctuation">(</span><span class="token operator">*</span>__first<span class="token punctuation">)</span> <span class="token operator">!=</span> std<span class="token operator">::</span><span class="token function">__addressof</span><span class="token punctuation">(</span>__value<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token function">_M_erase</span><span class="token punctuation">(</span>__first<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">else</span>        __extra <span class="token operator">=</span> __first<span class="token punctuation">;</span>        <span class="token punctuation">}</span>      __first <span class="token operator">=</span> __next<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>__extra <span class="token operator">!=</span> __last<span class="token punctuation">)</span>    <span class="token function">_M_erase</span><span class="token punctuation">(</span>__extra<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>除了这个remove外，还有一个是<code>remove_if</code>，根据条件来删除。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _Tp<span class="token punctuation">,</span> <span class="token keyword">typename</span> _Alloc<span class="token operator">></span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> _Predicate<span class="token operator">></span><span class="token keyword">void</span> list<span class="token operator">&lt;</span>_Tp<span class="token punctuation">,</span> _Alloc<span class="token operator">></span><span class="token operator">::</span><span class="token function">remove_if</span><span class="token punctuation">(</span>_Predicate __pred<span class="token punctuation">)</span><span class="token punctuation">{</span>    iterator __first <span class="token operator">=</span> <span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    iterator __last <span class="token operator">=</span> <span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>__first <span class="token operator">!=</span> __last<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        iterator __next <span class="token operator">=</span> __first<span class="token punctuation">;</span>        <span class="token operator">++</span>__next<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">__pred</span><span class="token punctuation">(</span><span class="token operator">*</span>__first<span class="token punctuation">)</span><span class="token punctuation">)</span>          <span class="token function">_M_erase</span><span class="token punctuation">(</span>__first<span class="token punctuation">)</span><span class="token punctuation">;</span>        __first <span class="token operator">=</span> __next<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>对上述的<code>remove</code>的if去掉，在里面添加一个判断即可。</p><p>使用如下</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token function">isone</span><span class="token punctuation">(</span><span class="token keyword">int</span> one<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> one<span class="token operator">==</span><span class="token number">2</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> t<span class="token punctuation">;</span>    t<span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    t<span class="token punctuation">.</span><span class="token function">remove_if</span><span class="token punctuation">(</span>isone<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><ul><li>删除一系列节点</li><li>删除所有节点，对应的函数<code>clear</code></li></ul><p><strong>（1）删除指定节点详细分析</strong></p><pre class=" language-cpp"><code class="language-cpp"><span class="token function">_M_erase</span><span class="token punctuation">(</span>iterator __position<span class="token punctuation">)</span>_GLIBCXX_NOEXCEPT<span class="token punctuation">{</span>    __position<span class="token punctuation">.</span>_M_node<span class="token operator">-</span><span class="token operator">></span><span class="token function">_M_unhook</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    _Node <span class="token operator">*</span>__n <span class="token operator">=</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span>_Node <span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">(</span>__position<span class="token punctuation">.</span>_M_node<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">if</span> __cplusplus >= 201103L</span>    <span class="token function">_M_get_Node_allocator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">destroy</span><span class="token punctuation">(</span>__n<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">else</span></span>    <span class="token function">_M_get_Tp_allocator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">destroy</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">__addressof</span><span class="token punctuation">(</span>__n<span class="token operator">-</span><span class="token operator">></span>_M_data<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">endif</span></span>    <span class="token function">_M_put_node</span><span class="token punctuation">(</span>__n<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 释放内存</span><span class="token punctuation">}</span></code></pre><p>其中<code>_M_unhook</code>实现在<code>gcc-4.9.1/libstdc++-v3/src/c++98/list.cc</code>，实现如下：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">void</span> _List_node_base<span class="token operator">::</span><span class="token function">_M_unhook</span><span class="token punctuation">(</span><span class="token punctuation">)</span> _GLIBCXX_USE_NOEXCEPT<span class="token punctuation">{</span>  _List_node_base<span class="token operator">*</span> <span class="token keyword">const</span> __next_node <span class="token operator">=</span> <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_next<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 第一步：保存后继节点</span>  _List_node_base<span class="token operator">*</span> <span class="token keyword">const</span> __prev_node <span class="token operator">=</span> <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_prev<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 第二步：保存前驱节点</span>  __prev_node<span class="token operator">-</span><span class="token operator">></span>_M_next <span class="token operator">=</span> __next_node<span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// 第三步：前驱节点的next指向后继节点</span>  __next_node<span class="token operator">-</span><span class="token operator">></span>_M_prev <span class="token operator">=</span> __prev_node<span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// 第四步：后继节点的prev指向前驱节点</span><span class="token punctuation">}</span></code></pre><p>例如：删除节点值为9的节点，第三与第四步图解：</p><p><img src="https://raw.githubusercontent.com/Light-City/cloudimg/master/list_erase.png" alt="list_erase"></p><p><strong>（2）删除一系列元素详细分析</strong></p><pre class=" language-cpp"><code class="language-cpp">iterator<span class="token macro property">#<span class="token directive keyword">if</span> __cplusplus >= 201103L</span><span class="token function">erase</span><span class="token punctuation">(</span>const_iterator __first<span class="token punctuation">,</span> const_iterator __last<span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token macro property">#<span class="token directive keyword">else</span></span><span class="token function">erase</span><span class="token punctuation">(</span>iterator __first<span class="token punctuation">,</span> iterator __last<span class="token punctuation">)</span><span class="token macro property">#<span class="token directive keyword">endif</span></span><span class="token punctuation">{</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>__first <span class="token operator">!=</span> __last<span class="token punctuation">)</span>        __first <span class="token operator">=</span> <span class="token function">erase</span><span class="token punctuation">(</span>__first<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> __last<span class="token punctuation">.</span><span class="token function">_M_const_cast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>使用erase，删除给定迭代器范围内的数据。</p><p><strong>（3）删除所有元素详细分析</strong></p><p>清空元素，并初始化，回到list默认状态。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span>_GLIBCXX_NOEXCEPT<span class="token punctuation">{</span>    _Base<span class="token operator">::</span><span class="token function">_M_clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    _Base<span class="token operator">::</span><span class="token function">_M_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>其中<code>_M_clear</code>实现在：<code>libstdc++-v3/include/bits/list.tcc</code>中：</p><pre class=" language-cpp"><code class="language-cpp">_List_base<span class="token operator">&lt;</span>_Tp<span class="token punctuation">,</span> _Alloc<span class="token operator">></span><span class="token operator">::</span><span class="token function">_M_clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span> _GLIBCXX_NOEXCEPT<span class="token punctuation">{</span>  <span class="token keyword">typedef</span> _List_node<span class="token operator">&lt;</span>_Tp<span class="token operator">></span>  _Node<span class="token punctuation">;</span>  _Node<span class="token operator">*</span> __cur <span class="token operator">=</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span>_Node<span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">(</span>_M_impl<span class="token punctuation">.</span>_M_node<span class="token punctuation">.</span>_M_next<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span>__cur <span class="token operator">!=</span> <span class="token operator">&amp;</span>_M_impl<span class="token punctuation">.</span>_M_node<span class="token punctuation">)</span>    <span class="token punctuation">{</span>      _Node<span class="token operator">*</span> __tmp <span class="token operator">=</span> __cur<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 保存节点</span>      __cur <span class="token operator">=</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span>_Node<span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">(</span>__cur<span class="token operator">-</span><span class="token operator">></span>_M_next<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 往后遍历</span>    <span class="token macro property">#<span class="token directive keyword">if</span> __cplusplus >= 201103L</span>      <span class="token function">_M_get_Node_allocator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">destroy</span><span class="token punctuation">(</span>__tmp<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token macro property">#<span class="token directive keyword">else</span></span>      <span class="token function">_M_get_Tp_allocator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">destroy</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">__addressof</span><span class="token punctuation">(</span>__tmp<span class="token operator">-</span><span class="token operator">></span>_M_data<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token macro property">#<span class="token directive keyword">endif</span></span>      <span class="token function">_M_put_node</span><span class="token punctuation">(</span>__tmp<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 释放内存</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><code>_M_init</code>实现，全部指向自己即可。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">_M_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span>_GLIBCXX_NOEXCEPT<span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_node<span class="token punctuation">.</span>_M_next <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_node<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_node<span class="token punctuation">.</span>_M_prev <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_node<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>【<strong>元素访问</strong>】</p><p>每个都实现了两个版本：引用与常引用。</p><ul><li>front 返回第一个元素</li></ul><pre class=" language-cpp"><code class="language-cpp">reference <span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span>_GLIBCXX_NOEXCEPT<span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token operator">*</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>const_reference<span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>_GLIBCXX_NOEXCEPT<span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token operator">*</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre><ul><li>返回最后一个元素</li></ul><pre class=" language-cpp"><code class="language-cpp">reference<span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span>_GLIBCXX_NOEXCEPT<span class="token punctuation">{</span>    iterator __tmp <span class="token operator">=</span> <span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">--</span>__tmp<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token operator">*</span>__tmp<span class="token punctuation">;</span><span class="token punctuation">}</span>const_reference<span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>_GLIBCXX_NOEXCEPT<span class="token punctuation">{</span>    const_iterator __tmp <span class="token operator">=</span> <span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">--</span>__tmp<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token operator">*</span>__tmp<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>【<strong>算法</strong>】</p><ul><li>unique</li></ul><p>从容器中的每个连续的相等元素组中除去除第一个元素外的所有元素。</p><p>请注意，只有与<a href="http://www.cplusplus.com/list" target="_blank" rel="noopener">列表</a>容器紧邻的元素相比，该元素才从<a href="http://www.cplusplus.com/list" target="_blank" rel="noopener">列表</a>容器中删除。因此，此功能对于排序列表特别有用。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _Tp<span class="token punctuation">,</span> <span class="token keyword">typename</span> _Alloc<span class="token operator">></span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> _BinaryPredicate<span class="token operator">></span>  <span class="token keyword">void</span>  list<span class="token operator">&lt;</span>_Tp<span class="token punctuation">,</span> _Alloc<span class="token operator">></span><span class="token operator">::</span>  <span class="token function">unique</span><span class="token punctuation">(</span>_BinaryPredicate __binary_pred<span class="token punctuation">)</span>  <span class="token punctuation">{</span>    iterator __first <span class="token operator">=</span> <span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    iterator __last <span class="token operator">=</span> <span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>__first <span class="token operator">==</span> __last<span class="token punctuation">)</span>  <span class="token keyword">return</span><span class="token punctuation">;</span>    iterator __next <span class="token operator">=</span> __first<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">++</span>__next <span class="token operator">!=</span> __last<span class="token punctuation">)</span>  <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 满足条件就删除</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">__binary_pred</span><span class="token punctuation">(</span><span class="token operator">*</span>__first<span class="token punctuation">,</span> <span class="token operator">*</span>__next<span class="token punctuation">)</span><span class="token punctuation">)</span>       <span class="token comment" spellcheck="true">// 删除</span>      <span class="token function">_M_erase</span><span class="token punctuation">(</span>__next<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>      __first <span class="token operator">=</span> __next<span class="token punctuation">;</span>    __next <span class="token operator">=</span> __first<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token punctuation">}</span></code></pre><p>举例如下：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// list::unique</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;cmath></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;list></span></span><span class="token comment" spellcheck="true">// a binary predicate implemented as a function:</span><span class="token keyword">bool</span> <span class="token function">same_integral_part</span> <span class="token punctuation">(</span><span class="token keyword">double</span> first<span class="token punctuation">,</span> <span class="token keyword">double</span> second<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token punctuation">(</span> <span class="token keyword">int</span><span class="token punctuation">(</span>first<span class="token punctuation">)</span><span class="token operator">==</span><span class="token keyword">int</span><span class="token punctuation">(</span>second<span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token comment" spellcheck="true">// a binary predicate implemented as a class:</span><span class="token keyword">struct</span> is_near <span class="token punctuation">{</span>  <span class="token keyword">bool</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">double</span> first<span class="token punctuation">,</span> <span class="token keyword">double</span> second<span class="token punctuation">)</span>  <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token function">fabs</span><span class="token punctuation">(</span>first<span class="token operator">-</span>second<span class="token punctuation">)</span><span class="token operator">&lt;</span><span class="token number">5.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">double</span> mydoubles<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">{</span> <span class="token number">12.15</span><span class="token punctuation">,</span>  <span class="token number">2.72</span><span class="token punctuation">,</span> <span class="token number">73.0</span><span class="token punctuation">,</span>  <span class="token number">12.77</span><span class="token punctuation">,</span>  <span class="token number">3.14</span><span class="token punctuation">,</span>                       <span class="token number">12.77</span><span class="token punctuation">,</span> <span class="token number">73.35</span><span class="token punctuation">,</span> <span class="token number">72.25</span><span class="token punctuation">,</span> <span class="token number">15.3</span><span class="token punctuation">,</span>  <span class="token number">72.25</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>  std<span class="token operator">::</span>list<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">></span> <span class="token function">mylist</span> <span class="token punctuation">(</span>mydoubles<span class="token punctuation">,</span>mydoubles<span class="token operator">+</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  mylist<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">//  2.72,  3.14, 12.15, 12.77, 12.77,</span>                             <span class="token comment" spellcheck="true">// 15.3,  72.25, 72.25, 73.0,  73.35</span>  mylist<span class="token punctuation">.</span><span class="token function">unique</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">//  2.72,  3.14, 12.15, 12.77</span>                             <span class="token comment" spellcheck="true">// 15.3,  72.25, 73.0,  73.35</span>  mylist<span class="token punctuation">.</span><span class="token function">unique</span> <span class="token punctuation">(</span>same_integral_part<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//  2.72,  3.14, 12.15</span>                                       <span class="token comment" spellcheck="true">// 15.3,  72.25, 73.0</span>  mylist<span class="token punctuation">.</span><span class="token function">unique</span> <span class="token punctuation">(</span><span class="token function">is_near</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">//  2.72, 12.15, 72.25</span>  std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"mylist contains:"</span><span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span>std<span class="token operator">::</span>list<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">></span><span class="token operator">::</span>iterator it<span class="token operator">=</span>mylist<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> it<span class="token operator">!=</span>mylist<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>it<span class="token punctuation">)</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">' '</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>it<span class="token punctuation">;</span>  std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>上述排序后会删除所有的重复元素，只剩下一个，而不排序只会删除重复且连续的元素。</p><ul><li>merge</li></ul><p>merge源码实现采用前面<code>_M_transfer</code>函数，假设现在有两个list，分别是list1与list2。list1中的元素与list2中的元素进行比较，如果list1中元素值小于list2中元素值，则对list1迭代器++，不进行任何操作，而如果list1中的元素值大于list2中的元素值，那么每次将list2这个小的元素对应的迭代器塞入<code>_M_transfer</code>函数中，通过这个函数完成向list1中刚才比较的迭代器前面插入list2较小的元素，那么最后所有元素都会被插入到list1中。</p><p>当list1已经遍历完毕，而list2还没有遍历完毕，那么只需要执行一次<code>_M_transfer</code>，将list2链表从当前迭代器开始到最后的end插入到list1的末尾即可。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _Tp<span class="token punctuation">,</span> <span class="token keyword">typename</span> _Alloc<span class="token operator">></span><span class="token keyword">void</span>list<span class="token operator">&lt;</span>_Tp<span class="token punctuation">,</span> _Alloc<span class="token operator">></span><span class="token operator">::</span><span class="token macro property">#<span class="token directive keyword">if</span> __cplusplus >= 201103L</span><span class="token function">merge</span><span class="token punctuation">(</span>list<span class="token operator">&amp;&amp;</span> __x<span class="token punctuation">)</span><span class="token macro property">#<span class="token directive keyword">else</span></span><span class="token function">merge</span><span class="token punctuation">(</span>list<span class="token operator">&amp;</span> __x<span class="token punctuation">)</span><span class="token macro property">#<span class="token directive keyword">endif</span></span><span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// _GLIBCXX_RESOLVE_LIB_DEFECTS</span>  <span class="token comment" spellcheck="true">// 300. list::merge() specification incomplete</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">!=</span> <span class="token operator">&amp;</span>__x<span class="token punctuation">)</span>  <span class="token punctuation">{</span>      <span class="token function">_M_check_equal_allocators</span><span class="token punctuation">(</span>__x<span class="token punctuation">)</span><span class="token punctuation">;</span>      iterator __first1 <span class="token operator">=</span> <span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      iterator __last1 <span class="token operator">=</span> <span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      iterator __first2 <span class="token operator">=</span> __x<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      iterator __last2 <span class="token operator">=</span> __x<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">while</span> <span class="token punctuation">(</span>__first1 <span class="token operator">!=</span> __last1 <span class="token operator">&amp;&amp;</span> __first2 <span class="token operator">!=</span> __last2<span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>__first2 <span class="token operator">&lt;</span> <span class="token operator">*</span>__first1<span class="token punctuation">)</span>         <span class="token punctuation">{</span>            iterator __next <span class="token operator">=</span> __first2<span class="token punctuation">;</span>            <span class="token function">_M_transfer</span><span class="token punctuation">(</span>__first1<span class="token punctuation">,</span> __first2<span class="token punctuation">,</span> <span class="token operator">++</span>__next<span class="token punctuation">)</span><span class="token punctuation">;</span>            __first2 <span class="token operator">=</span> __next<span class="token punctuation">;</span>         <span class="token punctuation">}</span>        <span class="token keyword">else</span>          <span class="token operator">++</span>__first1<span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>__first2 <span class="token operator">!=</span> __last2<span class="token punctuation">)</span>        <span class="token function">_M_transfer</span><span class="token punctuation">(</span>__last1<span class="token punctuation">,</span> __first2<span class="token punctuation">,</span> __last2<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>使用：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> l1 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> l2 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    l1<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    l2<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    l1<span class="token punctuation">.</span><span class="token function">merge</span><span class="token punctuation">(</span>l2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><ul><li>sort</li></ul><p>由于STL本身的排序算法sort接受的输入迭代器是随机访问迭代器，但是双向list链表容器的访问方式是双向迭代器，因此，不能使用STL本身的排序算法sort，必须自己定义属于自己访问的排序算法。我们从源码的剖析中，可以看到该排序算法思想类似于归并排序。</p><p>sort中splice调用的是：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">splice</span><span class="token punctuation">(</span>const_iterator __position<span class="token punctuation">,</span> list<span class="token operator">&amp;</span> __x<span class="token punctuation">,</span> const_iterator __i<span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">{</span> <span class="token function">splice</span><span class="token punctuation">(</span>__position<span class="token punctuation">,</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>__x<span class="token punctuation">)</span><span class="token punctuation">,</span> __i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre><p>进一步分析：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">void</span><span class="token function">splice</span><span class="token punctuation">(</span>iterator __position<span class="token punctuation">,</span> list <span class="token operator">&amp;</span>__x<span class="token punctuation">,</span> iterator __i<span class="token punctuation">)</span><span class="token punctuation">{</span>    iterator __j <span class="token operator">=</span> __i<span class="token punctuation">.</span><span class="token function">_M_const_cast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">++</span>__j<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>__position <span class="token operator">==</span> __i <span class="token operator">||</span> __position <span class="token operator">==</span> __j<span class="token punctuation">)</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">!=</span> <span class="token operator">&amp;</span>__x<span class="token punctuation">)</span>        <span class="token function">_M_check_equal_allocators</span><span class="token punctuation">(</span>__x<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span><span class="token punctuation">(</span>__position<span class="token punctuation">.</span><span class="token function">_M_const_cast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                      __i<span class="token punctuation">.</span><span class="token function">_M_const_cast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> __j<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>最后调用的是<code>_M_transfer</code>。</p><p>在sort中还有一个函数<code>swap</code>，完成两个链表交换，实现代码在<code>gcc-4.9.1/libstdc++-v3/src/c++98/list.cc</code>中：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">void</span>_List_node_base<span class="token operator">::</span><span class="token function">swap</span><span class="token punctuation">(</span>_List_node_base<span class="token operator">&amp;</span> __x<span class="token punctuation">,</span>          _List_node_base<span class="token operator">&amp;</span> __y<span class="token punctuation">)</span> _GLIBCXX_USE_NOEXCEPT<span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span> __x<span class="token punctuation">.</span>_M_next <span class="token operator">!=</span> <span class="token operator">&amp;</span>__x <span class="token punctuation">)</span>    <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span> __y<span class="token punctuation">.</span>_M_next <span class="token operator">!=</span> <span class="token operator">&amp;</span>__y <span class="token punctuation">)</span>        <span class="token punctuation">{</span>          <span class="token comment" spellcheck="true">// Both __x and __y are not empty.</span>          std<span class="token operator">::</span><span class="token function">swap</span><span class="token punctuation">(</span>__x<span class="token punctuation">.</span>_M_next<span class="token punctuation">,</span>__y<span class="token punctuation">.</span>_M_next<span class="token punctuation">)</span><span class="token punctuation">;</span>          std<span class="token operator">::</span><span class="token function">swap</span><span class="token punctuation">(</span>__x<span class="token punctuation">.</span>_M_prev<span class="token punctuation">,</span>__y<span class="token punctuation">.</span>_M_prev<span class="token punctuation">)</span><span class="token punctuation">;</span>          __x<span class="token punctuation">.</span>_M_next<span class="token operator">-</span><span class="token operator">></span>_M_prev <span class="token operator">=</span> __x<span class="token punctuation">.</span>_M_prev<span class="token operator">-</span><span class="token operator">></span>_M_next <span class="token operator">=</span> <span class="token operator">&amp;</span>__x<span class="token punctuation">;</span>          __y<span class="token punctuation">.</span>_M_next<span class="token operator">-</span><span class="token operator">></span>_M_prev <span class="token operator">=</span> __y<span class="token punctuation">.</span>_M_prev<span class="token operator">-</span><span class="token operator">></span>_M_next <span class="token operator">=</span> <span class="token operator">&amp;</span>__y<span class="token punctuation">;</span>        <span class="token punctuation">}</span>      <span class="token keyword">else</span>        <span class="token punctuation">{</span>              <span class="token comment" spellcheck="true">// __x is not empty, __y is empty.</span>              __y<span class="token punctuation">.</span>_M_next <span class="token operator">=</span> __x<span class="token punctuation">.</span>_M_next<span class="token punctuation">;</span>              __y<span class="token punctuation">.</span>_M_prev <span class="token operator">=</span> __x<span class="token punctuation">.</span>_M_prev<span class="token punctuation">;</span>              __y<span class="token punctuation">.</span>_M_next<span class="token operator">-</span><span class="token operator">></span>_M_prev <span class="token operator">=</span> __y<span class="token punctuation">.</span>_M_prev<span class="token operator">-</span><span class="token operator">></span>_M_next <span class="token operator">=</span> <span class="token operator">&amp;</span>__y<span class="token punctuation">;</span>              __x<span class="token punctuation">.</span>_M_next <span class="token operator">=</span> __x<span class="token punctuation">.</span>_M_prev <span class="token operator">=</span> <span class="token operator">&amp;</span>__x<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>      <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span> __y<span class="token punctuation">.</span>_M_next <span class="token operator">!=</span> <span class="token operator">&amp;</span>__y <span class="token punctuation">)</span>        <span class="token punctuation">{</span>          <span class="token comment" spellcheck="true">// __x is empty, __y is not empty.</span>          __x<span class="token punctuation">.</span>_M_next <span class="token operator">=</span> __y<span class="token punctuation">.</span>_M_next<span class="token punctuation">;</span>          __x<span class="token punctuation">.</span>_M_prev <span class="token operator">=</span> __y<span class="token punctuation">.</span>_M_prev<span class="token punctuation">;</span>          __x<span class="token punctuation">.</span>_M_next<span class="token operator">-</span><span class="token operator">></span>_M_prev <span class="token operator">=</span> __x<span class="token punctuation">.</span>_M_prev<span class="token operator">-</span><span class="token operator">></span>_M_next <span class="token operator">=</span> <span class="token operator">&amp;</span>__x<span class="token punctuation">;</span>          __y<span class="token punctuation">.</span>_M_next <span class="token operator">=</span> __y<span class="token punctuation">.</span>_M_prev <span class="token operator">=</span> <span class="token operator">&amp;</span>__y<span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>具体的实现思路是，判断两个链表为空还是不为空，然后修改next指针与prev指针。</p><p>下面来看看强大的sort：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _Tp<span class="token punctuation">,</span> <span class="token keyword">typename</span> _Alloc<span class="token operator">></span><span class="token keyword">void</span>list<span class="token operator">&lt;</span>_Tp<span class="token punctuation">,</span> _Alloc<span class="token operator">></span><span class="token operator">::</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// Do nothing if the list has length 0 or 1.</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_node<span class="token punctuation">.</span>_M_next <span class="token operator">!=</span> <span class="token operator">&amp;</span><span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_node        <span class="token operator">&amp;&amp;</span> <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_node<span class="token punctuation">.</span>_M_next<span class="token operator">-</span><span class="token operator">></span>_M_next <span class="token operator">!=</span> <span class="token operator">&amp;</span><span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_node<span class="token punctuation">)</span> <span class="token punctuation">{</span>        list __carry<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 辅助链表，用于从a中提取元素以及临时保存两个链表的合并结果</span>        list __tmp<span class="token punctuation">[</span><span class="token number">64</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 保存着当前每一个归并层次的结果, i号链表保存的元素个数为2的i次方或者0</span>        list <span class="token operator">*</span>__fill <span class="token operator">=</span> <span class="token operator">&amp;</span>__tmp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 表示当前最大归并排序的层次，while循环之后__fill变成log2(list.size())</span>        list <span class="token operator">*</span>__counter<span class="token punctuation">;</span>        <span class="token keyword">do</span> <span class="token punctuation">{</span>            __carry<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>__carry<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//把当前链表的第一个节点放在carry链表头</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>__counter <span class="token operator">=</span> <span class="token operator">&amp;</span>__tmp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                 __counter <span class="token operator">!=</span> __fill <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>__counter<span class="token operator">-</span><span class="token operator">></span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token operator">++</span>__counter<span class="token punctuation">)</span> <span class="token punctuation">{</span>                __counter<span class="token operator">-</span><span class="token operator">></span><span class="token function">merge</span><span class="token punctuation">(</span>__carry<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 两个有序链表合并</span>                __carry<span class="token punctuation">.</span><span class="token function">swap</span><span class="token punctuation">(</span><span class="token operator">*</span>__counter<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 类似于交换链表carry和counter[i]内容    </span>            <span class="token punctuation">}</span>            __carry<span class="token punctuation">.</span><span class="token function">swap</span><span class="token punctuation">(</span><span class="token operator">*</span>__counter<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 类似于交换链表carry和counter[i]内容    </span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>__counter <span class="token operator">==</span> __fill<span class="token punctuation">)</span>                <span class="token operator">++</span>__fill<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 每两个进行归并，依次网上，直到最后*(__fill-1)保存最后的排序结果。然后交换到当前list中。</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>__counter <span class="token operator">=</span> <span class="token operator">&amp;</span>__tmp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> __counter <span class="token operator">!=</span> __fill<span class="token punctuation">;</span> <span class="token operator">++</span>__counter<span class="token punctuation">)</span>            __counter<span class="token operator">-</span><span class="token operator">></span><span class="token function">merge</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span>__counter <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">swap</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span>__fill <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>上述代码看起来比较难懂，在网上查找后发现，G2.9中：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Alloc</span><span class="token operator">></span><span class="token keyword">void</span> list<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> Alloc<span class="token operator">></span> <span class="token operator">::</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 判断链表是否为空或者只有一个元素</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>next <span class="token operator">==</span> node <span class="token operator">||</span> <span class="token function">link_type</span><span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span>next <span class="token operator">==</span> node<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    list<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> Alloc<span class="token operator">></span> carry<span class="token punctuation">;</span>    list<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> alloc<span class="token operator">></span> counter<span class="token punctuation">[</span><span class="token number">64</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> fill <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        carry<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>carry<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> fill <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>counter<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            counter<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">merge</span><span class="token punctuation">(</span>carry<span class="token punctuation">)</span><span class="token punctuation">;</span>            carry<span class="token punctuation">.</span><span class="token function">swap</span><span class="token punctuation">(</span>counter<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        carry<span class="token punctuation">.</span><span class="token function">swap</span><span class="token punctuation">(</span>counter<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">==</span> fill<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token operator">++</span>fill<span class="token punctuation">;</span>        <span class="token punctuation">}</span>     <span class="token punctuation">}</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> fill<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>        counter<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">merge</span><span class="token punctuation">(</span>counter<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">swap</span><span class="token punctuation">(</span>counter<span class="token punctuation">[</span>fill<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>对应的外部实现是：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">sortList</span><span class="token punctuation">(</span>list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token operator">&amp;</span>l<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>l<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> carry<span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// 辅助链表，用于从a中提取元素以及临时保存两个链表的合并结果</span>    list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> counter<span class="token punctuation">[</span><span class="token number">64</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 保存着当前每一个归并层次的结果, i号链表保存的元素个数为2的i次方或者0</span>    <span class="token keyword">int</span> fill <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// 表示当前最大归并排序的层次，while循环之后fill变成log2(a.size())</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>l<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        carry<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>carry<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> l<span class="token punctuation">,</span> l<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 将链表a中的第一个元素移动至carry开头</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 从小往大不断合并非空归并层次直至遇到空层或者到达当前最大归并层次</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> fill <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>counter<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            counter<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">merge</span><span class="token punctuation">(</span>carry<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 链表合并，结果链表是有序的，必须保证合并前两个链表是有序的</span>            carry<span class="token punctuation">.</span><span class="token function">swap</span><span class="token punctuation">(</span>counter<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 链表元素互换</span>        <span class="token punctuation">}</span>        carry<span class="token punctuation">.</span><span class="token function">swap</span><span class="token punctuation">(</span>counter<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> fill<span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token comment" spellcheck="true">// i到达当前最大归并层次，说明得增加一层</span>            <span class="token operator">++</span>fill<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> fill<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 将所有归并层次的结果合并得到最终结果counter[fill - 1]</span>        counter<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">merge</span><span class="token punctuation">(</span>counter<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    l<span class="token punctuation">.</span><span class="token function">swap</span><span class="token punctuation">(</span>counter<span class="token punctuation">[</span>fill <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>这一块可以参考</p><blockquote><p><a href="https://blog.csdn.net/chenhanzhun/article/details/39337331" target="_blank" rel="noopener">https://blog.csdn.net/chenhanzhun/article/details/39337331</a></p></blockquote><p>上面给出了详细的过程图解。</p><p>我们再次将G4.9转换对应的外部实现：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">sortList1</span><span class="token punctuation">(</span>list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token operator">&amp;</span>l<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">typedef</span> list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> list<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>l<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    list __carry<span class="token punctuation">;</span>    list __tmp<span class="token punctuation">[</span><span class="token number">64</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    list <span class="token operator">*</span>__fill <span class="token operator">=</span> <span class="token operator">&amp;</span>__tmp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    list <span class="token operator">*</span>__counter<span class="token punctuation">;</span>    <span class="token keyword">do</span> <span class="token punctuation">{</span>        __carry<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>__carry<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> l<span class="token punctuation">,</span> l<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>__counter <span class="token operator">=</span> <span class="token operator">&amp;</span>__tmp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>             __counter <span class="token operator">!=</span> __fill <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>__counter<span class="token operator">-</span><span class="token operator">></span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token operator">++</span>__counter<span class="token punctuation">)</span> <span class="token punctuation">{</span>            __counter<span class="token operator">-</span><span class="token operator">></span><span class="token function">merge</span><span class="token punctuation">(</span>__carry<span class="token punctuation">)</span><span class="token punctuation">;</span>            __carry<span class="token punctuation">.</span><span class="token function">swap</span><span class="token punctuation">(</span><span class="token operator">*</span>__counter<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        __carry<span class="token punctuation">.</span><span class="token function">swap</span><span class="token punctuation">(</span><span class="token operator">*</span>__counter<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>__counter <span class="token operator">==</span> __fill<span class="token punctuation">)</span> <span class="token operator">++</span>__fill<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>l<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>__counter <span class="token operator">=</span> <span class="token operator">&amp;</span>__tmp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> __counter <span class="token operator">!=</span> __fill<span class="token punctuation">;</span> <span class="token operator">++</span>__counter<span class="token punctuation">)</span>        __counter<span class="token operator">-</span><span class="token operator">></span><span class="token function">merge</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span>__counter <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    l<span class="token punctuation">.</span><span class="token function">swap</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span>__fill <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>使用：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> l <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"===============排序前=============="</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> i<span class="token operator">:</span>l<span class="token punctuation">)</span> cout <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token function">sortList1</span><span class="token punctuation">(</span>l<span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"===============排序后=============="</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> i<span class="token operator">:</span>l<span class="token punctuation">)</span> cout <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>【<strong>操作符重载</strong>】</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _Tp<span class="token punctuation">,</span> <span class="token keyword">typename</span> _Alloc<span class="token operator">></span><span class="token keyword">inline</span> <span class="token keyword">bool</span><span class="token keyword">operator</span><span class="token operator">==</span><span class="token punctuation">(</span><span class="token keyword">const</span> list<span class="token operator">&lt;</span>_Tp<span class="token punctuation">,</span> _Alloc<span class="token operator">></span> <span class="token operator">&amp;</span>__x<span class="token punctuation">,</span> <span class="token keyword">const</span> list<span class="token operator">&lt;</span>_Tp<span class="token punctuation">,</span> _Alloc<span class="token operator">></span> <span class="token operator">&amp;</span>__y<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">typedef</span> <span class="token keyword">typename</span> list<span class="token operator">&lt;</span>_Tp<span class="token punctuation">,</span> _Alloc<span class="token operator">></span><span class="token operator">::</span>const_iterator const_iterator<span class="token punctuation">;</span>    const_iterator __end1 <span class="token operator">=</span> __x<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    const_iterator __end2 <span class="token operator">=</span> __y<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    const_iterator __i1 <span class="token operator">=</span> __x<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    const_iterator __i2 <span class="token operator">=</span> __y<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>__i1 <span class="token operator">!=</span> __end1 <span class="token operator">&amp;&amp;</span> __i2 <span class="token operator">!=</span> __end2 <span class="token operator">&amp;&amp;</span> <span class="token operator">*</span>__i1 <span class="token operator">==</span> <span class="token operator">*</span>__i2<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token operator">++</span>__i1<span class="token punctuation">;</span>        <span class="token operator">++</span>__i2<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> __i1 <span class="token operator">==</span> __end1 <span class="token operator">&amp;&amp;</span> __i2 <span class="token operator">==</span> __end2<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>实现思路是，迭代判断两个迭代器是否都抵达末尾。</p><p>剩下就是其他的操作符重载，比较简单，就不阐述了。其中<code>lexicographical_compare</code>实现在<code>c++-v3/src/c++98/stl_algobase.h</code>中，该函数是按照字典序测试[frist1,last1)是否小于[first2,last2)。该函数使用opeartor&lt;或者是comp进行比较。其行为类似于：如果两个序列长度不同，并且短序列和长序列头部完全一样，例如example和examplee.那么，长度大的字典序比短序的大。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">InputIterator1</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">InputIterator2</span><span class="token operator">></span><span class="token keyword">bool</span> <span class="token function">lexicographical_compare</span> <span class="token punctuation">(</span>InputIterator1 first1<span class="token punctuation">,</span> InputIterator1 last1<span class="token punctuation">,</span>InputIterator2 first2<span class="token punctuation">,</span> InputIterator2 last2<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>first1<span class="token operator">!=</span>last1<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>first2<span class="token operator">==</span>last2 <span class="token operator">||</span> <span class="token operator">*</span>first2<span class="token operator">&lt;</span><span class="token operator">*</span>first1<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>first1<span class="token operator">&lt;</span><span class="token operator">*</span>first2<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token operator">++</span>first1<span class="token punctuation">;</span> <span class="token operator">++</span>first2<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>first2<span class="token operator">!=</span>last2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>使用：</p><pre><code>int main() {     vector&lt;char&gt; v1{'h','e','l','l','o'};    vector&lt;char&gt; v2{'h','e','l','l','o','o'};    vector&lt;char&gt; v3{'h','e','l','m','o'};    cout&lt;&lt;"v1=";    for(char i:v1)        cout&lt;&lt;i&lt;&lt;" ";    cout&lt;&lt;endl;    cout&lt;&lt;"v2=";    for(char i:v2)        cout&lt;&lt;i&lt;&lt;" ";    cout&lt;&lt;endl;    cout&lt;&lt;"v3=";    for(char i:v3)        cout&lt;&lt;i&lt;&lt;" ";    cout&lt;&lt;endl;    if(lexicographical_compare(v1.begin(),v1.end(),v2.begin(),v2.end()))        cout&lt;&lt;"v1 is less than v2 "&lt;&lt;endl;    else        cout&lt;&lt;"v2 is less than v1 "&lt;&lt;endl;    if(lexicographical_compare(v1.begin(),v1.end(),v3.begin(),v3.end()))        cout&lt;&lt;"v1 is less than v3 "&lt;&lt;endl;    else        cout&lt;&lt;"v3 is less than v1 "&lt;&lt;endl;}</code></pre><p>其它重载操作符如下：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _Tp<span class="token punctuation">,</span> <span class="token keyword">typename</span> _Alloc<span class="token operator">></span><span class="token keyword">inline</span> <span class="token keyword">bool</span><span class="token keyword">operator</span><span class="token operator">&lt;</span><span class="token punctuation">(</span><span class="token keyword">const</span> list<span class="token operator">&lt;</span>_Tp<span class="token punctuation">,</span> _Alloc<span class="token operator">></span> <span class="token operator">&amp;</span>__x<span class="token punctuation">,</span> <span class="token keyword">const</span> list<span class="token operator">&lt;</span>_Tp<span class="token punctuation">,</span> _Alloc<span class="token operator">></span> <span class="token operator">&amp;</span>__y<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> std<span class="token operator">::</span><span class="token function">lexicographical_compare</span><span class="token punctuation">(</span>__x<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> __x<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                                        __y<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> __y<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/// Based on operator==</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _Tp<span class="token punctuation">,</span> <span class="token keyword">typename</span> _Alloc<span class="token operator">></span><span class="token keyword">inline</span> <span class="token keyword">bool</span><span class="token keyword">operator</span><span class="token operator">!=</span><span class="token punctuation">(</span><span class="token keyword">const</span> list<span class="token operator">&lt;</span>_Tp<span class="token punctuation">,</span> _Alloc<span class="token operator">></span> <span class="token operator">&amp;</span>__x<span class="token punctuation">,</span> <span class="token keyword">const</span> list<span class="token operator">&lt;</span>_Tp<span class="token punctuation">,</span> _Alloc<span class="token operator">></span> <span class="token operator">&amp;</span>__y<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token operator">!</span><span class="token punctuation">(</span>__x <span class="token operator">==</span> __y<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token comment" spellcheck="true">/// Based on operator&lt;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _Tp<span class="token punctuation">,</span> <span class="token keyword">typename</span> _Alloc<span class="token operator">></span><span class="token keyword">inline</span> <span class="token keyword">bool</span><span class="token keyword">operator</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">const</span> list<span class="token operator">&lt;</span>_Tp<span class="token punctuation">,</span> _Alloc<span class="token operator">></span> <span class="token operator">&amp;</span>__x<span class="token punctuation">,</span> <span class="token keyword">const</span> list<span class="token operator">&lt;</span>_Tp<span class="token punctuation">,</span> _Alloc<span class="token operator">></span> <span class="token operator">&amp;</span>__y<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> __y <span class="token operator">&lt;</span> __x<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token comment" spellcheck="true">/// Based on operator&lt;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _Tp<span class="token punctuation">,</span> <span class="token keyword">typename</span> _Alloc<span class="token operator">></span><span class="token keyword">inline</span> <span class="token keyword">bool</span><span class="token keyword">operator</span><span class="token operator">&lt;=</span><span class="token punctuation">(</span><span class="token keyword">const</span> list<span class="token operator">&lt;</span>_Tp<span class="token punctuation">,</span> _Alloc<span class="token operator">></span> <span class="token operator">&amp;</span>__x<span class="token punctuation">,</span> <span class="token keyword">const</span> list<span class="token operator">&lt;</span>_Tp<span class="token punctuation">,</span> _Alloc<span class="token operator">></span> <span class="token operator">&amp;</span>__y<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token operator">!</span><span class="token punctuation">(</span>__y <span class="token operator">&lt;</span> __x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token comment" spellcheck="true">/// Based on operator&lt;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _Tp<span class="token punctuation">,</span> <span class="token keyword">typename</span> _Alloc<span class="token operator">></span><span class="token keyword">inline</span> <span class="token keyword">bool</span><span class="token keyword">operator</span><span class="token operator">>=</span><span class="token punctuation">(</span><span class="token keyword">const</span> list<span class="token operator">&lt;</span>_Tp<span class="token punctuation">,</span> _Alloc<span class="token operator">></span> <span class="token operator">&amp;</span>__x<span class="token punctuation">,</span> <span class="token keyword">const</span> list<span class="token operator">&lt;</span>_Tp<span class="token punctuation">,</span> _Alloc<span class="token operator">></span> <span class="token operator">&amp;</span>__y<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token operator">!</span><span class="token punctuation">(</span>__x <span class="token operator">&lt;</span> __y<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre><h3 id="1-2-list基类源码"><a href="#1-2-list基类源码" class="headerlink" title="1.2 list基类源码"></a>1.2 list基类源码</h3><p><code>_list_base</code>中有一个结构体:<code>_List_impl</code>,而<code>_List_impl</code>中有一个<code>List_node_base</code>。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">_List_base</span><span class="token punctuation">{</span><span class="token keyword">protected</span><span class="token operator">:</span>  <span class="token keyword">typedef</span> <span class="token keyword">typename</span> _Alloc<span class="token operator">::</span><span class="token keyword">template</span> rebind<span class="token operator">&lt;</span>_List_node<span class="token operator">&lt;</span>_Tp<span class="token operator">></span> <span class="token operator">></span><span class="token operator">::</span>other    _Node_alloc_type<span class="token punctuation">;</span>  <span class="token keyword">typedef</span> <span class="token keyword">typename</span> _Alloc<span class="token operator">::</span><span class="token keyword">template</span> rebind<span class="token operator">&lt;</span>_Tp<span class="token operator">></span><span class="token operator">::</span>other _Tp_alloc_type<span class="token punctuation">;</span>  <span class="token keyword">struct</span> _List_impl  <span class="token operator">:</span> <span class="token keyword">public</span> _Node_alloc_type  <span class="token punctuation">{</span>    __detail<span class="token operator">::</span>_List_node_base _M_node<span class="token punctuation">;</span>    <span class="token function">_List_impl</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token operator">:</span> <span class="token function">_Node_alloc_type</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">_M_node</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span> <span class="token punctuation">}</span>    <span class="token function">_List_impl</span><span class="token punctuation">(</span><span class="token keyword">const</span> _Node_alloc_type<span class="token operator">&amp;</span> __a<span class="token punctuation">)</span> _GLIBCXX_NOEXCEPT    <span class="token operator">:</span> <span class="token function">_Node_alloc_type</span><span class="token punctuation">(</span>__a<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">_M_node</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span> <span class="token punctuation">}</span>    <span class="token macro property">#<span class="token directive keyword">if</span> __cplusplus >= 201103L</span>    <span class="token function">_List_impl</span><span class="token punctuation">(</span>_Node_alloc_type<span class="token operator">&amp;&amp;</span> __a<span class="token punctuation">)</span> _GLIBCXX_NOEXCEPT    <span class="token operator">:</span> <span class="token function">_Node_alloc_type</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>__a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">_M_node</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span> <span class="token punctuation">}</span>    <span class="token macro property">#<span class="token directive keyword">endif</span></span>  <span class="token punctuation">}</span><span class="token punctuation">;</span>  _List_impl _M_impl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>最后形成的图就是:</p><p><img src="https://raw.githubusercontent.com/Light-City/cloudimg/master/list_iterator_design.png" alt="list's iterator_design"></p><p>所以如果求:</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">sizeof</span><span class="token punctuation">(</span>list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token number">16</span></code></pre><p>原因是:</p><p><code>list</code>的sizeof为1,所以sizeof来源于基类<code>_list_base</code>,而<code>_list_base</code>中有一个结构体:<code>_List_impl</code>,而<code>_List_impl</code>中有一个<code>_List_node_base</code>.</p><p>我们知道<code>_List_node_base</code>,里面有两个指针,在64位上,每个为8字节,共16字节。</p><h2 id="2-list’s-Iterator剖析"><a href="#2-list’s-Iterator剖析" class="headerlink" title="2.list’s Iterator剖析"></a>2.list’s Iterator剖析</h2><h3 id="2-1-iterator"><a href="#2-1-iterator" class="headerlink" title="2.1 iterator"></a>2.1 iterator</h3><p>list的iterator定义</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _Tp<span class="token operator">></span><span class="token keyword">struct</span> _List_iterator<span class="token punctuation">{</span>  <span class="token keyword">typedef</span> _List_iterator<span class="token operator">&lt;</span>_Tp<span class="token operator">></span>                _Self<span class="token punctuation">;</span>  <span class="token keyword">typedef</span> _List_node<span class="token operator">&lt;</span>_Tp<span class="token operator">></span>                    _Node<span class="token punctuation">;</span>  <span class="token keyword">typedef</span> ptrdiff_t                          difference_type<span class="token punctuation">;</span>  <span class="token keyword">typedef</span> std<span class="token operator">::</span>bidirectional_iterator_tag    iterator_category<span class="token punctuation">;</span>  <span class="token keyword">typedef</span> _Tp                                value_type<span class="token punctuation">;</span>  <span class="token keyword">typedef</span> _Tp<span class="token operator">*</span>                               pointer<span class="token punctuation">;</span>  <span class="token keyword">typedef</span> _Tp<span class="token operator">&amp;</span>                               reference<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// The only member points to the %list element.</span>   __detail<span class="token operator">::</span>_List_node_base<span class="token operator">*</span> _M_node<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//  _List_node(节点的数据部分) -> _List_node_base(前指针与后指针)</span>  <span class="token function">_List_iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> _GLIBCXX_NOEXCEPT  <span class="token operator">:</span> <span class="token function">_M_node</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>  <span class="token keyword">explicit</span>  <span class="token function">_List_iterator</span><span class="token punctuation">(</span>__detail<span class="token operator">::</span>_List_node_base<span class="token operator">*</span> __x<span class="token punctuation">)</span> _GLIBCXX_NOEXCEPT  <span class="token operator">:</span> <span class="token function">_M_node</span><span class="token punctuation">(</span>__x<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>  _Self  <span class="token function">_M_const_cast</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> _GLIBCXX_NOEXCEPT  <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// The only member points to the %list element.</span>  __detail<span class="token operator">::</span>_List_node_base<span class="token operator">*</span> _M_node<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>内部重载函数:</p><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// Must downcast from _List_node_base to _List_node to get to _M_data.</span><span class="token comment" spellcheck="true">// 重载*操作符</span>reference <span class="token keyword">operator</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> _GLIBCXX_NOEXCEPT<span class="token punctuation">{</span>     <span class="token keyword">return</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span>_Node<span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">(</span>_M_node<span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span>_M_data<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 重载->操作符</span>pointer <span class="token keyword">operator</span><span class="token operator">-</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> _GLIBCXX_NOEXCEPT<span class="token punctuation">{</span>     <span class="token keyword">return</span> std<span class="token operator">::</span><span class="token function">__addressof</span><span class="token punctuation">(</span><span class="token keyword">static_cast</span><span class="token operator">&lt;</span>_Node<span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">(</span>_M_node<span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span>_M_data<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 重载前置++操作符  ++i</span>_Self<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">++</span><span class="token punctuation">(</span><span class="token punctuation">)</span> _GLIBCXX_NOEXCEPT   <span class="token punctuation">{</span>     _M_node <span class="token operator">=</span> _M_node<span class="token operator">-</span><span class="token operator">></span>_M_next<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 重载后置++操作符 i++</span>_Self <span class="token keyword">operator</span><span class="token operator">++</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> _GLIBCXX_NOEXCEPT<span class="token punctuation">{</span>    _Self __tmp <span class="token operator">=</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">// 记录原值  *调用的是拷贝构造函数</span>    _M_node <span class="token operator">=</span> _M_node<span class="token operator">-</span><span class="token operator">></span>_M_next<span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 进行操作</span>    <span class="token keyword">return</span> __tmp<span class="token punctuation">;</span>                     <span class="token comment" spellcheck="true">// 返回原值</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 重载前置--操作符  --i</span>_Self<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">--</span><span class="token punctuation">(</span><span class="token punctuation">)</span> _GLIBCXX_NOEXCEPT<span class="token punctuation">{</span>    _M_node <span class="token operator">=</span> _M_node<span class="token operator">-</span><span class="token operator">></span>_M_prev<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 重载后置--操作符  --i</span>_Self <span class="token keyword">operator</span><span class="token operator">--</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> _GLIBCXX_NOEXCEPT<span class="token punctuation">{</span>    _Self __tmp <span class="token operator">=</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>    _M_node <span class="token operator">=</span> _M_node<span class="token operator">-</span><span class="token operator">></span>_M_prev<span class="token punctuation">;</span>    <span class="token keyword">return</span> __tmp<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 重载++操作符</span><span class="token keyword">bool</span> <span class="token keyword">operator</span><span class="token operator">==</span><span class="token punctuation">(</span><span class="token keyword">const</span> _Self<span class="token operator">&amp;</span> __x<span class="token punctuation">)</span> <span class="token keyword">const</span> _GLIBCXX_NOEXCEPT<span class="token punctuation">{</span>     <span class="token keyword">return</span> _M_node <span class="token operator">==</span> __x<span class="token punctuation">.</span>_M_node<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 重载!=操作符</span><span class="token keyword">bool</span> <span class="token keyword">operator</span><span class="token operator">!=</span><span class="token punctuation">(</span><span class="token keyword">const</span> _Self<span class="token operator">&amp;</span> __x<span class="token punctuation">)</span> <span class="token keyword">const</span> _GLIBCXX_NOEXCEPT<span class="token punctuation">{</span>     <span class="token keyword">return</span> _M_node <span class="token operator">!=</span> __x<span class="token punctuation">.</span>_M_node<span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre><h3 id="2-2-结点设计"><a href="#2-2-结点设计" class="headerlink" title="2.2 结点设计"></a>2.2 结点设计</h3><p>iterator内部的<code>_List_node</code>,这里可以得到继承自<code>_List_node_base</code>.</p><p><code>_List_node</code>放数据部分</p><p><code>_List_node_base</code>放前后指针</p><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">/// An actual node in the %list.</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _Tp<span class="token operator">></span><span class="token keyword">struct</span> _List_node <span class="token operator">:</span> <span class="token keyword">public</span> __detail<span class="token operator">::</span>_List_node_base<span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">///&lt; User's data.</span>  _Tp _M_data<span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">if</span> __cplusplus >= 201103L</span>  <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> _Args<span class="token operator">></span>    <span class="token function">_List_node</span><span class="token punctuation">(</span>_Args<span class="token operator">&amp;&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> __args<span class="token punctuation">)</span><span class="token operator">:</span> __detail<span class="token operator">::</span><span class="token function">_List_node_base</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">_M_data</span><span class="token punctuation">(</span>std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>_Args<span class="token operator">></span><span class="token punctuation">(</span>__args<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span>     <span class="token punctuation">{</span> <span class="token punctuation">}</span><span class="token macro property">#<span class="token directive keyword">endif</span></span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p><code>_List_node_base</code>代码:</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">namespace</span> __detail<span class="token punctuation">{</span>    _GLIBCXX_BEGIN_NAMESPACE_VERSION    <span class="token comment" spellcheck="true">/// Common part of a node in the %list. </span>    <span class="token keyword">struct</span> _List_node_base    <span class="token punctuation">{</span>      _List_node_base<span class="token operator">*</span> _M_next<span class="token punctuation">;</span>      _List_node_base<span class="token operator">*</span> _M_prev<span class="token punctuation">;</span>      <span class="token keyword">static</span> <span class="token keyword">void</span>      <span class="token function">swap</span><span class="token punctuation">(</span>_List_node_base<span class="token operator">&amp;</span> __x<span class="token punctuation">,</span> _List_node_base<span class="token operator">&amp;</span> __y<span class="token punctuation">)</span> _GLIBCXX_USE_NOEXCEPT<span class="token punctuation">;</span>      <span class="token keyword">void</span>      <span class="token function">_M_transfer</span><span class="token punctuation">(</span>_List_node_base<span class="token operator">*</span> <span class="token keyword">const</span> __first<span class="token punctuation">,</span>          _List_node_base<span class="token operator">*</span> <span class="token keyword">const</span> __last<span class="token punctuation">)</span> _GLIBCXX_USE_NOEXCEPT<span class="token punctuation">;</span>      <span class="token keyword">void</span>      <span class="token function">_M_reverse</span><span class="token punctuation">(</span><span class="token punctuation">)</span> _GLIBCXX_USE_NOEXCEPT<span class="token punctuation">;</span>      <span class="token keyword">void</span>      <span class="token function">_M_hook</span><span class="token punctuation">(</span>_List_node_base<span class="token operator">*</span> <span class="token keyword">const</span> __position<span class="token punctuation">)</span> _GLIBCXX_USE_NOEXCEPT<span class="token punctuation">;</span>      <span class="token keyword">void</span>      <span class="token function">_M_unhook</span><span class="token punctuation">(</span><span class="token punctuation">)</span> _GLIBCXX_USE_NOEXCEPT<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    _GLIBCXX_END_NAMESPACE_VERSION<span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// namespace detail</span></code></pre><p>迭代器在设计的时候,总是保持前闭后开原则,例如iter-&gt;begin()指向第一个元素,iter-&gt;end()指向实际最后一个元素的下一个元素,故最后的设计刻意在环形list尾部加一个空白结点,用以符合STL前闭后开原则.</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> STL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C/C++多线程编程基础</title>
      <link href="/2019/09/24/duo-jin-cheng-yu-duo-xian-cheng-ji-chu/"/>
      <url>/2019/09/24/duo-jin-cheng-yu-duo-xian-cheng-ji-chu/</url>
      
        <content type="html"><![CDATA[<h1 id="C-C-多线程编程基础"><a href="#C-C-多线程编程基础" class="headerlink" title="C/C++多线程编程基础"></a>C/C++多线程编程基础</h1><h2 id="1-基础问题"><a href="#1-基础问题" class="headerlink" title="1.基础问题"></a>1.基础问题</h2><ul><li><strong>某个线程崩溃，会导致进程退出吗?或者说进程中某个线程崩溃，是否会对其他线程造成影响？</strong></li></ul><p>答：一般来说，每个线程都是独立执行的单位，每个线程都有自己的上下文堆栈，一个线程的的崩溃不会对其他线程造成影响。但是通常情况下，一个线程崩溃会产生一个进程内的错误，例如，在 Linux 操作系统中，可能会产生一个 <strong>Segment Fault</strong> 错误，这个错误会产生一个信号，操作系统默认对这个信号的处理就是结束进程，整个进程都被销毁了，这样的话这个进程中存在的其他线程自然也就不存在了。</p><ul><li><strong>排查 Linux 进程 CPU 使用率过高问题？</strong></li></ul><p>在实际开发中，有时候由于我们的程序逻辑不当问题，会导致某个线程<strong>空转</strong>（如无限空循环），进而引起该进程占用 CPU 使用率过高。这不仅会造成我们的系统卡顿，也是对 CPU 资源的一种浪费。那如何定位和排查引起 CPU 使用率过高的线程呢？</p><p>在 Linux 下我们可以综合使用 pstack 和 top 命令来排查此类问题。</p><h2 id="2-基础命令"><a href="#2-基础命令" class="headerlink" title="2.基础命令"></a>2.基础命令</h2><ul><li>pstack</li></ul><p>Linux 系统中可以通过 <strong>pstack</strong> 来命令查看一个进程的线程数量和每个线程的调用堆栈情况。</p><pre><code>pstack pid</code></pre><p><strong>pid</strong> 设置为要查看的进程的 id 即可。</p><ul><li>top</li></ul><p>可以查看cpu高的进程，找到占用cpu最大的进程号，然后使用：</p><pre><code>top -p pid</code></pre><p>观察指定pid的CPU和内存以及负载情况。</p><p>现在有如下信息：</p><pre><code>top - 19:30:05 up  6:15,  1 user,  load average: 0.85, 0.71, 0.61Tasks:   1 total,   0 running,   1 sleeping,   0 stopped,   0 zombie%Cpu(s):  8.1 us,  2.9 sy,  0.0 ni, 87.8 id,  0.0 wa,  0.0 hi,  1.1 si,  0.0 stKiB Mem : 20412976 total, 10960136 free,  5416592 used,  4036248 buff/cacheKiB Swap:  2097148 total,  2097148 free,        0 used. 14315608 avail Mem </code></pre><p><strong>第一行是任务队列信息</strong></p><table><thead><tr><th align="center">任务队列信息</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">9:30:05</td><td align="center">当前时间</td></tr><tr><td align="center">6:15 min</td><td align="center">用户在线时间</td></tr><tr><td align="center">1users</td><td align="center">在线用户数</td></tr><tr><td align="center">load average: 0.85, 0.71, 0.61</td><td align="center">系统负载，即任务队列的平均长度。1分钟前、5分钟前、15分钟前平均负载</td></tr></tbody></table><p><strong>第二行为进程的信息</strong></p><table><thead><tr><th align="center">进程信息</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">Tasks: 1 total</td><td align="center">进程总数</td></tr><tr><td align="center">0 running</td><td align="center">正在运行的进程数</td></tr><tr><td align="center">1 sleeping</td><td align="center">睡眠的进程数</td></tr><tr><td align="center">0 stopped</td><td align="center">停止的进程数</td></tr><tr><td align="center">0 zombie</td><td align="center">僵尸进程数</td></tr></tbody></table><p><strong>第三行为cpu信息</strong></p><table><thead><tr><th align="center">cpu信息</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">8.1 us</td><td align="center">用户空间占用CPU百分比</td></tr><tr><td align="center">2.9% sy</td><td align="center">内核空间占用CPU百分比</td></tr><tr><td align="center">0.0% ni</td><td align="center">用户进程空间内改变过优先级的进程占用CPU百分比</td></tr><tr><td align="center">87.8% id</td><td align="center">空闲CPU百分比</td></tr><tr><td align="center">0.0% wa</td><td align="center">等待输入输出的CPU时间百分比</td></tr><tr><td align="center">0.0% hi</td><td align="center">硬件中断</td></tr><tr><td align="center">1.1% si</td><td align="center">软件中断</td></tr><tr><td align="center">0.0%st</td><td align="center">实时</td></tr></tbody></table><p><strong>第四、五行为内存信息。</strong></p><table><thead><tr><th align="center">物理内存信息</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">Mem: 20412976 total</td><td align="center">物理内存总量</td></tr><tr><td align="center">5416592 used</td><td align="center">使用的物理内存总量</td></tr><tr><td align="center">10960136 free</td><td align="center">空闲内存总量</td></tr><tr><td align="center">4036248 buffers/cache</td><td align="center">用作内核缓存的内存量</td></tr></tbody></table><table><thead><tr><th align="center">交换区信息</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">Swap: 2097148 total</td><td align="center">交换区总量</td></tr><tr><td align="center">0k used</td><td align="center">使用的交换区总量</td></tr><tr><td align="center">2097148 free</td><td align="center">空闲交换区总量</td></tr><tr><td align="center">14315608 cached</td><td align="center">缓冲的交换区总量</td></tr></tbody></table><p>那如何通过top命令定位问题进程中每个线程占用cpu情况？</p><p>使用<code>-H</code>,top 命令的 -H 选项的作用是显示每个一个进程的各个线程运行状态（线程模式）。</p><p>例如：</p><pre><code>top -p 2085 -H</code></pre><p><img src="https://raw.githubusercontent.com/Light-City/cloudimg/master/top.png" alt=""></p><p>由上图明显可以发现，线程PID 2085 CPU占用率最高，接下来定位该线程的代码是否出现异常导致cpu占用过高。</p><p>结合上述的pstack，例如：</p><pre><code>pstack 2085</code></pre><p>在 pstack 输出的各个线程中，只要逐一对照我们的程序源码来梳理下该线程中是否有大多数时间都处于空转的逻辑，然后修改和优化这些逻辑就可以解决 CPU 使用率过高的问题了，一般情况下，不工作的线程应尽量使用锁对象让其挂起，而不是空转，这样可以提高系统资源利用率。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> C </category>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 项目之Googletest单元测试</title>
      <link href="/2019/09/17/googletest-1/"/>
      <url>/2019/09/17/googletest-1/</url>
      
        <content type="html"><![CDATA[<h1 id="C-项目之Googletest单元测试"><a href="#C-项目之Googletest单元测试" class="headerlink" title="C++ 项目之Googletest单元测试"></a>C++ 项目之Googletest单元测试</h1><h2 id="1-Clion集成Googletest单元测试"><a href="#1-Clion集成Googletest单元测试" class="headerlink" title="1.Clion集成Googletest单元测试"></a>1.Clion集成Googletest单元测试</h2><p>Googletest - Google Testing and Mocking Framework</p><p>源码下载地址:</p><blockquote><p><a href="https://github.com/google/googletest/releases" target="_blank" rel="noopener">https://github.com/google/googletest/releases</a></p></blockquote><p>Googletest中包含两个模块,分别是gtest与gmock,需要分别源码编译,编译完后,到指定目录去拷贝includes文件夹与.so文件到下面路径的指定位置.</p><p>然后项目中创建ext目录,里面分为两块</p><ul><li>第一块:includes</li></ul><p>包含gmock与gtest的include文件,对应于gcc -I参数,头文件路径,包含以.h结尾的头文件</p><ul><li>第二块:libs</li></ul><p>包含gmock与gtest的libs文件,对应gcc -L参数,库文件路径,里面包含的是一些.so或.dll等动态或静态链接库</p><pre class=" language-cpp"><code class="language-cpp">├── ext│   ├── includes│   │   ├── gmock│   │   └── gtest│   └── libs│       ├── gmock│       └── gtest</code></pre><p>上述本地项目路径配置好后,在CmakeLists.txt中进行配置:</p><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property"># ext</span><span class="token function">set</span><span class="token punctuation">(</span>BASE_INCLUDES ext<span class="token operator">/</span>includes<span class="token punctuation">)</span><span class="token function">set</span><span class="token punctuation">(</span>BASE_LIBS ext<span class="token operator">/</span>libs<span class="token punctuation">)</span><span class="token macro property"># googletest</span><span class="token function">set</span><span class="token punctuation">(</span>GTEST_INCLUDE_DIR $<span class="token punctuation">{</span>BASE_INCLUDES<span class="token punctuation">}</span><span class="token operator">/</span>gtest<span class="token operator">/</span>include<span class="token punctuation">)</span><span class="token function">set</span><span class="token punctuation">(</span>GMOCK_INCLUDE_DIR $<span class="token punctuation">{</span>BASE_INCLUDES<span class="token punctuation">}</span><span class="token operator">/</span>gmock<span class="token operator">/</span>include<span class="token punctuation">)</span><span class="token function">set</span><span class="token punctuation">(</span>GTEST_LINK_DIR $<span class="token punctuation">{</span>BASE_LIBS<span class="token punctuation">}</span><span class="token operator">/</span>gtest<span class="token operator">/</span>lib<span class="token operator">/</span><span class="token punctuation">)</span><span class="token function">set</span><span class="token punctuation">(</span>GMOCK_LINK_DIR $<span class="token punctuation">{</span>BASE_LIBS<span class="token punctuation">}</span><span class="token operator">/</span>gmock<span class="token operator">/</span>lib<span class="token operator">/</span><span class="token punctuation">)</span># 去哪里找头文件 相当于gcc<span class="token operator">/</span>clang 中的<span class="token operator">-</span><span class="token function">I</span><span class="token punctuation">(</span>i的大写字母<span class="token punctuation">)</span>参数<span class="token function">include_directories</span><span class="token punctuation">(</span>$<span class="token punctuation">{</span>GTEST_INCLUDE_DIR<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token function">include_directories</span><span class="token punctuation">(</span>$<span class="token punctuation">{</span>GMOCK_INCLUDE_DIR<span class="token punctuation">}</span><span class="token punctuation">)</span># 去哪里找库文件 <span class="token punctuation">.</span>so <span class="token punctuation">.</span>dll <span class="token punctuation">.</span>dylib 相当于gcc 中的<span class="token operator">-</span>L参数<span class="token function">link_directories</span><span class="token punctuation">(</span>$<span class="token punctuation">{</span>GTEST_LINK_DIR<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token function">link_directories</span><span class="token punctuation">(</span>$<span class="token punctuation">{</span>GMOCK_LINK_DIR<span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p>然后为每个test配上链接库即可.</p><p>例如,现在有个测试file,文件名为:了l1.cpp</p><p>那么在CmakeLists.txt中配置为:</p><pre class=" language-cpp"><code class="language-cpp"><span class="token function">add_executable</span><span class="token punctuation">(</span>l1 l1<span class="token punctuation">.</span>cpp<span class="token punctuation">)</span><span class="token function">target_link_libraries</span><span class="token punctuation">(</span>l1 gtest gtest_main<span class="token punctuation">)</span>  </code></pre><h2 id="2-gtest之Helloworld"><a href="#2-gtest之Helloworld" class="headerlink" title="2.gtest之Helloworld"></a>2.gtest之Helloworld</h2><pre><code>int main(int argc, char* argv[]){    // 接收命令行参数    testing::InitGoogleTest(&amp;argc, argv);    vector&lt;int&gt; x={1,2,3,5};    // EXPECT_EQ使用    for (int i = 0; i &lt; x.size(); ++i)    {        EXPECT_EQ(x[i], 1) &lt;&lt; "Vectors x and y differ at index " &lt;&lt; i;    }    RUN_ALL_TESTS();    return 0;}</code></pre><p>例如上述就是个完整的例子,每次运行:</p><pre><code>testing::InitGoogleTest(&amp;argc, argv);</code></pre><p>然后使用:</p><pre><code>RUN_ALL_TESTS();</code></pre><p>运行所有的Test,每个Test编写参考后面断言.</p><p>我们看看运行效果:</p><pre class=" language-cpp"><code class="language-cpp">l1<span class="token punctuation">.</span>cpp<span class="token operator">:</span><span class="token number">113</span><span class="token operator">:</span> FailureExpected equality of these values<span class="token operator">:</span>  x<span class="token punctuation">[</span>i<span class="token punctuation">]</span>    Which is<span class="token operator">:</span> <span class="token number">2</span>  <span class="token number">1</span>Vectors x <span class="token operator">and</span> y differ at index <span class="token number">1</span>l1<span class="token punctuation">.</span>cpp<span class="token operator">:</span><span class="token number">113</span><span class="token operator">:</span> FailureExpected equality of these values<span class="token operator">:</span>  x<span class="token punctuation">[</span>i<span class="token punctuation">]</span>    Which is<span class="token operator">:</span> <span class="token number">3</span>  <span class="token number">1</span>Vectors x <span class="token operator">and</span> y differ at index <span class="token number">2</span>l1<span class="token punctuation">.</span>cpp<span class="token operator">:</span><span class="token number">113</span><span class="token operator">:</span> FailureExpected equality of these values<span class="token operator">:</span>  x<span class="token punctuation">[</span>i<span class="token punctuation">]</span>    Which is<span class="token operator">:</span> <span class="token number">5</span>  <span class="token number">1</span>Vectors x <span class="token operator">and</span> y differ at index <span class="token number">3</span><span class="token punctuation">[</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token punctuation">]</span> Running <span class="token number">0</span> tests from <span class="token number">0</span> test cases<span class="token punctuation">.</span><span class="token punctuation">[</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token punctuation">]</span> <span class="token number">0</span> tests from <span class="token number">0</span> test cases ran<span class="token punctuation">.</span> <span class="token punctuation">(</span><span class="token number">0</span> ms total<span class="token punctuation">)</span><span class="token punctuation">[</span>  PASSED  <span class="token punctuation">]</span> <span class="token number">0</span> tests<span class="token punctuation">.</span><span class="token punctuation">[</span>  FAILED  <span class="token punctuation">]</span> <span class="token number">0</span> tests<span class="token punctuation">,</span> listed below<span class="token operator">:</span> <span class="token number">0</span> FAILED TESTS</code></pre><h2 id="2-gtest初识之断言"><a href="#2-gtest初识之断言" class="headerlink" title="2.gtest初识之断言"></a>2.gtest初识之断言</h2><p>关于断言Google包装了一系列<code>EXPECT</code>和<code>ASSERT</code>的宏，而EXPECT系列和ASSERT系列的区别是：</p><ul><li><code>EXPECT</code>  失败时，案例继续往下执行。</li><li><code>ASSERT</code> 失败时，直接在当前函数中返回，当前函数中<code>ASSERT</code>后面的语句将不会执行。</li></ul><p>例如:</p><pre class=" language-cpp"><code class="language-cpp"><span class="token function">TEST</span><span class="token punctuation">(</span>ASSERTTest<span class="token punctuation">,</span> ASSERT_VS_EXPECT<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">ASSERT_TRUE</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token operator">&lt;</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// ASSERT失败,直接在当前函数中返回,后面语句不执行</span>    <span class="token function">ASSERT_FALSE</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token operator">&lt;</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">EXPECT_EQ</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span> <span class="token function">Foo</span><span class="token punctuation">(</span><span class="token number">310</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>每个Test是个宏,Test底层源码如下:</p><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property"># <span class="token directive keyword">define</span> TEST(test_case_name, test_name) GTEST_TEST(test_case_name, test_name)</span></code></pre><p>对应test_case名与test名.</p><p>上述代码中10&lt;2为False,而使用了<code>ASSERT_TRUE</code>,该Test后面所有内容就不会执行,如果换成<code>EXPECT_TRUE</code>则正常运行!</p><blockquote><p> 布尔值检查</p></blockquote><table><thead><tr><th><strong>Fatal assertion</strong></th><th><strong>Nonfatal assertion</strong></th><th><strong>Verifies</strong></th></tr></thead><tbody><tr><td><code>ASSERT_TRUE(</code><em>condition</em><code>)</code>;</td><td><code>EXPECT_TRUE(</code><em>condition</em><code>)</code>;</td><td><em>condition</em> is true</td></tr><tr><td><code>ASSERT_FALSE(</code><em>condition</em><code>)</code>;</td><td><code>EXPECT_FALSE(</code><em>condition</em><code>)</code>;</td><td><em>condition</em> is false</td></tr></tbody></table><blockquote><p>数值型数据检查</p></blockquote><table><thead><tr><th><strong>Fatal assertion</strong></th><th><strong>Nonfatal assertion</strong></th><th><strong>Verifies</strong></th></tr></thead><tbody><tr><td><code>ASSERT_EQ(</code><em>expected</em><code>,</code><em>actual</em><code>);</code></td><td><code>EXPECT_EQ(</code><em>expected</em><code>,</code><em>actual</em><code>);</code></td><td><em>expected</em> <code>==</code> <em>actual</em></td></tr><tr><td><code>ASSERT_NE(</code><em>val1</em><code>,</code><em>val2</em><code>);</code></td><td><code>EXPECT_NE(</code><em>val1</em><code>,</code><em>val2</em><code>);</code></td><td><em>val1</em> <code>!=</code> <em>val2</em></td></tr><tr><td><code>ASSERT_LT(</code><em>val1</em><code>,</code><em>val2</em><code>);</code></td><td><code>EXPECT_LT(</code><em>val1</em><code>,</code><em>val2</em><code>);</code></td><td><em>val1</em> <code>&lt;</code> <em>val2</em></td></tr><tr><td><code>ASSERT_LE(</code><em>val1</em><code>,</code><em>val2</em><code>);</code></td><td><code>EXPECT_LE(</code><em>val1</em><code>,</code><em>val2</em><code>);</code></td><td><em>val1</em> <code>&lt;=</code> <em>val2</em></td></tr><tr><td><code>ASSERT_GT(</code><em>val1</em><code>,</code><em>val2</em><code>);</code></td><td><code>EXPECT_GT(</code><em>val1</em><code>,</code><em>val2</em><code>);</code></td><td><em>val1</em> <code>&gt;</code> <em>val2</em></td></tr><tr><td><code>ASSERT_GE(</code><em>val1</em><code>,</code><em>val2</em><code>);</code></td><td><code>EXPECT_GE(</code><em>val1</em><code>,</code><em>val2</em><code>);</code></td><td><em>val1</em> <code>&gt;=</code> <em>val2</em></td></tr></tbody></table><blockquote><p>字符串检查</p></blockquote><pre class=" language-cpp"><code class="language-cpp"><span class="token function">TEST</span><span class="token punctuation">(</span>StringCmpTest<span class="token punctuation">,</span> Demo<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">char</span><span class="token operator">*</span> pszCoderZh <span class="token operator">=</span> <span class="token string">"CoderZh"</span><span class="token punctuation">;</span>    <span class="token keyword">wchar_t</span><span class="token operator">*</span> wszCoderZh <span class="token operator">=</span> L<span class="token string">"CoderZh"</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>string strCoderZh <span class="token operator">=</span> <span class="token string">"CoderZh"</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>wstring wstrCoderZh <span class="token operator">=</span> L<span class="token string">"CoderZh"</span><span class="token punctuation">;</span>    <span class="token function">EXPECT_STREQ</span><span class="token punctuation">(</span><span class="token string">"CoderZh"</span><span class="token punctuation">,</span> pszCoderZh<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">EXPECT_STREQ</span><span class="token punctuation">(</span>L<span class="token string">"CoderZh"</span><span class="token punctuation">,</span> wszCoderZh<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">EXPECT_STRNE</span><span class="token punctuation">(</span><span class="token string">"CnBlogs"</span><span class="token punctuation">,</span> pszCoderZh<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">EXPECT_STRNE</span><span class="token punctuation">(</span>L<span class="token string">"CnBlogs"</span><span class="token punctuation">,</span> wszCoderZh<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">EXPECT_STRCASEEQ</span><span class="token punctuation">(</span><span class="token string">"coderzh"</span><span class="token punctuation">,</span> pszCoderZh<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//EXPECT_STRCASEEQ(L"coderzh", wszCoderZh);    不支持</span>    <span class="token function">EXPECT_STREQ</span><span class="token punctuation">(</span><span class="token string">"CoderZh"</span><span class="token punctuation">,</span> strCoderZh<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">EXPECT_STREQ</span><span class="token punctuation">(</span>L<span class="token string">"CoderZh"</span><span class="token punctuation">,</span> wstrCoderZh<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>其中STREQ和STRNE同时支持char<em>和wchar_t</em>类型的，<em>STRCASEEQ</em>和<em>STRCASENE</em>却只接收<code>char*</code></p><blockquote><p>显示返回成功或失败</p></blockquote><p>直接返回成功：<code>SUCCEED();</code></p><p>返回失败：</p><table><thead><tr><th><strong>Fatal assertion</strong></th><th><strong>Nonfatal assertion</strong></th></tr></thead><tbody><tr><td><code>FAIL();</code></td><td><code>ADD_FAILURE();</code></td></tr></tbody></table><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 返回成功与否</span><span class="token function">TEST</span><span class="token punctuation">(</span>ExplicitTest<span class="token punctuation">,</span> Demo<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">ADD_FAILURE</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"这行打印失败 Sorry"</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// None Fatal Asserton，继续往下执行。</span>    <span class="token comment" spellcheck="true">//FAIL(); // Fatal Assertion，不往下执行该案例。</span>    <span class="token function">EXPECT_TRUE</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">==</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span><span class="token string">"1==2 failed!"</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 为了验证上述失败后是否执行下面</span>    <span class="token function">SUCCEED</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><blockquote><p>异常检查</p></blockquote><p>分为三个:</p><p><code>EXPECT_NO_THROW(statement);</code>  不抛出异常</p><p><code>EXPECT_ANY_THROW(statement);</code>抛出任意类型异常</p><p><code>EXPECT_THROW(statement, exception_type);</code> 抛出指定类型异常</p><pre class=" language-cpp"><code class="language-cpp"><span class="token function">TEST</span><span class="token punctuation">(</span>ExceptionTest<span class="token punctuation">,</span>et<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 抛出任意类型异常</span>    <span class="token function">EXPECT_ANY_THROW</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token operator">/</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//Expected: 10/0 throws an exception.</span>    <span class="token comment" spellcheck="true">// 抛出指定类型异常</span>    <span class="token function">EXPECT_THROW</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">/</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//Expected: 1/0 throws an exception of type int.</span><span class="token punctuation">}</span></code></pre><blockquote><p>Predicate Assertions</p></blockquote><p>检查一个函数的返回值TRUE还是FALSE时，希望能够输出传入的参数是什么，以便失败后好跟踪</p><p>例如:</p><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 预测断言</span><span class="token keyword">bool</span> <span class="token function">MN</span><span class="token punctuation">(</span><span class="token keyword">int</span> m<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> m<span class="token operator">></span>n<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//检查一个函数的返回值TRUE还是FALSE时，希望能够输出传入的参数是什么，以便失败后好跟踪</span><span class="token function">TEST</span><span class="token punctuation">(</span>PredicateAssertionTest<span class="token punctuation">,</span> Demo<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> m <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">,</span> n <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span>    <span class="token function">EXPECT_PRED2</span><span class="token punctuation">(</span>MN<span class="token punctuation">,</span> m<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//只提供&lt;=5个参数  传递参数要与函数MN对应</span><span class="token punctuation">}</span></code></pre><p>``EXPECT_PRED2(pred2, val1, val2);`ASSERT类似.PRED2可以到PRED5</p><p>最多支持5个参数.</p><blockquote><p>浮点型检查</p></blockquote><p><code>EXPECT_FLOAT_EQ(expected, actual)</code>与<code>EXPECT_DOUBLE_EQ(expected, actual)</code></p><p>ASSERT类似.</p><p>对相近的两个数比较：</p><p><code>EXPECT_NEAR(val1, val2, abs_error);</code></p><p>ASSERT类似.</p><p>例如:</p><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 浮点型</span><span class="token function">TEST</span><span class="token punctuation">(</span>FloatDoubleTest<span class="token punctuation">,</span>Demo<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">ASSERT_DOUBLE_EQ</span><span class="token punctuation">(</span><span class="token number">1.1</span><span class="token punctuation">,</span><span class="token number">1.1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">EXPECT_FLOAT_EQ</span><span class="token punctuation">(</span><span class="token number">1.2</span><span class="token punctuation">,</span><span class="token number">4.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">EXPECT_NEAR</span><span class="token punctuation">(</span><span class="token number">1.234</span><span class="token punctuation">,</span><span class="token number">1.888</span><span class="token punctuation">,</span><span class="token number">0.9</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//    EXPECT_PRED_FORMAT2(testing::FloatLE, val1, val2);</span><span class="token comment" spellcheck="true">//    EXPECT_PRED_FORMAT2(testing::DoubleLE, val1, val2);</span>    <span class="token function">EXPECT_PRED_FORMAT2</span><span class="token punctuation">(</span>testing<span class="token operator">::</span>FloatLE<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// LE表示小于等于 也就是value1&lt;=value2</span>    <span class="token function">EXPECT_PRED_FORMAT2</span><span class="token punctuation">(</span>testing<span class="token operator">::</span>DoubleLE<span class="token punctuation">,</span><span class="token number">0.1</span><span class="token punctuation">,</span><span class="token number">0.2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><blockquote><p>类型检查</p></blockquote><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 类型检查</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">Tt</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        testing<span class="token operator">::</span>StaticAssertTypeEq<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token punctuation">,</span> T<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 与下面调用一致就不报错,否则报错</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token function">TEST</span><span class="token punctuation">(</span>TypeAssertionTest<span class="token punctuation">,</span> Demo<span class="token punctuation">)</span><span class="token punctuation">{</span>    Tt<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span> tt<span class="token punctuation">;</span>    tt<span class="token punctuation">.</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>学习参考自:<a href="https://www.cnblogs.com/coderzh/archive/2009/04/06/1430364.html" target="_blank" rel="noopener">https://www.cnblogs.com/coderzh/archive/2009/04/06/1430364.html</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 单元测试 </category>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> Googletest </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
