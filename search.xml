<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>C++ STL源码剖析之双向环形链表list</title>
      <link href="/2019/10/06/list/"/>
      <url>/2019/10/06/list/</url>
      
        <content type="html"><![CDATA[<h1 id="C-STL源码剖析之双向环形链表list"><a href="#C-STL源码剖析之双向环形链表list" class="headerlink" title="C++ STL源码剖析之双向环形链表list"></a>C++ STL源码剖析之双向环形链表list</h1><h2 id="0-导语"><a href="#0-导语" class="headerlink" title="0. 导语"></a>0. 导语</h2><p>源码对应的版本为<strong>gcc-4.9.1</strong></p><h3 id="1-list"><a href="#1-list" class="headerlink" title="1.list"></a>1.list</h3><p>list为双向环形链表，其结构为：</p><p><img src="http://pxz2lirgn.bkt.clouddn.com/list_1.png" alt=""></p><p>自己绘制的图如下：</p><p><img src="http://pxz2lirgn.bkt.clouddn.com/list_a.png" alt="list_all"></p><p>双向环状链表从节点值为3开始插入，红色框表示最后一个节点(end()指向的节点)。黄色线条表示指向前驱节点，黑色线条表示指向后继节点。</p><h3 id="1-1-list源码"><a href="#1-1-list源码" class="headerlink" title="1.1 list源码"></a>1.1 list源码</h3><h4 id="1-1-1-类结构"><a href="#1-1-1-类结构" class="headerlink" title="1.1.1 类结构"></a>1.1.1 类结构</h4><pre class=" language-c++"><code class="language-c++"> template<typename _Tp, typename _Alloc = std::allocator<_Tp> > class list : protected _List_base<_Tp, _Alloc>  { }</code></pre><p><code>list</code>继承<code>_List_base</code>。</p><h4 id="1-1-2-双向环形链表实现"><a href="#1-1-2-双向环形链表实现" class="headerlink" title="1.1.2 双向环形链表实现"></a>1.1.2 双向环形链表实现</h4><p>【<strong>构造函数</strong>】</p><p><strong>（1）不带任何元素的list</strong></p><pre class=" language-c++"><code class="language-c++">explicitlist(const allocator_type &__a) _GLIBCXX_NOEXCEPT: _Base(_Node_alloc_type(__a)) {}</code></pre><p><strong>（2）带n个元素且赋予初值的list</strong></p><pre class=" language-c++"><code class="language-c++">explicit list(size_type __n, const value_type &__value = value_type(),const allocator_type &__a = allocator_type()) : _Base(_Node_alloc_type(__a)) { _M_fill_initialize(__n, __value); }</code></pre><p><strong>（3）从一个范围中进行初始化list</strong></p><pre class=" language-c++"><code class="language-c++">template<typename _InputIterator>list(_InputIterator __first, _InputIterator __last,     const allocator_type &__a = allocator_type())        : _Base(_Node_alloc_type(__a)) {    // Check whether it's an integral type.  If so, it's not an iterator.    typedef typename std::__is_integer<_InputIterator>::__type _Integral;    _M_initialize_dispatch(__first, __last, _Integral());}</code></pre><p>【<strong>创建节点</strong>】</p><p>做的事情：创建一个新的节点并动态分配内存，返回节点。</p><pre class=" language-c++"><code class="language-c++">_Node *_M_create_node(const value_type &__x) {    _Node *__p = this->_M_get_node();    __try    {        _M_get_Tp_allocator().construct                (std::__addressof(__p->_M_data), __x);    }    __catch(...)    {        _M_put_node(__p);        __throw_exception_again;    }    return __p;}</code></pre><p>注意到里面有两个重要的函数<code>_M_get_node</code>与<code>_M_put_node</code>，我们来查看后发现这些方法来自基类，源码为：</p><pre class=" language-c++"><code class="language-c++">_List_node<_Tp> * _M_get_node() { return _M_impl._Node_alloc_type::allocate(1); }void _M_put_node(_List_node<_Tp> *__p)   _GLIBCXX_NOEXCEPT{ _M_impl._Node_alloc_type::deallocate(__p, 1); }</code></pre><p>对应的就是创建节点动态分配内存，若创建过程中抛出异常，则释放内存。</p><p>【<strong>插入节点</strong>】</p><p>插入节点包括：</p><ul><li>尾部插入n个指定节点值的节点，对应的函数<code>_M_fill_initialize</code></li></ul><p>在list的构造函数中使用：</p><pre class=" language-c++"><code class="language-c++">explicit list(size_type __n, const value_type &__value = value_type(),const allocator_type &__a = allocator_type()) : _Base(_Node_alloc_type(__a)) { _M_fill_initialize(__n, __value); }</code></pre><ul><li>指定位置插入指定节点值的节点，对应的函数<code>_M_insert</code></li></ul><p>其中大家经常使用的<code>push_back</code>与<code>push_front</code>底层就是调用<code>_M_insert</code>函数。</p><p>两者函数区别是：</p><pre class=" language-c++"><code class="language-c++">this->_M_insert(end(), __x);  // push_back   尾部插入  this->_M_insert(begin(), __x); // push_front 头部插入</code></pre><ul><li><strong>双向环形链表插入函数</strong><code>_M_hook</code>   <strong>(最重要！！！)</strong></li></ul><p>像前面提到的<code>push_back</code>、<code>push_front</code>、<code>_M_insert</code>，还有<code>insert</code>都是使用最基础的双向链表插入函数<code>_M_hook</code>实现的。</p><p><strong>下面来深入研究一下：</strong></p><p>其中<code>_M_fill_initialize</code>源码如下：</p><pre class=" language-c++"><code class="language-c++">void _M_fill_initialize(size_type __n, const value_type &__x) {    for (; __n; --__n)        push_back(__x);}</code></pre><p>其中<code>push_back</code>源码如下：</p><pre class=" language-c++"><code class="language-c++">void push_back(const value_type &__x) { this->_M_insert(end(), __x); }</code></pre><p>其中<code>_M_insert</code>，在指定的位置插入初始值为x的节点。</p><pre class=" language-c++"><code class="language-c++">void _M_insert(iterator __position, const value_type &__x) {    _Node *__tmp = _M_create_node(__x);    __tmp->_M_hook(__position._M_node);}</code></pre><p>其中<code>_M_hook</code>实现在<code>gcc-4.9.1/libstdc++-v3/src/c++98/list.cc</code>中,当然<code>_List_node_base</code>的其他函数，例如：<code>_M_unhook</code>也在这个文件中。</p><pre class=" language-c++"><code class="language-c++">// 在指定的位置前插入this指向的节点void_List_node_base::_M_hook(_List_node_base* const __position) _GLIBCXX_USE_NOEXCEPT{  this->_M_next = __position;          this->_M_prev = __position->_M_prev;  __position->_M_prev->_M_next = this;  __position->_M_prev = this;}</code></pre><p>所以上述细分为两个函数：我们把上述代码进行总结：</p><p>（1）在指定的位置插入初始值为x的节点</p><pre class=" language-c++"><code class="language-c++">void _M_insert(iterator __position, const value_type &__x) {    _Node *__tmp = _M_create_node(__x);    __tmp->_M_next = __position;            // 第一步    __tmp->_M_prev = __position->_M_prev;    // 第二步    __position->_M_prev->_M_next = __tmp;    // 第三步    __position->_M_prev = __tmp;            // 第四步}</code></pre><p>这种插入是在指定位置前插入，(对应到代码就是)例如实现在指定<code>__position</code>节点为7前插入节点值9的节点(对应到代码就是__tmp)，下面阐述了具体的插入流程。</p><p><img src="http://pxz2lirgn.bkt.clouddn.com/list_insert.png" alt="list_insert"></p><p>（2）在末尾依次插入n个节点值为x的节点</p><pre class=" language-c++"><code class="language-c++">void _M_fill_initialize(size_type __n, const value_type &__x) {    for (; __n; --__n)        _M_insert(end(), __x);}</code></pre><p>对于上述的代码大家或许会联想到<code>insert</code>,它有三个。<code>insert</code>实现文件在<code>libstdc++-v3/include/bits/list.tcc</code>。</p><ul><li><strong>第一：在指定迭代器之前插入指定元素值节点。</strong></li></ul><p>实现是调用前面的<code>_M_hook</code>函数。</p><pre class=" language-c++"><code class="language-c++">template<typename _Tp, typename _Alloc>typename list<_Tp, _Alloc>::iteratorlist<_Tp, _Alloc>::#if __cplusplus >= 201103Linsert(const_iterator __position, const value_type& __x)#elseinsert(iterator __position, const value_type& __x)#endif{  _Node* __tmp = _M_create_node(__x);  __tmp->_M_hook(__position._M_const_cast()._M_node);  return iterator(__tmp);}</code></pre><ul><li><strong>第二：在指定迭代器之前插入n个指定节点值的节点。</strong></li></ul><pre class=" language-c++"><code class="language-c++">void insert(iterator __position, size_type __n, const value_type &__x) {    list __tmp(__n, __x, get_allocator());    splice(__position, __tmp);}</code></pre><p>实现是先调用list构造函数，完成创建一个拥有n个指定节点值的list。</p><pre class=" language-c++"><code class="language-c++">explicit list(size_type __n, const value_type &__value = value_type(),const allocator_type &__a = allocator_type()) : _Base(_Node_alloc_type(__a)) { _M_fill_initialize(__n, __value); }</code></pre><p>然后使用<code>splice</code>函数完成从另一个list中来插入当前list。</p><pre class=" language-c++"><code class="language-c++">void splice(iterator __position, list &__x){    if (!__x.empty()) {        _M_check_equal_allocators(__x);        this->_M_transfer(__position._M_const_cast(),                          __x.begin(), __x.end());    }}</code></pre><p>其中<code>_M_transfer</code>追踪代码，可以知道：</p><pre class=" language-c++"><code class="language-c++">// Moves the elements from [first,last) before position.void_M_transfer(iterator __position, iterator __first, iterator __last) {    __position._M_node->_M_transfer(__first._M_node, __last._M_node);}</code></pre><p>再次分析得到其来自list的基类<code>_List_node_base</code>，而<code>_M_transfer</code>实现文件在<code>gcc-4.9.1/libstdc++-v3/src/c++98/list.cc</code>中：</p><pre class=" language-c++"><code class="language-c++">void _List_node_base::_M_transfer(_List_node_base * const __first,    _List_node_base * const __last) _GLIBCXX_USE_NOEXCEPT{  if (this != __last)  {      // Remove [first, last) from its old position.      __last->_M_prev->_M_next  = this;      __first->_M_prev->_M_next = __last;      this->_M_prev->_M_next    = __first;      // Splice [first, last) into its new position.      _List_node_base* const __tmp = this->_M_prev;      this->_M_prev                = __last->_M_prev;      __last->_M_prev              = __first->_M_prev;      __first->_M_prev             = __tmp;  }}</code></pre><p>仍然是上述的图：</p><p><img src="http://pxz2lirgn.bkt.clouddn.com/list_a.png" alt="list_all"></p><p>经过前面分析，我们知道<code>splice</code>是将上述图的所代表的整个list插入指定迭代器前面，例如，我们想要在下面两个节点前面插入，具体图形步骤如下：</p><p><code>this</code>代表的节点为值为8的节点，下图描述的就是在节点10与节点8中间插入整个list。</p><p><code>__last</code>代表的是红色框节点，该节点为<code>end()</code>指向的节点，我们是不需要该节点的，所以在后面处理中，会把该节点从整个list中去除掉。</p><p><code>__first</code>代表的是图中节点值为3的节点。</p><p><strong>第一步：先将最后一个有效节点，也就是红色框的前一个节点的next指针指向指定的节点8。</strong></p><p><img src="http://pxz2lirgn.bkt.clouddn.com/step1.png" alt=""></p><p>对应代码为：</p><pre><code>__last-&gt;_M_prev-&gt;_M_next  = this;    </code></pre><p><strong>第二步：<code>_last</code>的next指针指向自己。</strong></p><p><img src="http://pxz2lirgn.bkt.clouddn.com/step2.png" alt=""></p><p>对应的代码为：</p><pre><code>__first-&gt;_M_prev-&gt;_M_next = __last;</code></pre><p><strong>第三步：让指定迭代器之前的节点的nex指向原先list的第一个节点(<code>__first</code>)。</strong></p><p><img src="http://pxz2lirgn.bkt.clouddn.com/step3.png" alt=""></p><p>对应的代码为：</p><pre><code>this-&gt;_M_prev-&gt;_M_next    = __first;</code></pre><p><strong>第四步：保存指定迭代器的前驱节点(对应到哪图中的节点值为10的节点)。</strong></p><pre><code>_List_node_base* const __tmp = this-&gt;_M_prev;</code></pre><p><strong>第五步：指定迭代器的前驱节点指向原list中实际最后一个节点(end()前一节点)。</strong></p><p><img src="http://pxz2lirgn.bkt.clouddn.com/step5.png" alt=""></p><p>对应的代码为：</p><pre><code>this-&gt;_M_prev                = __last-&gt;_M_prev;</code></pre><p><strong>第六步：让原list的最后一个节点(end()指向的节点)的prev指向自己。</strong></p><p><img src="http://pxz2lirgn.bkt.clouddn.com/step6.png" alt=""></p><p>对应的代码为：</p><pre><code>__last-&gt;_M_prev              = __first-&gt;_M_prev;</code></pre><p><strong>第七步：让原list第一个节点的prev指向第四步保存的节点。</strong></p><p><img src="http://pxz2lirgn.bkt.clouddn.com/step7.png" alt=""></p><p>对应的代码为：</p><pre><code>__first-&gt;_M_prev             = __tmp;</code></pre><p>这样经过以上七步操作，完成了在节点8与节点10之前插入一个list。</p><ul><li><strong>第三：从一个list范围把数据插入到指定迭代器前面。</strong></li></ul><pre class=" language-c++"><code class="language-c++">template<typename _InputIterator>voidinsert(iterator __position, _InputIterator __first,       _InputIterator __last) {    list __tmp(__first, __last, get_allocator());    splice(__position, __tmp);}</code></pre><p>原理同上，只不过这个<code>__tmp</code>是调用另外一个构造函数。</p><p>【<strong>删除节点</strong>】</p><ul><li>删除指定节点</li></ul><p>删除指定节点分为两个，第一个通过迭代器删除，第二个是通过元素值删除。</p><p><strong>（1）通过迭代器删除，对应函数为erase</strong></p><p>其中<code>pop_front</code>与<code>pop_back</code>、<code>erase</code>、<code>remove</code>底层实现基于<code>_M_erase</code>函数。</p><pre class=" language-c++"><code class="language-c++">this->_M_erase(begin());     // pop_front 不断删除起点的元素this->_M_erase(iterator(this->_M_impl._M_node._M_prev)); // pop_back移除最后一个元素</code></pre><p>在<code>libstdc++-v3/include/bits/list.tcc</code>中：</p><pre class=" language-c++"><code class="language-c++">erase(iterator __position)#endif{  iterator __ret = iterator(__position._M_node->_M_next);  _M_erase(__position._M_const_cast());  return __ret;}</code></pre><p><strong>（2）通过元素值删除，对应函数为remove</strong></p><p>特殊情况处理，当删除元素的地址与迭代器的地址一样的时候，先保存起来，最后判断保存的迭代器是不是end()，如果不是，就删除掉。底层仍旧是通过<code>_M_erase</code>删除。</p><pre class=" language-c++"><code class="language-c++">template<typename _Tp, typename _Alloc>void list<_Tp, _Alloc>::remove(const value_type& __value){  iterator __first = begin();  iterator __last = end();  iterator __extra = __last;  while (__first != __last)  {      iterator __next = __first;      ++__next;      if (*__first == __value)        {          // _GLIBCXX_RESOLVE_LIB_DEFECTS          // 526. Is it undefined if a function in the standard changes          // in parameters?          if (std::__addressof(*__first) != std::__addressof(__value))        _M_erase(__first);          else        __extra = __first;        }      __first = __next;  }  if (__extra != __last)    _M_erase(__extra);}</code></pre><p>除了这个remove外，还有一个是<code>remove_if</code>，根据条件来删除。</p><pre class=" language-c++"><code class="language-c++">template<typename _Tp, typename _Alloc>template <typename _Predicate>void list<_Tp, _Alloc>::remove_if(_Predicate __pred){    iterator __first = begin();    iterator __last = end();    while (__first != __last)    {        iterator __next = __first;        ++__next;        if (__pred(*__first))          _M_erase(__first);        __first = __next;    }}</code></pre><p>对上述的<code>remove</code>的if去掉，在里面添加一个判断即可。</p><p>使用如下</p><pre class=" language-c++"><code class="language-c++">bool isone(int one) {    return one==2;}int main() {    list<int> t;    t={3,4,0,2,0,10,10};    t.remove_if(isone);}</code></pre><ul><li>删除一系列节点</li><li>删除所有节点，对应的函数<code>clear</code></li></ul><p><strong>（1）删除指定节点详细分析</strong></p><pre class=" language-c++"><code class="language-c++">_M_erase(iterator __position)_GLIBCXX_NOEXCEPT{    __position._M_node->_M_unhook();    _Node *__n = static_cast<_Node *>(__position._M_node);#if __cplusplus >= 201103L    _M_get_Node_allocator().destroy(__n);#else    _M_get_Tp_allocator().destroy(std::__addressof(__n->_M_data));#endif    _M_put_node(__n);        // 释放内存}</code></pre><p>其中<code>_M_unhook</code>实现在<code>gcc-4.9.1/libstdc++-v3/src/c++98/list.cc</code>，实现如下：</p><pre class=" language-c++"><code class="language-c++">void _List_node_base::_M_unhook() _GLIBCXX_USE_NOEXCEPT{  _List_node_base* const __next_node = this->_M_next;    // 第一步：保存后继节点  _List_node_base* const __prev_node = this->_M_prev;    // 第二步：保存前驱节点  __prev_node->_M_next = __next_node;                    // 第三步：前驱节点的next指向后继节点  __next_node->_M_prev = __prev_node;                    // 第四步：后继节点的prev指向前驱节点}</code></pre><p>例如：删除节点值为9的节点，第三与第四步图解：</p><p><img src="http://pxz2lirgn.bkt.clouddn.com/list_erase.png" alt="list_erase"></p><p><strong>（2）删除一系列元素详细分析</strong></p><pre class=" language-c++"><code class="language-c++">iterator#if __cplusplus >= 201103Lerase(const_iterator __first, const_iterator __last) noexcept#elseerase(iterator __first, iterator __last)#endif{    while (__first != __last)        __first = erase(__first);    return __last._M_const_cast();}</code></pre><p>使用erase，删除给定迭代器范围内的数据。</p><p><strong>（3）删除所有元素详细分析</strong></p><p>清空元素，并初始化，回到list默认状态。</p><pre class=" language-c++"><code class="language-c++">void clear()_GLIBCXX_NOEXCEPT{    _Base::_M_clear();    _Base::_M_init();}</code></pre><p>其中<code>_M_clear</code>实现在：<code>libstdc++-v3/include/bits/list.tcc</code>中：</p><pre class=" language-c++"><code class="language-c++">_List_base<_Tp, _Alloc>::_M_clear() _GLIBCXX_NOEXCEPT{  typedef _List_node<_Tp>  _Node;  _Node* __cur = static_cast<_Node*>(_M_impl._M_node._M_next);  while (__cur != &_M_impl._M_node)    {      _Node* __tmp = __cur;            // 保存节点      __cur = static_cast<_Node*>(__cur->_M_next);    // 往后遍历    #if __cplusplus >= 201103L      _M_get_Node_allocator().destroy(__tmp);    #else      _M_get_Tp_allocator().destroy(std::__addressof(__tmp->_M_data));    #endif      _M_put_node(__tmp);    // 释放内存    }}</code></pre><p><code>_M_init</code>实现，全部指向自己即可。</p><pre class=" language-c++"><code class="language-c++">void _M_init()_GLIBCXX_NOEXCEPT{    this->_M_impl._M_node._M_next = &this->_M_impl._M_node;    this->_M_impl._M_node._M_prev = &this->_M_impl._M_node;}</code></pre><p>【<strong>元素访问</strong>】</p><p>每个都实现了两个版本：引用与常引用。</p><ul><li>front 返回第一个元素</li></ul><pre class=" language-c++"><code class="language-c++">reference front()_GLIBCXX_NOEXCEPT{ return *begin(); }const_referencefront() const_GLIBCXX_NOEXCEPT{ return *begin(); }</code></pre><ul><li>返回最后一个元素</li></ul><pre class=" language-c++"><code class="language-c++">referenceback()_GLIBCXX_NOEXCEPT{    iterator __tmp = end();    --__tmp;    return *__tmp;}const_referenceback() const_GLIBCXX_NOEXCEPT{    const_iterator __tmp = end();    --__tmp;    return *__tmp;}</code></pre><p>【<strong>算法</strong>】</p><ul><li>unique</li></ul><p>从容器中的每个连续的相等元素组中除去除第一个元素外的所有元素。</p><p>请注意，只有与<a href="http://www.cplusplus.com/list" target="_blank" rel="noopener">列表</a>容器紧邻的元素相比，该元素才从<a href="http://www.cplusplus.com/list" target="_blank" rel="noopener">列表</a>容器中删除。因此，此功能对于排序列表特别有用。</p><pre class=" language-c++"><code class="language-c++">template<typename _Tp, typename _Alloc>template <typename _BinaryPredicate>  void  list<_Tp, _Alloc>::  unique(_BinaryPredicate __binary_pred)  {    iterator __first = begin();    iterator __last = end();    if (__first == __last)  return;    iterator __next = __first;    while (++__next != __last)  {    // 满足条件就删除    if (__binary_pred(*__first, *__next))       // 删除      _M_erase(__next);    else      __first = __next;    __next = __first;  }  }</code></pre><p>举例如下：</p><pre class=" language-c++"><code class="language-c++">// list::unique#include <iostream>#include <cmath>#include <list>// a binary predicate implemented as a function:bool same_integral_part (double first, double second){ return ( int(first)==int(second) ); }// a binary predicate implemented as a class:struct is_near {  bool operator() (double first, double second)  { return (fabs(first-second)<5.0); }};int main (){  double mydoubles[]={ 12.15,  2.72, 73.0,  12.77,  3.14,                       12.77, 73.35, 72.25, 15.3,  72.25 };  std::list<double> mylist (mydoubles,mydoubles+10);  mylist.sort();             //  2.72,  3.14, 12.15, 12.77, 12.77,                             // 15.3,  72.25, 72.25, 73.0,  73.35  mylist.unique();           //  2.72,  3.14, 12.15, 12.77                             // 15.3,  72.25, 73.0,  73.35  mylist.unique (same_integral_part);  //  2.72,  3.14, 12.15                                       // 15.3,  72.25, 73.0  mylist.unique (is_near());           //  2.72, 12.15, 72.25  std::cout << "mylist contains:";  for (std::list<double>::iterator it=mylist.begin(); it!=mylist.end(); ++it)    std::cout << ' ' << *it;  std::cout << '\n';  return 0;}</code></pre><p>上述排序后会删除所有的重复元素，只剩下一个，而不排序只会删除重复且连续的元素。</p><ul><li>merge</li></ul><p>merge源码实现采用前面<code>_M_transfer</code>函数，假设现在有两个list，分别是list1与list2。list1中的元素与list2中的元素进行比较，如果list1中元素值小于list2中元素值，则对list1迭代器++，不进行任何操作，而如果list1中的元素值大于list2中的元素值，那么每次将list2这个小的元素对应的迭代器塞入<code>_M_transfer</code>函数中，通过这个函数完成向list1中刚才比较的迭代器前面插入list2较小的元素，那么最后所有元素都会被插入到list1中。</p><p>当list1已经遍历完毕，而list2还没有遍历完毕，那么只需要执行一次<code>_M_transfer</code>，将list2链表从当前迭代器开始到最后的end插入到list1的末尾即可。</p><pre class=" language-c++"><code class="language-c++">template<typename _Tp, typename _Alloc>voidlist<_Tp, _Alloc>::#if __cplusplus >= 201103Lmerge(list&& __x)#elsemerge(list& __x)#endif{  // _GLIBCXX_RESOLVE_LIB_DEFECTS  // 300. list::merge() specification incomplete  if (this != &__x)  {      _M_check_equal_allocators(__x);      iterator __first1 = begin();      iterator __last1 = end();      iterator __first2 = __x.begin();      iterator __last2 = __x.end();      while (__first1 != __last1 && __first2 != __last2)        if (*__first2 < *__first1)         {            iterator __next = __first2;            _M_transfer(__first1, __first2, ++__next);            __first2 = __next;         }        else          ++__first1;      if (__first2 != __last2)        _M_transfer(__last1, __first2, __last2);   }}</code></pre><p>使用：</p><pre class=" language-c++"><code class="language-c++">#include <iostream>#include <list>using namespace std;int main() {     list<int> l1 = {2,3,5,7};    list<int> l2 = {1,10,9,5};    l1.sort();    l2.sort();    l1.merge(l2);    for(auto i:l1)         cout<<i<<" "<<endl;    // 1 2 3 5 5 7 9 10    return 0;}</code></pre><ul><li>sort</li></ul><p>由于STL本身的排序算法sort接受的输入迭代器是随机访问迭代器，但是双向list链表容器的访问方式是双向迭代器，因此，不能使用STL本身的排序算法sort，必须自己定义属于自己访问的排序算法。我们从源码的剖析中，可以看到该排序算法思想类似于归并排序。</p><p>sort中splice调用的是：</p><pre class=" language-c++"><code class="language-c++">void splice(const_iterator __position, list& __x, const_iterator __i) noexcept{ splice(__position, std::move(__x), __i); }</code></pre><p>进一步分析：</p><pre class=" language-c++"><code class="language-c++">voidsplice(iterator __position, list &__x, iterator __i){    iterator __j = __i._M_const_cast();    ++__j;    if (__position == __i || __position == __j)        return;    if (this != &__x)        _M_check_equal_allocators(__x);    this->(__position._M_const_cast(),                      __i._M_const_cast(), __j);}</code></pre><p>最后调用的是<code>_M_transfer</code>。</p><p>在sort中还有一个函数<code>swap</code>，完成两个链表交换，实现代码在<code>gcc-4.9.1/libstdc++-v3/src/c++98/list.cc</code>中：</p><pre class=" language-c++"><code class="language-c++">void_List_node_base::swap(_List_node_base& __x,          _List_node_base& __y) _GLIBCXX_USE_NOEXCEPT{      if ( __x._M_next != &__x )    {      if ( __y._M_next != &__y )        {          // Both __x and __y are not empty.          std::swap(__x._M_next,__y._M_next);          std::swap(__x._M_prev,__y._M_prev);          __x._M_next->_M_prev = __x._M_prev->_M_next = &__x;          __y._M_next->_M_prev = __y._M_prev->_M_next = &__y;        }      else        {              // __x is not empty, __y is empty.              __y._M_next = __x._M_next;              __y._M_prev = __x._M_prev;              __y._M_next->_M_prev = __y._M_prev->_M_next = &__y;              __x._M_next = __x._M_prev = &__x;            }        }      else if ( __y._M_next != &__y )        {          // __x is empty, __y is not empty.          __x._M_next = __y._M_next;          __x._M_prev = __y._M_prev;          __x._M_next->_M_prev = __x._M_prev->_M_next = &__x;          __y._M_next = __y._M_prev = &__y;        }}</code></pre><p>具体的实现思路是，判断两个链表为空还是不为空，然后修改next指针与prev指针。</p><p>下面来看看强大的sort：</p><pre class=" language-c++"><code class="language-c++">template<typename _Tp, typename _Alloc>voidlist<_Tp, _Alloc>::sort() {    // Do nothing if the list has length 0 or 1.    if (this->_M_impl._M_node._M_next != &this->_M_impl._M_node        && this->_M_impl._M_node._M_next->_M_next != &this->_M_impl._M_node) {        list __carry; // 辅助链表，用于从a中提取元素以及临时保存两个链表的合并结果        list __tmp[64]; // 保存着当前每一个归并层次的结果, i号链表保存的元素个数为2的i次方或者0        list *__fill = &__tmp[0]; // 表示当前最大归并排序的层次，while循环之后__fill变成log2(list.size())        list *__counter;        do {            __carry.splice(__carry.begin(), *this, begin()); //把当前链表的第一个节点放在carry链表头            for (__counter = &__tmp[0];                 __counter != __fill && !__counter->empty();                 ++__counter) {                __counter->merge(__carry);    // 两个有序链表合并                __carry.swap(*__counter); // 类似于交换链表carry和counter[i]内容                }            __carry.swap(*__counter); // 类似于交换链表carry和counter[i]内容                if (__counter == __fill)                ++__fill;        } while (!empty());        // 每两个进行归并，依次网上，直到最后*(__fill-1)保存最后的排序结果。然后交换到当前list中。        for (__counter = &__tmp[1]; __counter != __fill; ++__counter)            __counter->merge(*(__counter - 1));        swap(*(__fill - 1));     }}</code></pre><p>上述代码看起来比较难懂，在网上查找后发现，G2.9中：</p><pre class=" language-c++"><code class="language-c++">template <class T, class Alloc>void list<T, Alloc> :: sort(){    // 判断链表是否为空或者只有一个元素    if(node->next == node || link_type(node->next)->next == node){        return;    }    list<T, Alloc> carry;    list<T, alloc> counter[64];    int fill = 0;    while(!empty()){        carry.splice(carry.begin(), *this, begin());        int i = 0;        while(i < fill && !counter[i].empty()){            counter[i].merge(carry);            carry.swap(counter[i++]);        }        carry.swap(counter[i]);        if(i == fill){            ++fill;        }     }    for(int i = 1; i < fill; ++i){        counter[i].merge(counter[i-1]);    }    swap(counter[fill-1]);}</code></pre><p>对应的外部实现是：</p><pre class=" language-c++"><code class="language-c++">void sortList(list<int> &l) {    if (l.size() <= 1) {        return;    }    list<int> carry;       // 辅助链表，用于从a中提取元素以及临时保存两个链表的合并结果    list<int> counter[64]; // 保存着当前每一个归并层次的结果, i号链表保存的元素个数为2的i次方或者0    int fill = 0;          // 表示当前最大归并排序的层次，while循环之后fill变成log2(a.size())    while (!l.empty()) {        carry.splice(carry.begin(), l, l.begin()); // 将链表a中的第一个元素移动至carry开头        int i = 0;        // 从小往大不断合并非空归并层次直至遇到空层或者到达当前最大归并层次        while (i < fill && !counter[i].empty()) {            counter[i].merge(carry);    // 链表合并，结果链表是有序的，必须保证合并前两个链表是有序的            carry.swap(counter[i++]);   // 链表元素互换        }        carry.swap(counter[i]);        if (i == fill) {       // i到达当前最大归并层次，说明得增加一层            ++fill;        }    }    for (int i = 1; i < fill; ++i) {  // 将所有归并层次的结果合并得到最终结果counter[fill - 1]        counter[i].merge(counter[i - 1]);    }    l.swap(counter[fill - 1]);}</code></pre><p>这一块可以参考</p><blockquote><p><a href="https://blog.csdn.net/chenhanzhun/article/details/39337331" target="_blank" rel="noopener">https://blog.csdn.net/chenhanzhun/article/details/39337331</a></p></blockquote><p>上面给出了详细的过程图解。</p><p>我们再次将G4.9转换对应的外部实现：</p><pre class=" language-c++"><code class="language-c++">void sortList1(list<int> &l) {    typedef list<int> list;    if (l.size() <= 1) {        return;    }    list __carry;    list __tmp[64];    list *__fill = &__tmp[0];    list *__counter;    do {        __carry.splice(__carry.begin(), l, l.begin());        for (__counter = &__tmp[0];             __counter != __fill && !__counter->empty();             ++__counter) {            __counter->merge(__carry);            __carry.swap(*__counter);        }        __carry.swap(*__counter);        if (__counter == __fill) ++__fill;    } while (!l.empty());    for (__counter = &__tmp[1]; __counter != __fill; ++__counter)        __counter->merge(*(__counter - 1));    l.swap(*(__fill - 1));}</code></pre><p>使用：</p><pre class=" language-c++"><code class="language-c++">int main() {    list<int> l = {7, 5, 8, 1};    cout << "===============排序前==============" << endl;    for (auto i:l) cout << i << " ";    cout << endl;    sortList1(l);    cout << "===============排序后==============" << endl;    for (auto i:l) cout << i << " ";    cout << endl;    return 0;}</code></pre><p>【<strong>操作符重载</strong>】</p><pre class=" language-c++"><code class="language-c++">template<typename _Tp, typename _Alloc>inline booloperator==(const list<_Tp, _Alloc> &__x, const list<_Tp, _Alloc> &__y) {    typedef typename list<_Tp, _Alloc>::const_iterator const_iterator;    const_iterator __end1 = __x.end();    const_iterator __end2 = __y.end();    const_iterator __i1 = __x.begin();    const_iterator __i2 = __y.begin();    while (__i1 != __end1 && __i2 != __end2 && *__i1 == *__i2) {        ++__i1;        ++__i2;    }    return __i1 == __end1 && __i2 == __end2;}</code></pre><p>实现思路是，迭代判断两个迭代器是否都抵达末尾。</p><p>剩下就是其他的操作符重载，比较简单，就不阐述了。其中<code>lexicographical_compare</code>实现在<code>c++-v3/src/c++98/stl_algobase.h</code>中，该函数是按照字典序测试[frist1,last1)是否小于[first2,last2)。该函数使用opeartor&lt;或者是comp进行比较。其行为类似于：如果两个序列长度不同，并且短序列和长序列头部完全一样，例如example和examplee.那么，长度大的字典序比短序的大。</p><pre class=" language-c++"><code class="language-c++">template <class InputIterator1, class InputIterator2>bool lexicographical_compare (InputIterator1 first1, InputIterator1 last1,InputIterator2 first2, InputIterator2 last2){    while (first1!=last1)    {        if (first2==last2 || *first2<*first1) return false;        else if (*first1<*first2) return true;        ++first1; ++first2;    }    return (first2!=last2);}</code></pre><p>使用：</p><pre class=" language-c++"><code class="language-c++">int main() {     vector<char> v1{'h','e','l','l','o'};    vector<char> v2{'h','e','l','l','o','o'};    vector<char> v3{'h','e','l','m','o'};    cout<<"v1=";    for(char i:v1)        cout<<i<<" ";    cout<<endl;    cout<<"v2=";    for(char i:v2)        cout<<i<<" ";    cout<<endl;    cout<<"v3=";    for(char i:v3)        cout<<i<<" ";    cout<<endl;    if(lexicographical_compare(v1.begin(),v1.end(),v2.begin(),v2.end()))        cout<<"v1 is less than v2 "<<endl;    else        cout<<"v2 is less than v1 "<<endl;    if(lexicographical_compare(v1.begin(),v1.end(),v3.begin(),v3.end()))        cout<<"v1 is less than v3 "<<endl;    else        cout<<"v3 is less than v1 "<<endl;}</code></pre><p>其它重载操作符如下：</p><pre class=" language-c++"><code class="language-c++">template<typename _Tp, typename _Alloc>inline booloperator<(const list<_Tp, _Alloc> &__x, const list<_Tp, _Alloc> &__y) {    return std::lexicographical_compare(__x.begin(), __x.end(),                                        __y.begin(), __y.end());}/// Based on operator==template<typename _Tp, typename _Alloc>inline booloperator!=(const list<_Tp, _Alloc> &__x, const list<_Tp, _Alloc> &__y) { return !(__x == __y); }/// Based on operator<template<typename _Tp, typename _Alloc>inline booloperator>(const list<_Tp, _Alloc> &__x, const list<_Tp, _Alloc> &__y) { return __y < __x; }/// Based on operator<template<typename _Tp, typename _Alloc>inline booloperator<=(const list<_Tp, _Alloc> &__x, const list<_Tp, _Alloc> &__y) { return !(__y < __x); }/// Based on operator<template<typename _Tp, typename _Alloc>inline booloperator>=(const list<_Tp, _Alloc> &__x, const list<_Tp, _Alloc> &__y) { return !(__x < __y); }</code></pre><h3 id="1-2-list基类源码"><a href="#1-2-list基类源码" class="headerlink" title="1.2 list基类源码"></a>1.2 list基类源码</h3><p><code>_list_base</code>中有一个结构体:<code>_List_impl</code>,而<code>_List_impl</code>中有一个<code>List_node_base</code>。</p><pre class=" language-c++"><code class="language-c++">class _List_base{protected:  typedef typename _Alloc::template rebind<_List_node<_Tp> >::other    _Node_alloc_type;  typedef typename _Alloc::template rebind<_Tp>::other _Tp_alloc_type;  struct _List_impl  : public _Node_alloc_type  {    __detail::_List_node_base _M_node;    _List_impl()    : _Node_alloc_type(), _M_node()    { }    _List_impl(const _Node_alloc_type& __a) _GLIBCXX_NOEXCEPT    : _Node_alloc_type(__a), _M_node()    { }    #if __cplusplus >= 201103L    _List_impl(_Node_alloc_type&& __a) _GLIBCXX_NOEXCEPT    : _Node_alloc_type(std::move(__a)), _M_node()    { }    #endif  };  _List_impl _M_impl;};</code></pre><p>最后形成的图就是:</p><p><img src="http://pxz2lirgn.bkt.clouddn.com/list_iterator_design.png" alt="list's iterator_design"></p><p>所以如果求:</p><pre class=" language-c++"><code class="language-c++">sizeof(list<int>)=16</code></pre><p>原因是:</p><p><code>list</code>的sizeof为1,所以sizeof来源于基类<code>_list_base</code>,而<code>_list_base</code>中有一个结构体:<code>_List_impl</code>,而<code>_List_impl</code>中有一个<code>_List_node_base</code>.</p><p>我们知道<code>_List_node_base</code>,里面有两个指针,在64位上,每个为8字节,共16字节。</p><h2 id="2-list’s-Iterator剖析"><a href="#2-list’s-Iterator剖析" class="headerlink" title="2.list’s Iterator剖析"></a>2.list’s Iterator剖析</h2><h3 id="2-1-iterator"><a href="#2-1-iterator" class="headerlink" title="2.1 iterator"></a>2.1 iterator</h3><p>list的iterator定义</p><pre class=" language-c++"><code class="language-c++">template<typename _Tp>struct _List_iterator{  typedef _List_iterator<_Tp>                _Self;  typedef _List_node<_Tp>                    _Node;  typedef ptrdiff_t                          difference_type;  typedef std::bidirectional_iterator_tag    iterator_category;  typedef _Tp                                value_type;  typedef _Tp*                               pointer;  typedef _Tp&                               reference;   // The only member points to the %list element.   __detail::_List_node_base* _M_node;            //  _List_node(节点的数据部分) -> _List_node_base(前指针与后指针)  _List_iterator() _GLIBCXX_NOEXCEPT  : _M_node() { }  explicit  _List_iterator(__detail::_List_node_base* __x) _GLIBCXX_NOEXCEPT  : _M_node(__x) { }  _Self  _M_const_cast() const _GLIBCXX_NOEXCEPT  { return *this; }  // The only member points to the %list element.  __detail::_List_node_base* _M_node;};</code></pre><p>内部重载函数:</p><pre class=" language-c++"><code class="language-c++">// Must downcast from _List_node_base to _List_node to get to _M_data.// 重载*操作符reference operator*() const _GLIBCXX_NOEXCEPT{     return static_cast<_Node*>(_M_node)->_M_data; }// 重载->操作符pointer operator->() const _GLIBCXX_NOEXCEPT{     return std::__addressof(static_cast<_Node*>(_M_node)->_M_data); }// 重载前置++操作符  ++i_Self& operator++() _GLIBCXX_NOEXCEPT   {     _M_node = _M_node->_M_next;    return *this;}// 重载后置++操作符 i++_Self operator++(int) _GLIBCXX_NOEXCEPT{    _Self __tmp = *this;             // 记录原值  *调用的是拷贝构造函数    _M_node = _M_node->_M_next;         // 进行操作    return __tmp;                     // 返回原值}// 重载前置--操作符  --i_Self& operator--() _GLIBCXX_NOEXCEPT{    _M_node = _M_node->_M_prev;    return *this;}// 重载后置--操作符  --i_Self operator--(int) _GLIBCXX_NOEXCEPT{    _Self __tmp = *this;    _M_node = _M_node->_M_prev;    return __tmp;}// 重载++操作符bool operator==(const _Self& __x) const _GLIBCXX_NOEXCEPT{     return _M_node == __x._M_node; }// 重载!=操作符bool operator!=(const _Self& __x) const _GLIBCXX_NOEXCEPT{     return _M_node != __x._M_node; }</code></pre><h3 id="2-2-结点设计"><a href="#2-2-结点设计" class="headerlink" title="2.2 结点设计"></a>2.2 结点设计</h3><p>iterator内部的<code>_List_node</code>,这里可以得到继承自<code>_List_node_base</code>.</p><p><code>_List_node</code>放数据部分</p><p><code>_List_node_base</code>放前后指针</p><pre class=" language-c++"><code class="language-c++">/// An actual node in the %list.template<typename _Tp>struct _List_node : public __detail::_List_node_base{  ///< User's data.  _Tp _M_data;#if __cplusplus >= 201103L  template<typename... _Args>    _List_node(_Args&&... __args): __detail::_List_node_base(), _M_data(std::forward<_Args>(__args)...)     { }#endif};</code></pre><p><code>_List_node_base</code>代码:</p><pre class=" language-c++"><code class="language-c++">namespace __detail{    _GLIBCXX_BEGIN_NAMESPACE_VERSION    /// Common part of a node in the %list.     struct _List_node_base    {      _List_node_base* _M_next;      _List_node_base* _M_prev;      static void      swap(_List_node_base& __x, _List_node_base& __y) _GLIBCXX_USE_NOEXCEPT;      void      _M_transfer(_List_node_base* const __first,          _List_node_base* const __last) _GLIBCXX_USE_NOEXCEPT;      void      _M_reverse() _GLIBCXX_USE_NOEXCEPT;      void      _M_hook(_List_node_base* const __position) _GLIBCXX_USE_NOEXCEPT;      void      _M_unhook() _GLIBCXX_USE_NOEXCEPT;    };    _GLIBCXX_END_NAMESPACE_VERSION} // namespace detail</code></pre><p>迭代器在设计的时候,总是保持前闭后开原则,例如iter-&gt;begin()指向第一个元素,iter-&gt;end()指向实际最后一个元素的下一个元素,故最后的设计刻意在环形list尾部加一个空白结点,用以符合STL前闭后开原则.</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> STL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C/C++多线程编程基础</title>
      <link href="/2019/09/24/duo-jin-cheng-yu-duo-xian-cheng-ji-chu/"/>
      <url>/2019/09/24/duo-jin-cheng-yu-duo-xian-cheng-ji-chu/</url>
      
        <content type="html"><![CDATA[<h1 id="C-C-多线程编程基础"><a href="#C-C-多线程编程基础" class="headerlink" title="C/C++多线程编程基础"></a>C/C++多线程编程基础</h1><h2 id="1-基础问题"><a href="#1-基础问题" class="headerlink" title="1.基础问题"></a>1.基础问题</h2><ul><li><strong>某个线程崩溃，会导致进程退出吗?或者说进程中某个线程崩溃，是否会对其他线程造成影响？</strong></li></ul><p>答：一般来说，每个线程都是独立执行的单位，每个线程都有自己的上下文堆栈，一个线程的的崩溃不会对其他线程造成影响。但是通常情况下，一个线程崩溃会产生一个进程内的错误，例如，在 Linux 操作系统中，可能会产生一个 <strong>Segment Fault</strong> 错误，这个错误会产生一个信号，操作系统默认对这个信号的处理就是结束进程，整个进程都被销毁了，这样的话这个进程中存在的其他线程自然也就不存在了。</p><ul><li><strong>排查 Linux 进程 CPU 使用率过高问题？</strong></li></ul><p>在实际开发中，有时候由于我们的程序逻辑不当问题，会导致某个线程<strong>空转</strong>（如无限空循环），进而引起该进程占用 CPU 使用率过高。这不仅会造成我们的系统卡顿，也是对 CPU 资源的一种浪费。那如何定位和排查引起 CPU 使用率过高的线程呢？</p><p>在 Linux 下我们可以综合使用 pstack 和 top 命令来排查此类问题。</p><h2 id="2-基础命令"><a href="#2-基础命令" class="headerlink" title="2.基础命令"></a>2.基础命令</h2><ul><li>pstack</li></ul><p>Linux 系统中可以通过 <strong>pstack</strong> 来命令查看一个进程的线程数量和每个线程的调用堆栈情况。</p><pre><code>pstack pid</code></pre><p><strong>pid</strong> 设置为要查看的进程的 id 即可。</p><ul><li>top</li></ul><p>可以查看cpu高的进程，找到占用cpu最大的进程号，然后使用：</p><pre><code>top -p pid</code></pre><p>观察指定pid的CPU和内存以及负载情况。</p><p>现在有如下信息：</p><pre><code>top - 19:30:05 up  6:15,  1 user,  load average: 0.85, 0.71, 0.61Tasks:   1 total,   0 running,   1 sleeping,   0 stopped,   0 zombie%Cpu(s):  8.1 us,  2.9 sy,  0.0 ni, 87.8 id,  0.0 wa,  0.0 hi,  1.1 si,  0.0 stKiB Mem : 20412976 total, 10960136 free,  5416592 used,  4036248 buff/cacheKiB Swap:  2097148 total,  2097148 free,        0 used. 14315608 avail Mem </code></pre><p><strong>第一行是任务队列信息</strong></p><table><thead><tr><th align="center">任务队列信息</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">9:30:05</td><td align="center">当前时间</td></tr><tr><td align="center">6:15 min</td><td align="center">用户在线时间</td></tr><tr><td align="center">1users</td><td align="center">在线用户数</td></tr><tr><td align="center">load average: 0.85, 0.71, 0.61</td><td align="center">系统负载，即任务队列的平均长度。1分钟前、5分钟前、15分钟前平均负载</td></tr></tbody></table><p><strong>第二行为进程的信息</strong></p><table><thead><tr><th align="center">进程信息</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">Tasks: 1 total</td><td align="center">进程总数</td></tr><tr><td align="center">0 running</td><td align="center">正在运行的进程数</td></tr><tr><td align="center">1 sleeping</td><td align="center">睡眠的进程数</td></tr><tr><td align="center">0 stopped</td><td align="center">停止的进程数</td></tr><tr><td align="center">0 zombie</td><td align="center">僵尸进程数</td></tr></tbody></table><p><strong>第三行为cpu信息</strong></p><table><thead><tr><th align="center">cpu信息</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">8.1 us</td><td align="center">用户空间占用CPU百分比</td></tr><tr><td align="center">2.9% sy</td><td align="center">内核空间占用CPU百分比</td></tr><tr><td align="center">0.0% ni</td><td align="center">用户进程空间内改变过优先级的进程占用CPU百分比</td></tr><tr><td align="center">87.8% id</td><td align="center">空闲CPU百分比</td></tr><tr><td align="center">0.0% wa</td><td align="center">等待输入输出的CPU时间百分比</td></tr><tr><td align="center">0.0% hi</td><td align="center">硬件中断</td></tr><tr><td align="center">1.1% si</td><td align="center">软件中断</td></tr><tr><td align="center">0.0%st</td><td align="center">实时</td></tr></tbody></table><p><strong>第四、五行为内存信息。</strong></p><table><thead><tr><th align="center">物理内存信息</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">Mem: 20412976 total</td><td align="center">物理内存总量</td></tr><tr><td align="center">5416592 used</td><td align="center">使用的物理内存总量</td></tr><tr><td align="center">10960136 free</td><td align="center">空闲内存总量</td></tr><tr><td align="center">4036248 buffers/cache</td><td align="center">用作内核缓存的内存量</td></tr></tbody></table><table><thead><tr><th align="center">交换区信息</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">Swap: 2097148 total</td><td align="center">交换区总量</td></tr><tr><td align="center">0k used</td><td align="center">使用的交换区总量</td></tr><tr><td align="center">2097148 free</td><td align="center">空闲交换区总量</td></tr><tr><td align="center">14315608 cached</td><td align="center">缓冲的交换区总量</td></tr></tbody></table><p>那如何通过top命令定位问题进程中每个线程占用cpu情况？</p><p>使用<code>-H</code>,top 命令的 -H 选项的作用是显示每个一个进程的各个线程运行状态（线程模式）。</p><p>例如：</p><pre><code>top -p 2085 -H</code></pre><p><img src="http://pxz2lirgn.bkt.clouddn.com/top.png" alt=""></p><p>由上图明显可以发现，线程PID 2085 CPU占用率最高，接下来定位该线程的代码是否出现异常导致cpu占用过高。</p><p>结合上述的pstack，例如：</p><pre><code>pstack 2085</code></pre><p>在 pstack 输出的各个线程中，只要逐一对照我们的程序源码来梳理下该线程中是否有大多数时间都处于空转的逻辑，然后修改和优化这些逻辑就可以解决 CPU 使用率过高的问题了，一般情况下，不工作的线程应尽量使用锁对象让其挂起，而不是空转，这样可以提高系统资源利用率。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> C </category>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 项目之Googletest单元测试</title>
      <link href="/2019/09/17/googletest-1/"/>
      <url>/2019/09/17/googletest-1/</url>
      
        <content type="html"><![CDATA[<h1 id="C-项目之Googletest单元测试"><a href="#C-项目之Googletest单元测试" class="headerlink" title="C++ 项目之Googletest单元测试"></a>C++ 项目之Googletest单元测试</h1><h2 id="1-Clion集成Googletest单元测试"><a href="#1-Clion集成Googletest单元测试" class="headerlink" title="1.Clion集成Googletest单元测试"></a>1.Clion集成Googletest单元测试</h2><p>Googletest - Google Testing and Mocking Framework</p><p>源码下载地址:</p><blockquote><p><a href="https://github.com/google/googletest/releases" target="_blank" rel="noopener">https://github.com/google/googletest/releases</a></p></blockquote><p>Googletest中包含两个模块,分别是gtest与gmock,需要分别源码编译,编译完后,到指定目录去拷贝includes文件夹与.so文件到下面路径的指定位置.</p><p>然后项目中创建ext目录,里面分为两块</p><ul><li>第一块:includes</li></ul><p>包含gmock与gtest的include文件,对应于gcc -I参数,头文件路径,包含以.h结尾的头文件</p><ul><li>第二块:libs</li></ul><p>包含gmock与gtest的libs文件,对应gcc -L参数,库文件路径,里面包含的是一些.so或.dll等动态或静态链接库</p><pre class=" language-c++"><code class="language-c++">├── ext│   ├── includes│   │   ├── gmock│   │   └── gtest│   └── libs│       ├── gmock│       └── gtest</code></pre><p>上述本地项目路径配置好后,在CmakeLists.txt中进行配置:</p><pre class=" language-c++"><code class="language-c++"># extset(BASE_INCLUDES ext/includes)set(BASE_LIBS ext/libs)# googletestset(GTEST_INCLUDE_DIR ${BASE_INCLUDES}/gtest/include)set(GMOCK_INCLUDE_DIR ${BASE_INCLUDES}/gmock/include)set(GTEST_LINK_DIR ${BASE_LIBS}/gtest/lib/)set(GMOCK_LINK_DIR ${BASE_LIBS}/gmock/lib/)# 去哪里找头文件 相当于gcc/clang 中的-I(i的大写字母)参数include_directories(${GTEST_INCLUDE_DIR})include_directories(${GMOCK_INCLUDE_DIR})# 去哪里找库文件 .so .dll .dylib 相当于gcc 中的-L参数link_directories(${GTEST_LINK_DIR})link_directories(${GMOCK_LINK_DIR})</code></pre><p>然后为每个test配上链接库即可.</p><p>例如,现在有个测试file,文件名为:了l1.cpp</p><p>那么在CmakeLists.txt中配置为:</p><pre class=" language-c++"><code class="language-c++">add_executable(l1 l1.cpp)target_link_libraries(l1 gtest gtest_main)  </code></pre><h2 id="2-gtest之Helloworld"><a href="#2-gtest之Helloworld" class="headerlink" title="2.gtest之Helloworld"></a>2.gtest之Helloworld</h2><pre><code>int main(int argc, char* argv[]){    // 接收命令行参数    testing::InitGoogleTest(&amp;argc, argv);    vector&lt;int&gt; x={1,2,3,5};    // EXPECT_EQ使用    for (int i = 0; i &lt; x.size(); ++i)    {        EXPECT_EQ(x[i], 1) &lt;&lt; "Vectors x and y differ at index " &lt;&lt; i;    }    RUN_ALL_TESTS();    return 0;}</code></pre><p>例如上述就是个完整的例子,每次运行:</p><pre><code>testing::InitGoogleTest(&amp;argc, argv);</code></pre><p>然后使用:</p><pre><code>RUN_ALL_TESTS();</code></pre><p>运行所有的Test,每个Test编写参考后面断言.</p><p>我们看看运行效果:</p><pre class=" language-c++"><code class="language-c++">l1.cpp:113: FailureExpected equality of these values:  x[i]    Which is: 2  1Vectors x and y differ at index 1l1.cpp:113: FailureExpected equality of these values:  x[i]    Which is: 3  1Vectors x and y differ at index 2l1.cpp:113: FailureExpected equality of these values:  x[i]    Which is: 5  1Vectors x and y differ at index 3[==========] Running 0 tests from 0 test cases.[==========] 0 tests from 0 test cases ran. (0 ms total)[  PASSED  ] 0 tests.[  FAILED  ] 0 tests, listed below: 0 FAILED TESTS</code></pre><h2 id="2-gtest初识之断言"><a href="#2-gtest初识之断言" class="headerlink" title="2.gtest初识之断言"></a>2.gtest初识之断言</h2><p>关于断言Google包装了一系列<code>EXPECT</code>和<code>ASSERT</code>的宏，而EXPECT系列和ASSERT系列的区别是：</p><ul><li><code>EXPECT</code>  失败时，案例继续往下执行。</li><li><code>ASSERT</code> 失败时，直接在当前函数中返回，当前函数中<code>ASSERT</code>后面的语句将不会执行。</li></ul><p>例如:</p><pre class=" language-c++"><code class="language-c++">TEST(ASSERTTest, ASSERT_VS_EXPECT){    ASSERT_TRUE(10<2);  // ASSERT失败,直接在当前函数中返回,后面语句不执行    ASSERT_FALSE(10<2);    EXPECT_EQ(6, Foo(310, 18));}</code></pre><p>每个Test是个宏,Test底层源码如下:</p><pre class=" language-c++"><code class="language-c++"># define TEST(test_case_name, test_name) GTEST_TEST(test_case_name, test_name)</code></pre><p>对应test_case名与test名.</p><p>上述代码中10&lt;2为False,而使用了<code>ASSERT_TRUE</code>,该Test后面所有内容就不会执行,如果换成<code>EXPECT_TRUE</code>则正常运行!</p><blockquote><p> 布尔值检查</p></blockquote><table><thead><tr><th><strong>Fatal assertion</strong></th><th><strong>Nonfatal assertion</strong></th><th><strong>Verifies</strong></th></tr></thead><tbody><tr><td><code>ASSERT_TRUE(</code><em>condition</em><code>)</code>;</td><td><code>EXPECT_TRUE(</code><em>condition</em><code>)</code>;</td><td><em>condition</em> is true</td></tr><tr><td><code>ASSERT_FALSE(</code><em>condition</em><code>)</code>;</td><td><code>EXPECT_FALSE(</code><em>condition</em><code>)</code>;</td><td><em>condition</em> is false</td></tr></tbody></table><blockquote><p>数值型数据检查</p></blockquote><table><thead><tr><th><strong>Fatal assertion</strong></th><th><strong>Nonfatal assertion</strong></th><th><strong>Verifies</strong></th></tr></thead><tbody><tr><td><code>ASSERT_EQ(</code><em>expected</em><code>,</code><em>actual</em><code>);</code></td><td><code>EXPECT_EQ(</code><em>expected</em><code>,</code><em>actual</em><code>);</code></td><td><em>expected</em> <code>==</code> <em>actual</em></td></tr><tr><td><code>ASSERT_NE(</code><em>val1</em><code>,</code><em>val2</em><code>);</code></td><td><code>EXPECT_NE(</code><em>val1</em><code>,</code><em>val2</em><code>);</code></td><td><em>val1</em> <code>!=</code> <em>val2</em></td></tr><tr><td><code>ASSERT_LT(</code><em>val1</em><code>,</code><em>val2</em><code>);</code></td><td><code>EXPECT_LT(</code><em>val1</em><code>,</code><em>val2</em><code>);</code></td><td><em>val1</em> <code>&lt;</code> <em>val2</em></td></tr><tr><td><code>ASSERT_LE(</code><em>val1</em><code>,</code><em>val2</em><code>);</code></td><td><code>EXPECT_LE(</code><em>val1</em><code>,</code><em>val2</em><code>);</code></td><td><em>val1</em> <code>&lt;=</code> <em>val2</em></td></tr><tr><td><code>ASSERT_GT(</code><em>val1</em><code>,</code><em>val2</em><code>);</code></td><td><code>EXPECT_GT(</code><em>val1</em><code>,</code><em>val2</em><code>);</code></td><td><em>val1</em> <code>&gt;</code> <em>val2</em></td></tr><tr><td><code>ASSERT_GE(</code><em>val1</em><code>,</code><em>val2</em><code>);</code></td><td><code>EXPECT_GE(</code><em>val1</em><code>,</code><em>val2</em><code>);</code></td><td><em>val1</em> <code>&gt;=</code> <em>val2</em></td></tr></tbody></table><blockquote><p>字符串检查</p></blockquote><pre class=" language-c++"><code class="language-c++">TEST(StringCmpTest, Demo){    char* pszCoderZh = "CoderZh";    wchar_t* wszCoderZh = L"CoderZh";    std::string strCoderZh = "CoderZh";    std::wstring wstrCoderZh = L"CoderZh";    EXPECT_STREQ("CoderZh", pszCoderZh);    EXPECT_STREQ(L"CoderZh", wszCoderZh);    EXPECT_STRNE("CnBlogs", pszCoderZh);    EXPECT_STRNE(L"CnBlogs", wszCoderZh);    EXPECT_STRCASEEQ("coderzh", pszCoderZh);    //EXPECT_STRCASEEQ(L"coderzh", wszCoderZh);    不支持    EXPECT_STREQ("CoderZh", strCoderZh.c_str());    EXPECT_STREQ(L"CoderZh", wstrCoderZh.c_str());}</code></pre><p>其中STREQ和STRNE同时支持char<em>和wchar_t</em>类型的，<em>STRCASEEQ</em>和<em>STRCASENE</em>却只接收<code>char*</code></p><blockquote><p>显示返回成功或失败</p></blockquote><p>直接返回成功：<code>SUCCEED();</code></p><p>返回失败：</p><table><thead><tr><th><strong>Fatal assertion</strong></th><th><strong>Nonfatal assertion</strong></th></tr></thead><tbody><tr><td><code>FAIL();</code></td><td><code>ADD_FAILURE();</code></td></tr></tbody></table><pre class=" language-c++"><code class="language-c++">// 返回成功与否TEST(ExplicitTest, Demo){    ADD_FAILURE() << "这行打印失败 Sorry"; // None Fatal Asserton，继续往下执行。    //FAIL(); // Fatal Assertion，不往下执行该案例。    EXPECT_TRUE(1==2)<<"1==2 failed!";      // 为了验证上述失败后是否执行下面    SUCCEED();}</code></pre><blockquote><p>异常检查</p></blockquote><p>分为三个:</p><p><code>EXPECT_NO_THROW(statement);</code>  不抛出异常</p><p><code>EXPECT_ANY_THROW(statement);</code>抛出任意类型异常</p><p><code>EXPECT_THROW(statement, exception_type);</code> 抛出指定类型异常</p><pre class=" language-c++"><code class="language-c++">TEST(ExceptionTest,et) {    // 抛出任意类型异常    EXPECT_ANY_THROW(10/0); //Expected: 10/0 throws an exception.    // 抛出指定类型异常    EXPECT_THROW(1/0,int); //Expected: 1/0 throws an exception of type int.}</code></pre><blockquote><p>Predicate Assertions</p></blockquote><p>检查一个函数的返回值TRUE还是FALSE时，希望能够输出传入的参数是什么，以便失败后好跟踪</p><p>例如:</p><pre class=" language-c++"><code class="language-c++">// 预测断言bool MN(int m, int n){    return m>n;}//检查一个函数的返回值TRUE还是FALSE时，希望能够输出传入的参数是什么，以便失败后好跟踪TEST(PredicateAssertionTest, Demo){    int m = 5, n = 6;    EXPECT_PRED2(MN, m, n); //只提供<=5个参数  传递参数要与函数MN对应}</code></pre><p>``EXPECT_PRED2(pred2, val1, val2);`ASSERT类似.PRED2可以到PRED5</p><p>最多支持5个参数.</p><blockquote><p>浮点型检查</p></blockquote><p><code>EXPECT_FLOAT_EQ(expected, actual)</code>与<code>EXPECT_DOUBLE_EQ(expected, actual)</code></p><p>ASSERT类似.</p><p>对相近的两个数比较：</p><p><code>EXPECT_NEAR(val1, val2, abs_error);</code></p><p>ASSERT类似.</p><p>例如:</p><pre class=" language-c++"><code class="language-c++">// 浮点型TEST(FloatDoubleTest,Demo) {    ASSERT_DOUBLE_EQ(1.1,1.1);    EXPECT_FLOAT_EQ(1.2,4.0);    EXPECT_NEAR(1.234,1.888,0.9);//    EXPECT_PRED_FORMAT2(testing::FloatLE, val1, val2);//    EXPECT_PRED_FORMAT2(testing::DoubleLE, val1, val2);    EXPECT_PRED_FORMAT2(testing::FloatLE,1,0);      // LE表示小于等于 也就是value1<=value2    EXPECT_PRED_FORMAT2(testing::DoubleLE,0.1,0.2);}</code></pre><blockquote><p>类型检查</p></blockquote><pre class=" language-c++"><code class="language-c++">// 类型检查template <typename T>class Tt{public:    void foo() {        testing::StaticAssertTypeEq<bool, T>();     // 与下面调用一致就不报错,否则报错    }};TEST(TypeAssertionTest, Demo){    Tt<bool> tt;    tt.foo();}</code></pre><p>学习参考自:<a href="https://www.cnblogs.com/coderzh/archive/2009/04/06/1430364.html" target="_blank" rel="noopener">https://www.cnblogs.com/coderzh/archive/2009/04/06/1430364.html</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 单元测试 </category>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> Googletest </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
