<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>C++ STL源码剖析之undered_map、unordered_multimap、unordered_set、unordered_multiset</title>
      <link href="/2019/10/24/undered-map/"/>
      <url>/2019/10/24/undered-map/</url>
      
        <content type="html"><![CDATA[<h1 id="C-STL源码剖析之undered-map、unordered-multimap、unordered-set、unordered-multiset"><a href="#C-STL源码剖析之undered-map、unordered-multimap、unordered-set、unordered-multiset" class="headerlink" title="C++ STL源码剖析之undered_map、unordered_multimap、unordered_set、unordered_multiset"></a>C++ STL源码剖析之undered_map、unordered_multimap、unordered_set、unordered_multiset</h1><h2 id="0-导语"><a href="#0-导语" class="headerlink" title="0.导语"></a>0.导语</h2><p>前面学到了hashtable，而这节是hashtable的容器适配器：unordered_map。</p><p>所以无序map的底层容器采用hashtable。</p><p>unordered_map与unordered_multimap的源码在<code>unordered_map.h</code>这个文件中。</p><h2 id="1-undered-map与unordered-multimap本质区别"><a href="#1-undered-map与unordered-multimap本质区别" class="headerlink" title="1.undered_map与unordered_multimap本质区别"></a>1.undered_map与unordered_multimap本质区别</h2><p>先来看一下undered_map源码：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">_Key</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">_Tp</span><span class="token punctuation">,</span><span class="token keyword">class</span> <span class="token class-name">_Hash</span> <span class="token operator">=</span> hash<span class="token operator">&lt;</span>_Key<span class="token operator">></span><span class="token punctuation">,</span><span class="token keyword">class</span> <span class="token class-name">_Pred</span> <span class="token operator">=</span> std<span class="token operator">::</span>equal_to<span class="token operator">&lt;</span>_Key<span class="token operator">></span><span class="token punctuation">,</span><span class="token keyword">class</span> <span class="token class-name">_Alloc</span> <span class="token operator">=</span> std<span class="token operator">::</span>allocator<span class="token operator">&lt;</span>std<span class="token operator">::</span>pair<span class="token operator">&lt;</span><span class="token keyword">const</span> _Key<span class="token punctuation">,</span> _Tp<span class="token operator">></span> <span class="token operator">></span> <span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">unordered_map</span><span class="token punctuation">{</span>    <span class="token keyword">typedef</span> __umap_hashtable<span class="token operator">&lt;</span>_Key<span class="token punctuation">,</span> _Tp<span class="token punctuation">,</span> _Hash<span class="token punctuation">,</span> _Pred<span class="token punctuation">,</span> _Alloc<span class="token operator">></span>  _Hashtable<span class="token punctuation">;</span>    _Hashtable _M_h<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>去看底层容器的<code>__umap_hashtable</code>的声明：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">bool</span> _Cache<span class="token operator">></span><span class="token keyword">using</span> __umap_traits <span class="token operator">=</span> __detail<span class="token operator">::</span>_Hashtable_traits<span class="token operator">&lt;</span>_Cache<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token operator">></span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _Key<span class="token punctuation">,</span>    <span class="token keyword">typename</span> _Tp<span class="token punctuation">,</span>    <span class="token keyword">typename</span> _Hash <span class="token operator">=</span> hash<span class="token operator">&lt;</span>_Key<span class="token operator">></span><span class="token punctuation">,</span>    <span class="token keyword">typename</span> _Pred <span class="token operator">=</span> std<span class="token operator">::</span>equal_to<span class="token operator">&lt;</span>_Key<span class="token operator">></span><span class="token punctuation">,</span>    <span class="token keyword">typename</span> _Alloc <span class="token operator">=</span> std<span class="token operator">::</span>allocator<span class="token operator">&lt;</span>std<span class="token operator">::</span>pair<span class="token operator">&lt;</span><span class="token keyword">const</span> _Key<span class="token punctuation">,</span> _Tp<span class="token operator">></span> <span class="token operator">></span><span class="token punctuation">,</span>    <span class="token keyword">typename</span> _Tr <span class="token operator">=</span> __umap_traits<span class="token operator">&lt;</span>__cache_default<span class="token operator">&lt;</span>_Key<span class="token punctuation">,</span> _Hash<span class="token operator">></span><span class="token operator">::</span>value<span class="token operator">>></span><span class="token keyword">using</span> __umap_hashtable <span class="token operator">=</span> _Hashtable<span class="token operator">&lt;</span>_Key<span class="token punctuation">,</span> std<span class="token operator">::</span>pair<span class="token operator">&lt;</span><span class="token keyword">const</span> _Key<span class="token punctuation">,</span> _Tp<span class="token operator">></span><span class="token punctuation">,</span>_Alloc<span class="token punctuation">,</span> __detail<span class="token operator">::</span>_Select1st<span class="token punctuation">,</span>_Pred<span class="token punctuation">,</span> _Hash<span class="token punctuation">,</span>__detail<span class="token operator">::</span>_Mod_range_hashing<span class="token punctuation">,</span>__detail<span class="token operator">::</span>_Default_ranged_hash<span class="token punctuation">,</span>__detail<span class="token operator">::</span>_Prime_rehash_policy<span class="token punctuation">,</span> _Tr<span class="token operator">></span><span class="token punctuation">;</span></code></pre><p>可以得到下面结论:<br>hashtable的模板参数：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _Key<span class="token punctuation">,</span> <span class="token keyword">typename</span> _Value<span class="token punctuation">,</span> <span class="token keyword">typename</span> _Alloc<span class="token punctuation">,</span><span class="token keyword">typename</span> _ExtractKey<span class="token punctuation">,</span> <span class="token keyword">typename</span> _Equal<span class="token punctuation">,</span><span class="token keyword">typename</span> _H1<span class="token punctuation">,</span> <span class="token keyword">typename</span> _H2<span class="token punctuation">,</span> <span class="token keyword">typename</span> _Hash<span class="token punctuation">,</span><span class="token keyword">typename</span> _RehashPolicy<span class="token punctuation">,</span> <span class="token keyword">typename</span> _Traits<span class="token operator">></span></code></pre><p>默认情况下，undered_map采用：</p><ul><li>H1为hash<key></key></li><li>H2为_Mod_range_hashing</li><li>_Hash为_Default_ranged_hash</li><li>_RehashPolicy为_Prime_rehash_policy</li><li>_Traits为_Tr<br>对于最后的_Tr,非常重要，因为正是因为这个参数，才有undered_multimap。<br>具体分析看下面：</li></ul><p>_Tr如下：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">typename</span> _Tr <span class="token operator">=</span> __umap_traits<span class="token operator">&lt;</span>__cache_default<span class="token operator">&lt;</span>_Key<span class="token punctuation">,</span> _Hash<span class="token operator">></span><span class="token operator">::</span>value<span class="token operator">>></span></code></pre><p>_Tr使用了<code>__umap_traits</code>，我们继续往下看：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">bool</span> _Cache<span class="token operator">></span><span class="token keyword">using</span> __umap_traits <span class="token operator">=</span> __detail<span class="token operator">::</span>_Hashtable_traits<span class="token operator">&lt;</span>_Cache<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token operator">></span><span class="token punctuation">;</span></code></pre><p>可以对比上述两个发现<strong>umap_traits里面有一串</strong>cache_default，我们再看一下模板参数为bool类型，故可以打印出来是false还是true，经过实测，为false，表示不缓存hash code。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _Tp<span class="token punctuation">,</span> <span class="token keyword">typename</span> _Hash<span class="token operator">></span><span class="token keyword">using</span> __cache_default<span class="token operator">=</span>  __not_<span class="token operator">&lt;</span>__and_<span class="token operator">&lt;</span>__is_fast_hash<span class="token operator">&lt;</span>_Hash<span class="token operator">></span><span class="token punctuation">,</span>__detail<span class="token operator">::</span>__is_noexcept_hash<span class="token operator">&lt;</span>_Tp<span class="token punctuation">,</span> _Hash<span class="token operator">>></span><span class="token operator">></span><span class="token punctuation">;</span></code></pre><p>继续看<code>__umap_traits</code>，这个实际上是调用<code>_Hashtable_traits</code>，我们继续往下：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">bool</span> _Cache_hash_code<span class="token punctuation">,</span> <span class="token keyword">bool</span> _Constant_iterators<span class="token punctuation">,</span> <span class="token keyword">bool</span> _Unique_keys<span class="token operator">></span><span class="token keyword">struct</span> _Hashtable_traits<span class="token punctuation">{</span>    <span class="token keyword">using</span> __hash_cached <span class="token operator">=</span> __bool_constant<span class="token operator">&lt;</span>_Cache_hash_code<span class="token operator">></span><span class="token punctuation">;</span>    <span class="token keyword">using</span> __constant_iterators <span class="token operator">=</span> __bool_constant<span class="token operator">&lt;</span>_Constant_iterators<span class="token operator">></span><span class="token punctuation">;</span>    <span class="token keyword">using</span> __unique_keys <span class="token operator">=</span> __bool_constant<span class="token operator">&lt;</span>_Unique_keys<span class="token operator">></span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>看到有三个using，理解为三个typedef，依次表示：hash code缓存与否，是否是常迭代器，是否是唯一的key，再往上回头看，传递进来的是三个模板参数，分别是false,false,true，也验证了undered_map是唯一的key，那么对应的undered_multimap就是不唯一的key，最后一个参数为false。我们翻阅到相应代码如下：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">/// Base types for unordered_multimap.</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">bool</span> _Cache<span class="token operator">></span><span class="token keyword">using</span> __ummap_traits <span class="token operator">=</span> __detail<span class="token operator">::</span>_Hashtable_traits<span class="token operator">&lt;</span>_Cache<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token operator">></span><span class="token punctuation">;</span></code></pre><p>小结，在上面分析，我们知道了unordered_map与unordered_multimap的本质区别，也发现了如何在底层源码上用一个容器实现两个容器适配器！</p><h2 id="2-undered-set与unordered-multiset本质区别"><a href="#2-undered-set与unordered-multiset本质区别" class="headerlink" title="2.undered_set与unordered_multiset本质区别"></a>2.undered_set与unordered_multiset本质区别</h2><p>分析同前面一样，先看undered_set:</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">_Value</span><span class="token punctuation">,</span>    <span class="token keyword">class</span> <span class="token class-name">_Hash</span> <span class="token operator">=</span> hash<span class="token operator">&lt;</span>_Value<span class="token operator">></span><span class="token punctuation">,</span>    <span class="token keyword">class</span> <span class="token class-name">_Pred</span> <span class="token operator">=</span> std<span class="token operator">::</span>equal_to<span class="token operator">&lt;</span>_Value<span class="token operator">></span><span class="token punctuation">,</span>    <span class="token keyword">class</span> <span class="token class-name">_Alloc</span> <span class="token operator">=</span> std<span class="token operator">::</span>allocator<span class="token operator">&lt;</span>_Value<span class="token operator">></span> <span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">unordered_set</span><span class="token punctuation">{</span>    <span class="token keyword">typedef</span> __uset_hashtable<span class="token operator">&lt;</span>_Value<span class="token punctuation">,</span> _Hash<span class="token punctuation">,</span> _Pred<span class="token punctuation">,</span> _Alloc<span class="token operator">></span>  _Hashtable<span class="token punctuation">;</span>    _Hashtable _M_h<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">bool</span> _Cache<span class="token operator">></span><span class="token keyword">using</span> __uset_traits <span class="token operator">=</span> __detail<span class="token operator">::</span>_Hashtable_traits<span class="token operator">&lt;</span>_Cache<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token operator">></span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _Value<span class="token punctuation">,</span>    <span class="token keyword">typename</span> _Hash <span class="token operator">=</span> hash<span class="token operator">&lt;</span>_Value<span class="token operator">></span><span class="token punctuation">,</span>    <span class="token keyword">typename</span> _Pred <span class="token operator">=</span> std<span class="token operator">::</span>equal_to<span class="token operator">&lt;</span>_Value<span class="token operator">></span><span class="token punctuation">,</span>    <span class="token keyword">typename</span> _Alloc <span class="token operator">=</span> std<span class="token operator">::</span>allocator<span class="token operator">&lt;</span>_Value<span class="token operator">></span><span class="token punctuation">,</span>    <span class="token keyword">typename</span> _Tr <span class="token operator">=</span> __uset_traits<span class="token operator">&lt;</span>__cache_default<span class="token operator">&lt;</span>_Value<span class="token punctuation">,</span> _Hash<span class="token operator">></span><span class="token operator">::</span>value<span class="token operator">>></span><span class="token keyword">using</span> __uset_hashtable <span class="token operator">=</span> _Hashtable<span class="token operator">&lt;</span>_Value<span class="token punctuation">,</span> _Value<span class="token punctuation">,</span> _Alloc<span class="token punctuation">,</span>                __detail<span class="token operator">::</span>_Identity<span class="token punctuation">,</span> _Pred<span class="token punctuation">,</span> _Hash<span class="token punctuation">,</span>                __detail<span class="token operator">::</span>_Mod_range_hashing<span class="token punctuation">,</span>                __detail<span class="token operator">::</span>_Default_ranged_hash<span class="token punctuation">,</span>                __detail<span class="token operator">::</span>_Prime_rehash_policy<span class="token punctuation">,</span> _Tr<span class="token operator">></span><span class="token punctuation">;</span></code></pre><p>可以看到传递给<code>_Hashtable_traits</code>的是false,true,true。对于undered_set来说使用的是const iterator与唯一的key,我们再看一下unordered_multiset：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">bool</span> _Cache<span class="token operator">></span><span class="token keyword">using</span> __umset_traits <span class="token operator">=</span> __detail<span class="token operator">::</span>_Hashtable_traits<span class="token operator">&lt;</span>_Cache<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token operator">></span><span class="token punctuation">;</span></code></pre><p>再将两者对比一下，本质就是undered_set不允许key重复，而undered_multiset允许key重复。</p><h2 id="3-三大结论"><a href="#3-三大结论" class="headerlink" title="3.三大结论"></a>3.三大结论</h2><p>现在，我们有了前面基础，依次列出前面四个容器适配器：</p><p>(1) undered_map</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">bool</span> _Cache<span class="token operator">></span><span class="token keyword">using</span> __umap_traits <span class="token operator">=</span> __detail<span class="token operator">::</span>_Hashtable_traits<span class="token operator">&lt;</span>_Cache<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token operator">></span><span class="token punctuation">;</span></code></pre><p>(2) undered_multimap</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">bool</span> _Cache<span class="token operator">></span><span class="token keyword">using</span> __umap_traits <span class="token operator">=</span> __detail<span class="token operator">::</span>_Hashtable_traits<span class="token operator">&lt;</span>_Cache<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token operator">></span><span class="token punctuation">;</span></code></pre><p>(3) undered_set</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">bool</span> _Cache<span class="token operator">></span><span class="token keyword">using</span> __uset_traits <span class="token operator">=</span> __detail<span class="token operator">::</span>_Hashtable_traits<span class="token operator">&lt;</span>_Cache<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token operator">></span><span class="token punctuation">;</span></code></pre><p>(4) undered_set</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">bool</span> _Cache<span class="token operator">></span><span class="token keyword">using</span> __uset_traits <span class="token operator">=</span> __detail<span class="token operator">::</span>_Hashtable_traits<span class="token operator">&lt;</span>_Cache<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token operator">></span><span class="token punctuation">;</span></code></pre><p>对比后，得出</p><ul><li>结论1：undered_map与undered_set不允许key重复,而带multi的则允许key重复；</li><li>结论2：undered_map与undered_multimap采用的迭代器是iterator，而undered_set与undered_multiset采用的迭代器是const_iterator。</li><li>结论3：undered_map与undered_multimap的key是key，value是key+value；而undered_set与undered_multiset的key是Value，Value也是Key。</li></ul><p>最后一个结论对比看下面(我们看传递给hashtable的第一与第二个参数)：</p><p>undered_map与undered_multimap：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">using</span> __umap_hashtable <span class="token operator">=</span> _Hashtable<span class="token operator">&lt;</span>_Key<span class="token punctuation">,</span> std<span class="token operator">::</span>pair<span class="token operator">&lt;</span><span class="token keyword">const</span> _Key<span class="token punctuation">,</span> _Tp<span class="token operator">></span><span class="token punctuation">,</span>_Alloc<span class="token punctuation">,</span> __detail<span class="token operator">::</span>_Select1st<span class="token punctuation">,</span>_Pred<span class="token punctuation">,</span> _Hash<span class="token punctuation">,</span>__detail<span class="token operator">::</span>_Mod_range_hashing<span class="token punctuation">,</span>__detail<span class="token operator">::</span>_Default_ranged_hash<span class="token punctuation">,</span>__detail<span class="token operator">::</span>_Prime_rehash_policy<span class="token punctuation">,</span> _Tr<span class="token operator">></span><span class="token punctuation">;</span></code></pre><p>undered_set与undered_multiset：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _Value<span class="token punctuation">,</span><span class="token keyword">typename</span> _Hash <span class="token operator">=</span> hash<span class="token operator">&lt;</span>_Value<span class="token operator">></span><span class="token punctuation">,</span><span class="token keyword">typename</span> _Pred <span class="token operator">=</span> std<span class="token operator">::</span>equal_to<span class="token operator">&lt;</span>_Value<span class="token operator">></span><span class="token punctuation">,</span><span class="token keyword">typename</span> _Alloc <span class="token operator">=</span> std<span class="token operator">::</span>allocator<span class="token operator">&lt;</span>_Value<span class="token operator">></span><span class="token punctuation">,</span><span class="token keyword">typename</span> _Tr <span class="token operator">=</span> __uset_traits<span class="token operator">&lt;</span>__cache_default<span class="token operator">&lt;</span>_Value<span class="token punctuation">,</span> _Hash<span class="token operator">></span><span class="token operator">::</span>value<span class="token operator">>></span><span class="token keyword">using</span> __uset_hashtable <span class="token operator">=</span> _Hashtable<span class="token operator">&lt;</span>_Value<span class="token punctuation">,</span> _Value<span class="token punctuation">,</span> _Alloc<span class="token punctuation">,</span>__detail<span class="token operator">::</span>_Identity<span class="token punctuation">,</span> _Pred<span class="token punctuation">,</span> _Hash<span class="token punctuation">,</span>__detail<span class="token operator">::</span>_Mod_range_hashing<span class="token punctuation">,</span>__detail<span class="token operator">::</span>_Default_ranged_hash<span class="token punctuation">,</span>__detail<span class="token operator">::</span>_Prime_rehash_policy<span class="token punctuation">,</span> _Tr<span class="token operator">></span><span class="token punctuation">;</span></code></pre><h2 id="4-undered-map重要函数"><a href="#4-undered-map重要函数" class="headerlink" title="4.undered_map重要函数"></a>4.undered_map重要函数</h2><blockquote><p>初始化</p></blockquote><p>可以在下面的构造函数中看到undered_map的默认桶数为10。</p><p>在undered_map的底层默认采用hasher(),也就是H1,也就是std::hash</p><pre class=" language-cpp"><code class="language-cpp"><span class="token function">unordered_map</span><span class="token punctuation">(</span>size_type __n <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">,</span>    <span class="token keyword">const</span> hasher<span class="token operator">&amp;</span> __hf <span class="token operator">=</span> <span class="token function">hasher</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">const</span> key_equal<span class="token operator">&amp;</span> __eql <span class="token operator">=</span> <span class="token function">key_equal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">const</span> allocator_type<span class="token operator">&amp;</span> __a <span class="token operator">=</span> <span class="token function">allocator_type</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token function">_M_h</span><span class="token punctuation">(</span>__n<span class="token punctuation">,</span> __hf<span class="token punctuation">,</span> __eql<span class="token punctuation">,</span> __a<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token punctuation">}</span></code></pre><p>下面测试是否采用默认的hash：</p><pre class=" language-cpp"><code class="language-cpp">unordered_map<span class="token operator">&lt;</span>string<span class="token punctuation">,</span><span class="token keyword">int</span><span class="token operator">></span> um<span class="token punctuation">;</span>hash<span class="token operator">&lt;</span>string<span class="token operator">></span> h<span class="token punctuation">;</span>cout<span class="token operator">&lt;&lt;</span>um<span class="token punctuation">.</span><span class="token function">hash_function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token string">"hhhhhawq"</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>cout<span class="token operator">&lt;&lt;</span><span class="token function">h</span><span class="token punctuation">(</span><span class="token string">"hhhhhawq"</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span></code></pre><p>输出：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token number">9074142923776869151</span><span class="token number">9074142923776869151</span></code></pre><p>进一步验证了采用默认的hash。</p><blockquote><p>是否空、大小、最大大小</p></blockquote><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">bool</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">noexcept</span><span class="token punctuation">{</span> <span class="token keyword">return</span> _M_h<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token comment" spellcheck="true">///  Returns the size of the %unordered_map.</span>size_type<span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">noexcept</span><span class="token punctuation">{</span> <span class="token keyword">return</span> _M_h<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token comment" spellcheck="true">///  Returns the maximum size of the %unordered_map.</span>size_type<span class="token function">max_size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">noexcept</span><span class="token punctuation">{</span> <span class="token keyword">return</span> _M_h<span class="token punctuation">.</span><span class="token function">max_size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre><blockquote><p>begin与end</p></blockquote><pre class=" language-cpp"><code class="language-cpp">iterator<span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">{</span> <span class="token keyword">return</span> _M_h<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>iterator<span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">{</span> <span class="token keyword">return</span> _M_h<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre><blockquote><p>insert<br>五种插入方式</p></blockquote><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// value</span>std<span class="token operator">::</span>pair<span class="token operator">&lt;</span>iterator<span class="token punctuation">,</span> <span class="token keyword">bool</span><span class="token operator">></span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token keyword">const</span> value_type<span class="token operator">&amp;</span> __x<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">return</span> _M_h<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>__x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token comment" spellcheck="true">// pair </span>std<span class="token operator">::</span>pair<span class="token operator">&lt;</span>iterator<span class="token punctuation">,</span> <span class="token keyword">bool</span><span class="token operator">></span><span class="token function">insert</span><span class="token punctuation">(</span>_Pair<span class="token operator">&amp;&amp;</span> __x<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">return</span> _M_h<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>_Pair<span class="token operator">></span><span class="token punctuation">(</span>__x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token comment" spellcheck="true">// iterator+value</span>iterator<span class="token function">insert</span><span class="token punctuation">(</span>const_iterator __hint<span class="token punctuation">,</span> <span class="token keyword">const</span> value_type<span class="token operator">&amp;</span> __x<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">return</span> _M_h<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>__hint<span class="token punctuation">,</span> __x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token comment" spellcheck="true">// first到last范围插入</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _InputIterator<span class="token operator">></span><span class="token keyword">void</span><span class="token function">insert</span><span class="token punctuation">(</span>_InputIterator __first<span class="token punctuation">,</span> _InputIterator __last<span class="token punctuation">)</span><span class="token punctuation">{</span> _M_h<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>__first<span class="token punctuation">,</span> __last<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 初始化列表插入</span><span class="token keyword">void</span><span class="token function">insert</span><span class="token punctuation">(</span>initializer_list<span class="token operator">&lt;</span>value_type<span class="token operator">></span> __l<span class="token punctuation">)</span><span class="token punctuation">{</span> _M_h<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>__l<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre><blockquote><p>删除</p></blockquote><p>三种删除方式</p><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// iterator</span>iterator<span class="token function">erase</span><span class="token punctuation">(</span>iterator __position<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">return</span> _M_h<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>__position<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token comment" spellcheck="true">// key</span>size_type<span class="token function">erase</span><span class="token punctuation">(</span><span class="token keyword">const</span> key_type<span class="token operator">&amp;</span> __x<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">return</span> _M_h<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>__x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token comment" spellcheck="true">// first到last范围</span>iterator<span class="token function">erase</span><span class="token punctuation">(</span>const_iterator __first<span class="token punctuation">,</span> const_iterator __last<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">return</span> _M_h<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>__first<span class="token punctuation">,</span> __last<span class="token punctuation">)</span><span class="token punctuation">;</span> </code></pre><blockquote><p>清除</p></blockquote><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">void</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">{</span> _M_h<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre><blockquote><p>hash_function</p></blockquote><p>得到该undered_map的hash_function</p><pre class=" language-cpp"><code class="language-cpp">hasher<span class="token function">hash_function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">{</span> <span class="token keyword">return</span> _M_h<span class="token punctuation">.</span><span class="token function">hash_function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre><p>使用：</p><pre class=" language-cpp"><code class="language-cpp">unordered_map<span class="token operator">&lt;</span>string<span class="token punctuation">,</span><span class="token keyword">int</span><span class="token operator">></span> um<span class="token punctuation">;</span>cout<span class="token operator">&lt;&lt;</span>um<span class="token punctuation">.</span><span class="token function">hash_function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token string">"hhhhhawq"</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//传递的内容要与上面key类型一致。</span></code></pre><blockquote><p>key_eq<br>key_eq返回的是std::equal_to<br>使用如下：</p><pre class=" language-cpp"><code class="language-cpp">unordered_map<span class="token operator">&lt;</span>string<span class="token punctuation">,</span><span class="token keyword">int</span><span class="token operator">></span> um<span class="token punctuation">;</span>cout<span class="token operator">&lt;&lt;</span>um<span class="token punctuation">.</span><span class="token function">key_eq</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token string">"1"</span><span class="token punctuation">,</span><span class="token string">"2"</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span></code></pre><p>查找与获取value</p></blockquote><pre class=" language-cpp"><code class="language-cpp">iterator<span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">const</span> key_type<span class="token operator">&amp;</span> __x<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">return</span> _M_h<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>__x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>mapped_type<span class="token operator">&amp;</span><span class="token keyword">operator</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">const</span> key_type<span class="token operator">&amp;</span> __k<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">return</span> _M_h<span class="token punctuation">[</span>__k<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>mapped_type<span class="token operator">&amp;</span><span class="token function">at</span><span class="token punctuation">(</span><span class="token keyword">const</span> key_type<span class="token operator">&amp;</span> __k<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">return</span> _M_h<span class="token punctuation">.</span><span class="token function">at</span><span class="token punctuation">(</span>__k<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre><p>除了这些函数还有获取桶，最大桶数、加载因子、rehash等等，就是没有排序，因为hashtable没有提供排序功能。hashtable在查找、删除和插入节点是常数时间，优于RB-Tree红黑树。</p><p>同理，unordered_set、unordered_multiset、unordered_multimap与undered_map一样的函数，所以就不阐述了。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> STL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ STL源码剖析之哈希表</title>
      <link href="/2019/10/24/hashtable/"/>
      <url>/2019/10/24/hashtable/</url>
      
        <content type="html"><![CDATA[<h1 id="C-STL源码剖析之哈希表"><a href="#C-STL源码剖析之哈希表" class="headerlink" title="C++ STL源码剖析之哈希表"></a>C++ STL源码剖析之哈希表</h1><h2 id="0-导语"><a href="#0-导语" class="headerlink" title="0.导语"></a>0.导语</h2><p>哈希表，是作为<code>unordered_map</code>与<code>undered_set</code>等的底层容器，自gcc2.9后源码量大增！</p><p>这次阅读的代码仍旧是gcc4.9.1，代码量非常多，就不全部展开，重点研究底层哈希的艺术与技术，似乎这两个词语很押韵哦，哈哈，进入正文～</p><h2 id="1-Hashtable初识"><a href="#1-Hashtable初识" class="headerlink" title="1.Hashtable初识"></a>1.Hashtable初识</h2><p>先来看一眼Hashtable源码：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _Key<span class="token punctuation">,</span> <span class="token keyword">typename</span> _Value<span class="token punctuation">,</span> <span class="token keyword">typename</span> _Alloc<span class="token punctuation">,</span>    <span class="token keyword">typename</span> _ExtractKey<span class="token punctuation">,</span> <span class="token keyword">typename</span> _Equal<span class="token punctuation">,</span>    <span class="token keyword">typename</span> _H1<span class="token punctuation">,</span> <span class="token keyword">typename</span> _H2<span class="token punctuation">,</span> <span class="token keyword">typename</span> _Hash<span class="token punctuation">,</span>    <span class="token keyword">typename</span> _RehashPolicy<span class="token punctuation">,</span> <span class="token keyword">typename</span> _Traits<span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">_Hashtable</span><span class="token operator">:</span> 　<span class="token keyword">public</span> __detail<span class="token operator">::</span>_Hashtable_base<span class="token operator">&lt;</span>_Key<span class="token punctuation">,</span> _Value<span class="token punctuation">,</span> _ExtractKey<span class="token punctuation">,</span> _Equal<span class="token punctuation">,</span>    <span class="token keyword">public</span> __detail<span class="token operator">::</span>_Map_base<span class="token operator">&lt;</span>_Key<span class="token punctuation">,</span> _Value<span class="token punctuation">,</span> _Alloc<span class="token punctuation">,</span> _ExtractKey<span class="token punctuation">,</span> _Equal<span class="token punctuation">,</span>  _H1<span class="token punctuation">,</span> _H2<span class="token punctuation">,</span> _Hash<span class="token punctuation">,</span> _RehashPolicy<span class="token punctuation">,</span> _Traits<span class="token operator">></span><span class="token punctuation">,</span>    <span class="token keyword">public</span> __detail<span class="token operator">::</span>_Insert<span class="token operator">&lt;</span>_Key<span class="token punctuation">,</span> _Value<span class="token punctuation">,</span> _Alloc<span class="token punctuation">,</span> _ExtractKey<span class="token punctuation">,</span> _Equal<span class="token punctuation">,</span> _H1<span class="token punctuation">,</span> _H2<span class="token punctuation">,</span> _Hash<span class="token punctuation">,</span> _RehashPolicy<span class="token punctuation">,</span> _Traits<span class="token operator">></span><span class="token punctuation">,</span>    <span class="token keyword">public</span> __detail<span class="token operator">::</span>_Rehash_base<span class="token operator">&lt;</span>_Key<span class="token punctuation">,</span> _Value<span class="token punctuation">,</span> _Alloc<span class="token punctuation">,</span> _ExtractKey<span class="token punctuation">,</span> _Equal<span class="token punctuation">,</span>_H1<span class="token punctuation">,</span> _H2<span class="token punctuation">,</span> _Hash<span class="token punctuation">,</span> _RehashPolicy<span class="token punctuation">,</span> _Traits<span class="token operator">></span><span class="token punctuation">,</span>    <span class="token keyword">public</span> __detail<span class="token operator">::</span>_Equality<span class="token operator">&lt;</span>_Key<span class="token punctuation">,</span> _Value<span class="token punctuation">,</span> _Alloc<span class="token punctuation">,</span> _ExtractKey<span class="token punctuation">,</span> _Equal<span class="token punctuation">,</span>_H1<span class="token punctuation">,</span> _H2<span class="token punctuation">,</span> _Hash<span class="token punctuation">,</span> _RehashPolicy<span class="token punctuation">,</span> _Traits<span class="token operator">></span><span class="token punctuation">,</span>    <span class="token keyword">private</span> __detail<span class="token operator">::</span>_Hashtable_alloc<span class="token operator">&lt;</span><span class="token keyword">typename</span> __alloctr_rebind<span class="token operator">&lt;</span>_Alloc<span class="token punctuation">,</span>__detail<span class="token operator">::</span>_Hash_node<span class="token operator">&lt;</span>_Value<span class="token punctuation">,</span>_Traits<span class="token operator">::</span>__hash_cached<span class="token operator">::</span>value<span class="token operator">></span> <span class="token operator">></span><span class="token operator">::</span>__type<span class="token operator">></span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>没学过类模板的一脸懵逼，数一下模板参数都晕死。。。</p><p>还有它的继承，一下子整出这么多父亲来。。。</p><p>下面就来一一分析它的父亲，然后再回到哈希表。</p><h2 id="2-Hashtable-base"><a href="#2-Hashtable-base" class="headerlink" title="2._Hashtable_base"></a>2._Hashtable_base</h2><p>其中注释中如下：</p><blockquote><p>Helper class adding management of _Equal functor to _Hash_code_base type.</p></blockquote><p>帮助程序类，将仿函数_Equal的管理添加到_Hash_code_base中。</p><p>对比代码就可以看出来是啥意思了：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _Key<span class="token punctuation">,</span> <span class="token keyword">typename</span> _Value<span class="token punctuation">,</span>    <span class="token keyword">typename</span> _ExtractKey<span class="token punctuation">,</span> <span class="token keyword">typename</span> _Equal<span class="token punctuation">,</span>    <span class="token keyword">typename</span> _H1<span class="token punctuation">,</span> <span class="token keyword">typename</span> _H2<span class="token punctuation">,</span> <span class="token keyword">typename</span> _Hash<span class="token punctuation">,</span> <span class="token keyword">typename</span> _Traits<span class="token operator">></span><span class="token keyword">struct</span> _Hashtable_base<span class="token operator">:</span> <span class="token keyword">public</span> _Hash_code_base<span class="token operator">&lt;</span>_Key<span class="token punctuation">,</span> _Value<span class="token punctuation">,</span> _ExtractKey<span class="token punctuation">,</span> _H1<span class="token punctuation">,</span> _H2<span class="token punctuation">,</span> _Hash<span class="token punctuation">,</span> _Traits<span class="token operator">::</span>__hash_cached<span class="token operator">::</span>value<span class="token operator">></span><span class="token punctuation">,</span><span class="token keyword">private</span> _Hashtable_ebo_helper<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">,</span> _Equal<span class="token operator">></span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>对比一下<code>_Hash_code_base</code>与<code>_Hashtable_base</code>，两者就差一个<code>_Equal</code>，据此这句话解释完毕。</p><p>它的基类又有两个分别是：</p><pre class=" language-cpp"><code class="language-cpp">__detail<span class="token operator">::</span>_Hash_code_base__detail<span class="token operator">::</span>_Hashtable_ebo_helper</code></pre><p>我们继续追踪这两个类！</p><h3 id="2-1-Hash-code-base"><a href="#2-1-Hash-code-base" class="headerlink" title="2.1 _Hash_code_base"></a>2.1 _Hash_code_base</h3><p>这个类最后一个<code>__cache_hash_code</code>表示是否缓存hash code。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _Key<span class="token punctuation">,</span> <span class="token keyword">typename</span> _Value<span class="token punctuation">,</span> <span class="token keyword">typename</span> _ExtractKey<span class="token punctuation">,</span><span class="token keyword">typename</span> _H1<span class="token punctuation">,</span> <span class="token keyword">typename</span> _H2<span class="token punctuation">,</span> <span class="token keyword">typename</span> _Hash<span class="token punctuation">,</span><span class="token keyword">bool</span> __cache_hash_code<span class="token operator">></span><span class="token keyword">struct</span> _Hash_code_base<span class="token punctuation">;</span></code></pre><p>根据是否缓存，得到其偏特化版本：</p><ul><li>使用范围哈希(实际上就是我们通常说的除留余数法)，不缓存hash code。</li></ul><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _Key<span class="token punctuation">,</span> <span class="token keyword">typename</span> _Value<span class="token punctuation">,</span> <span class="token keyword">typename</span> _ExtractKey<span class="token punctuation">,</span><span class="token keyword">typename</span> _H1<span class="token punctuation">,</span> <span class="token keyword">typename</span> _H2<span class="token punctuation">,</span> <span class="token keyword">typename</span> _Hash<span class="token operator">></span><span class="token keyword">struct</span> _Hash_code_base<span class="token operator">&lt;</span>_Key<span class="token punctuation">,</span> _Value<span class="token punctuation">,</span> _ExtractKey<span class="token punctuation">,</span> _H1<span class="token punctuation">,</span> _H2<span class="token punctuation">,</span> _Hash<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token operator">></span><span class="token operator">:</span> <span class="token keyword">private</span> _Hashtable_ebo_helper<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">,</span> _ExtractKey<span class="token operator">></span><span class="token punctuation">,</span><span class="token keyword">private</span> _Hashtable_ebo_helper<span class="token operator">&lt;</span><span class="token number">1</span><span class="token punctuation">,</span> _Hash<span class="token operator">></span><span class="token punctuation">}</span></code></pre><ul><li>使用范围哈希(实际上就是我们通常说的除留余数法)，缓存hash code。</li></ul><p>对于这个偏特化，缓存是没有必要的，所以代码中只是声明，并没有定义！</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _Key<span class="token punctuation">,</span> <span class="token keyword">typename</span> _Value<span class="token punctuation">,</span> <span class="token keyword">typename</span> _ExtractKey<span class="token punctuation">,</span><span class="token keyword">typename</span> _H1<span class="token punctuation">,</span> <span class="token keyword">typename</span> _H2<span class="token punctuation">,</span> <span class="token keyword">typename</span> _Hash<span class="token operator">></span><span class="token keyword">struct</span> _Hash_code_base<span class="token operator">&lt;</span>_Key<span class="token punctuation">,</span> _Value<span class="token punctuation">,</span> _ExtractKey<span class="token punctuation">,</span> _H1<span class="token punctuation">,</span> _H2<span class="token punctuation">,</span> _Hash<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token operator">></span><span class="token punctuation">;</span></code></pre><ul><li>有哈希函数以及范围哈希函数，不缓存hash code。</li></ul><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _Key<span class="token punctuation">,</span> <span class="token keyword">typename</span> _Value<span class="token punctuation">,</span> <span class="token keyword">typename</span> _ExtractKey<span class="token punctuation">,</span><span class="token keyword">typename</span> _H1<span class="token punctuation">,</span> <span class="token keyword">typename</span> _H2<span class="token operator">></span><span class="token keyword">struct</span> _Hash_code_base<span class="token operator">&lt;</span>_Key<span class="token punctuation">,</span> _Value<span class="token punctuation">,</span> _ExtractKey<span class="token punctuation">,</span> _H1<span class="token punctuation">,</span> _H2<span class="token punctuation">,</span>_Default_ranged_hash<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token operator">></span><span class="token operator">:</span> <span class="token keyword">private</span> _Hashtable_ebo_helper<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">,</span> _ExtractKey<span class="token operator">></span><span class="token punctuation">,</span><span class="token keyword">private</span> _Hashtable_ebo_helper<span class="token operator">&lt;</span><span class="token number">1</span><span class="token punctuation">,</span> _H1<span class="token operator">></span><span class="token punctuation">,</span><span class="token keyword">private</span> _Hashtable_ebo_helper<span class="token operator">&lt;</span><span class="token number">2</span><span class="token punctuation">,</span> _H2<span class="token operator">></span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><ul><li>上述的缓存hash code</li></ul><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _Key<span class="token punctuation">,</span> <span class="token keyword">typename</span> _Value<span class="token punctuation">,</span> <span class="token keyword">typename</span> _ExtractKey<span class="token punctuation">,</span>    <span class="token keyword">typename</span> _H1<span class="token punctuation">,</span> <span class="token keyword">typename</span> _H2<span class="token operator">></span><span class="token keyword">struct</span> _Hash_code_base<span class="token operator">&lt;</span>_Key<span class="token punctuation">,</span> _Value<span class="token punctuation">,</span> _ExtractKey<span class="token punctuation">,</span> _H1<span class="token punctuation">,</span> _H2<span class="token punctuation">,</span>            _Default_ranged_hash<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token operator">></span><span class="token operator">:</span> <span class="token keyword">private</span> _Hashtable_ebo_helper<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">,</span> _ExtractKey<span class="token operator">></span><span class="token punctuation">,</span>    <span class="token keyword">private</span> _Hashtable_ebo_helper<span class="token operator">&lt;</span><span class="token number">1</span><span class="token punctuation">,</span> _H1<span class="token operator">></span><span class="token punctuation">,</span>    <span class="token keyword">private</span> _Hashtable_ebo_helper<span class="token operator">&lt;</span><span class="token number">2</span><span class="token punctuation">,</span> _H2<span class="token operator">></span><span class="token punctuation">{</span></code></pre><p>上述_H1与_H2大家肯定很迷惑，下面来看一下：</p><p>（1） Default range hashing function(默认范围哈希函数)</p><pre class=" language-cpp"><code class="language-cpp">h1<span class="token operator">=</span>hash<span class="token operator">&lt;</span>key<span class="token operator">></span></code></pre><p>下面这个就是：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token function">h2</span><span class="token punctuation">(</span><span class="token function">h1</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span>N<span class="token punctuation">)</span><span class="token operator">=</span><span class="token function">h1</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token operator">%</span>N</code></pre><p>具体可以在后面看到阐述。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> _Mod_range_hashing<span class="token punctuation">{</span>    <span class="token keyword">typedef</span> std<span class="token operator">::</span>size_t first_argument_type<span class="token punctuation">;</span>    <span class="token keyword">typedef</span> std<span class="token operator">::</span>size_t second_argument_type<span class="token punctuation">;</span>    <span class="token keyword">typedef</span> std<span class="token operator">::</span>size_t result_type<span class="token punctuation">;</span>    result_type    <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>first_argument_type __num<span class="token punctuation">,</span>            second_argument_type __den<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">noexcept</span>    <span class="token punctuation">{</span> <span class="token keyword">return</span> __num <span class="token operator">%</span> __den<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>别看使用一个struct定义的，大家会以为是类，实际上重载了()操作符，就是个仿函数。</p><p>上面对应到哈希表数据结构中，就是大家知道的散列函数：<strong>除留余数法</strong>。</p><pre><code>f(__num) = __num mod __den(__den&lt;=__num)</code></pre><p>其次，是<code>_Default_ranged_hash</code>:</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> _Default_ranged_hash <span class="token punctuation">{</span> <span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>这个只是作为标记用，默认已经计算的范围哈希函数( Default ranged hash function):</p><pre><code>h(k, N) = h2(h1(k), N),</code></pre><p>所以到这，底层的哈希表的散列函数很明显了，默认就是这样的。<br>而刚才提到的标记就是由于类型H1与H2的对象组合成H，会消耗额外的拷贝操作，因此这里引出了这个标记。</p><p>至此，上面提到的_H1与_H2讲解完毕，就是分别对应上述两个函数。</p><p>（2） rehash操作</p><p>紧接着，还有个比较重要的称为rehash，相信大家很清楚rehash，当散列表的冲突到达一定程度，那么就需要重新将key放到合适位置，而哈希表的底层源码就是这样做的，这里封装成了一个rehash policy：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> _Prime_rehash_policy<span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">//...</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>rehash操作中提到：桶的大小(bucket size) 默认通常是最小的素数，从而保证装载因子(load factor 容器当前元素数量与桶数量之比。)足够小。装载因子用来衡量哈希表满的程度，最大加载因子默认值为1.0.</p><pre class=" language-cpp"><code class="language-cpp"><span class="token function">_Prime_rehash_policy</span><span class="token punctuation">(</span><span class="token keyword">float</span> __z <span class="token operator">=</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token function">_M_max_load_factor</span><span class="token punctuation">(</span>__z<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">_M_next_resize</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span><span class="token operator">></span> rehash计算下一个素数桶</code></pre><p>当哈希冲突的时候，怎么rehash呢？</p><pre class=" language-c++"><code class="language-c++"> inline std::size_t_Prime_rehash_policy::_M_next_bkt(std::size_t __n) const{    const unsigned long* __p = std::lower_bound(__prime_list, __prime_list + _S_n_primes, __n);    _M_next_resize =         static_cast<std::size_t>(__builtin_ceil(*__p * _M_max_load_factor));return *__p;}</code></pre><p>当发生哈希冲突的时候，该函数会返回一个不小于n的素数来作为一下个桶。</p><blockquote><p>素数表</p></blockquote><p>怎么查找素数呢？<br>发现上面有个<code>__prime_list</code>,于是取查找，在<code>libstdc++v3/src/shared/hashtable-aux.cc</code>中找到了所有的素数表。<br>里面总共有256+1+49或者256+49个。<br>如果sizeof(unsigned long)!=8 就是256+1+49个，否则就是256+49个。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">extern</span> <span class="token keyword">const</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> __prime_list<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token comment" spellcheck="true">// 256 + 1 or 256 + 48 + 1</span>  <span class="token punctuation">{</span>    <span class="token number">2ul</span><span class="token punctuation">,</span> <span class="token number">3ul</span><span class="token punctuation">,</span> <span class="token number">5ul</span><span class="token punctuation">,</span> <span class="token number">7ul</span><span class="token punctuation">,</span> <span class="token number">11ul</span><span class="token punctuation">,</span> <span class="token number">13ul</span><span class="token punctuation">,</span> <span class="token number">17ul</span><span class="token punctuation">,</span> <span class="token number">19ul</span><span class="token punctuation">,</span> <span class="token number">23ul</span><span class="token punctuation">,</span> <span class="token number">29ul</span><span class="token punctuation">,</span> <span class="token number">31ul</span><span class="token punctuation">,</span>    <span class="token number">37ul</span><span class="token punctuation">,</span> <span class="token number">41ul</span><span class="token punctuation">,</span> <span class="token number">43ul</span><span class="token punctuation">,</span> <span class="token number">47ul</span><span class="token punctuation">,</span> <span class="token number">53ul</span><span class="token punctuation">,</span> <span class="token number">59ul</span><span class="token punctuation">,</span> <span class="token number">61ul</span><span class="token punctuation">,</span> <span class="token number">67ul</span><span class="token punctuation">,</span> <span class="token number">71ul</span><span class="token punctuation">,</span> <span class="token number">73ul</span><span class="token punctuation">,</span> <span class="token number">79ul</span><span class="token punctuation">,</span>    <span class="token number">83ul</span><span class="token punctuation">,</span> <span class="token number">89ul</span><span class="token punctuation">,</span> <span class="token number">97ul</span><span class="token punctuation">,</span> <span class="token number">103ul</span><span class="token punctuation">,</span> <span class="token number">109ul</span><span class="token punctuation">,</span> <span class="token number">113ul</span><span class="token punctuation">,</span> <span class="token number">127ul</span><span class="token punctuation">,</span> <span class="token number">137ul</span><span class="token punctuation">,</span> <span class="token number">139ul</span><span class="token punctuation">,</span> <span class="token number">149ul</span>，    <span class="token comment" spellcheck="true">// 后面还有很多</span>  <span class="token punctuation">}</span></code></pre><p>所以一切都变得非常清晰，那就是通过lower_bound在上述表中去找第一个大于等于给定值n的素数。</p><pre><code>enum { _S_n_primes = sizeof(unsigned long) != 8 ? 256 : 256 + 48 };</code></pre><blockquote><p>计算元素对应的桶</p></blockquote><p>根据最大加载因子算出最小的桶，然后根据桶计算出对于每个元素对应的最小素数桶。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">inline</span> std<span class="token operator">::</span>size_t_Prime_rehash_policy<span class="token operator">::</span><span class="token function">_M_bkt_for_elements</span><span class="token punctuation">(</span>std<span class="token operator">::</span>size_t __n<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 获取最小的桶</span>    <span class="token keyword">const</span> <span class="token keyword">float</span> __min_bkts <span class="token operator">=</span> __n <span class="token operator">/</span> _M_max_load_factor<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 获取最小素数p</span>    <span class="token keyword">const</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token operator">*</span> __p <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">lower_bound</span><span class="token punctuation">(</span>__prime_list<span class="token punctuation">,</span> __prime_list                        <span class="token operator">+</span> _S_n_primes<span class="token punctuation">,</span> __min_bkts<span class="token punctuation">)</span><span class="token punctuation">;</span>    _M_next_resize <span class="token operator">=</span>        <span class="token keyword">static_cast</span><span class="token operator">&lt;</span>std<span class="token operator">::</span>size_t<span class="token operator">></span><span class="token punctuation">(</span><span class="token function">__builtin_ceil</span><span class="token punctuation">(</span><span class="token operator">*</span>__p <span class="token operator">*</span> _M_max_load_factor<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token operator">*</span>__p<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>_Hashtable_ebo_helper就是前面学习过的EBO空基类 </p><p><code>_Map_base</code>主要是通过偏特化，实现重载操作符<code>[]</code>与<code>at</code>。</p><p>｀_Insert｀主要完成插入相关。</p><p>｀_Rehash_base｀主要完成上述rehash中的最大加载因子值的传递。</p><p>｀_Equality_base｀主要是为类<code>_Equality</code>提供公共类型与函数。</p><p>到现在为止，上述的<code>_Hashtable</code>继承的所有类都阐述完毕。</p><h2 id="2-hashtable中链表的节点结构"><a href="#2-hashtable中链表的节点结构" class="headerlink" title="2.hashtable中链表的节点结构"></a>2.hashtable中链表的节点结构</h2><p>hash node基类，这个只包含指针声明。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> _Hash_node_base<span class="token punctuation">{</span>    _Hash_node_base<span class="token operator">*</span> _M_nxt<span class="token punctuation">;</span>    <span class="token function">_Hash_node_base</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token operator">:</span> <span class="token function">_M_nxt</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>    <span class="token function">_Hash_node_base</span><span class="token punctuation">(</span>_Hash_node_base<span class="token operator">*</span> __next<span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token operator">:</span> <span class="token function">_M_nxt</span><span class="token punctuation">(</span>__next<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>带节点值的类继承上述基类</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _Value<span class="token operator">></span><span class="token keyword">struct</span> _Hash_node_value_base <span class="token operator">:</span> _Hash_node_base<span class="token punctuation">{</span>    <span class="token keyword">typedef</span> _Value value_type<span class="token punctuation">;</span>    __gnu_cxx<span class="token operator">::</span>__aligned_buffer<span class="token operator">&lt;</span>_Value<span class="token operator">></span> _M_storage<span class="token punctuation">;</span>    _Value<span class="token operator">*</span>    <span class="token function">_M_valptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span>    <span class="token punctuation">{</span> <span class="token keyword">return</span> _M_storage<span class="token punctuation">.</span><span class="token function">_M_ptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token keyword">const</span> _Value<span class="token operator">*</span>    <span class="token function">_M_valptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">noexcept</span>    <span class="token punctuation">{</span> <span class="token keyword">return</span> _M_storage<span class="token punctuation">.</span><span class="token function">_M_ptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    _Value<span class="token operator">&amp;</span>    <span class="token function">_M_v</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span>    <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token operator">*</span><span class="token function">_M_valptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token keyword">const</span> _Value<span class="token operator">&amp;</span>    <span class="token function">_M_v</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">noexcept</span>    <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token operator">*</span><span class="token function">_M_valptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>前面提到节点是否还有hash code，故在节点中应该得带hash code，而具体在下面中实现：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">/***  Primary template struct _Hash_node.*/</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _Value<span class="token punctuation">,</span> <span class="token keyword">bool</span> _Cache_hash_code<span class="token operator">></span><span class="token keyword">struct</span> _Hash_node<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/***  Specialization for nodes with caches, struct _Hash_node.**  Base class is __detail::_Hash_node_value_base.*/</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _Value<span class="token operator">></span><span class="token keyword">struct</span> _Hash_node<span class="token operator">&lt;</span>_Value<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token operator">></span> <span class="token operator">:</span> _Hash_node_value_base<span class="token operator">&lt;</span>_Value<span class="token operator">></span><span class="token punctuation">{</span>    std<span class="token operator">::</span>size_t  _M_hash_code<span class="token punctuation">;</span>    _Hash_node<span class="token operator">*</span>    <span class="token function">_M_next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">noexcept</span>    <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span>_Hash_node<span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_nxt<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/***  Specialization for nodes without caches, struct _Hash_node.**  Base class is __detail::_Hash_node_value_base.*/</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _Value<span class="token operator">></span><span class="token keyword">struct</span> _Hash_node<span class="token operator">&lt;</span>_Value<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token operator">></span> <span class="token operator">:</span> _Hash_node_value_base<span class="token operator">&lt;</span>_Value<span class="token operator">></span><span class="token punctuation">{</span>    _Hash_node<span class="token operator">*</span>    <span class="token function">_M_next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">noexcept</span>    <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span>_Hash_node<span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_nxt<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>到这里就很明确了，对于节点，分为包含hash code与不包含，具体是根据传递的模板参数，来调用相应的偏特化版本。</p><h2 id="3-迭代器"><a href="#3-迭代器" class="headerlink" title="3.迭代器"></a>3.迭代器</h2><p>迭代器基类显示使用using的语法，这个语法类似于typedef，后面定义就可以直接使用<code>__node_type</code>语法来定义，<code>_M_incr</code>函数完成链表下一个节点获取。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">/// Base class for node iterators.</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _Value<span class="token punctuation">,</span> <span class="token keyword">bool</span> _Cache_hash_code<span class="token operator">></span><span class="token keyword">struct</span> _Node_iterator_base<span class="token punctuation">{</span>    <span class="token keyword">using</span> __node_type <span class="token operator">=</span> _Hash_node<span class="token operator">&lt;</span>_Value<span class="token punctuation">,</span> _Cache_hash_code<span class="token operator">></span><span class="token punctuation">;</span>    __node_type<span class="token operator">*</span>  _M_cur<span class="token punctuation">;</span>    <span class="token function">_Node_iterator_base</span><span class="token punctuation">(</span>__node_type<span class="token operator">*</span> __p<span class="token punctuation">)</span> <span class="token keyword">noexcept</span>    <span class="token operator">:</span> <span class="token function">_M_cur</span><span class="token punctuation">(</span>__p<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>    <span class="token keyword">void</span>    <span class="token function">_M_incr</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span>    <span class="token punctuation">{</span> _M_cur <span class="token operator">=</span> _M_cur<span class="token operator">-</span><span class="token operator">></span><span class="token function">_M_next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>节点迭代器：对下面代码研读，学习到两点：</p><ul><li>第一：using 的使用</li><li>hashtable的迭代器属于forward_iterator</li><li>重载了++,–,*,-&gt;，这四个操作符</li></ul><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _Value<span class="token punctuation">,</span> <span class="token keyword">bool</span> __constant_iterators<span class="token punctuation">,</span> <span class="token keyword">bool</span> __cache<span class="token operator">></span><span class="token keyword">struct</span> _Node_iterator<span class="token operator">:</span> <span class="token keyword">public</span> _Node_iterator_base<span class="token operator">&lt;</span>_Value<span class="token punctuation">,</span> __cache<span class="token operator">></span><span class="token punctuation">{</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">using</span> __base_type <span class="token operator">=</span> _Node_iterator_base<span class="token operator">&lt;</span>_Value<span class="token punctuation">,</span> __cache<span class="token operator">></span><span class="token punctuation">;</span>    <span class="token keyword">using</span> __node_type <span class="token operator">=</span> <span class="token keyword">typename</span> __base_type<span class="token operator">::</span>__node_type<span class="token punctuation">;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">typedef</span> _Value                    value_type<span class="token punctuation">;</span>    <span class="token keyword">typedef</span> std<span class="token operator">::</span>ptrdiff_t                difference_type<span class="token punctuation">;</span>    <span class="token keyword">typedef</span> std<span class="token operator">::</span>forward_iterator_tag            iterator_category<span class="token punctuation">;</span>    <span class="token keyword">using</span> pointer <span class="token operator">=</span> <span class="token keyword">typename</span> std<span class="token operator">::</span>conditional<span class="token operator">&lt;</span>__constant_iterators<span class="token punctuation">,</span>                    <span class="token keyword">const</span> _Value<span class="token operator">*</span><span class="token punctuation">,</span> _Value<span class="token operator">*</span><span class="token operator">></span><span class="token operator">::</span>type<span class="token punctuation">;</span>    <span class="token keyword">using</span> reference <span class="token operator">=</span> <span class="token keyword">typename</span> std<span class="token operator">::</span>conditional<span class="token operator">&lt;</span>__constant_iterators<span class="token punctuation">,</span>                        <span class="token keyword">const</span> _Value<span class="token operator">&amp;</span><span class="token punctuation">,</span> _Value<span class="token operator">&amp;</span><span class="token operator">></span><span class="token operator">::</span>type<span class="token punctuation">;</span>    <span class="token function">_Node_iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span>    <span class="token operator">:</span> <span class="token function">__base_type</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>    <span class="token keyword">explicit</span>    <span class="token function">_Node_iterator</span><span class="token punctuation">(</span>__node_type<span class="token operator">*</span> __p<span class="token punctuation">)</span> <span class="token keyword">noexcept</span>    <span class="token operator">:</span> <span class="token function">__base_type</span><span class="token punctuation">(</span>__p<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>    reference    <span class="token keyword">operator</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">noexcept</span>    <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_cur<span class="token operator">-</span><span class="token operator">></span><span class="token function">_M_v</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    pointer    <span class="token keyword">operator</span><span class="token operator">-</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">noexcept</span>    <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_cur<span class="token operator">-</span><span class="token operator">></span><span class="token function">_M_valptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    _Node_iterator<span class="token operator">&amp;</span>    <span class="token keyword">operator</span><span class="token operator">++</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span>    <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">_M_incr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    _Node_iterator    <span class="token keyword">operator</span><span class="token operator">++</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span>    <span class="token punctuation">{</span>        _Node_iterator <span class="token function">__tmp</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">_M_incr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> __tmp<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><h2 id="4-仔细研究hashtable的重要内部结构"><a href="#4-仔细研究hashtable的重要内部结构" class="headerlink" title="4.仔细研究hashtable的重要内部结构"></a>4.仔细研究hashtable的重要内部结构</h2><p>内部结构为在每个元素中维护一个单链表, 然后在单链表上执行元素的插入、搜寻、删除等操作，每个元素被称为桶(bucket)，底层构建先采用H1计算出key的hash code，再通过除留余数法H2得到其对应的桶。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _Key<span class="token punctuation">,</span> <span class="token keyword">typename</span> _Value<span class="token punctuation">,</span> <span class="token keyword">typename</span> _Alloc<span class="token punctuation">,</span>    <span class="token keyword">typename</span> _ExtractKey<span class="token punctuation">,</span> <span class="token keyword">typename</span> _Equal<span class="token punctuation">,</span>    <span class="token keyword">typename</span> _H1<span class="token punctuation">,</span> <span class="token keyword">typename</span> _H2<span class="token punctuation">,</span> <span class="token keyword">typename</span> _Hash<span class="token punctuation">,</span>    <span class="token keyword">typename</span> _RehashPolicy<span class="token punctuation">,</span> <span class="token keyword">typename</span> _Traits<span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">_Hashtable</span><span class="token keyword">private</span><span class="token operator">:</span>    __bucket_type<span class="token operator">*</span>        _M_buckets<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//_ Hash_node_base *</span>    size_type            _M_bucket_count<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// bucket 节点个数</span>    __node_base        _M_before_begin<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// _NodeAlloc::value_type</span>    size_type            _M_element_count<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// //hashtable中list节点个数</span>    _RehashPolicy        _M_rehash_policy<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// rehash策略</span>    __bucket_type        _M_single_bucket<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 只需要一个桶用</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>hashtable的一些重要函数：</p><blockquote><p>begin函数</p></blockquote><pre class=" language-cpp"><code class="language-cpp">iterator<span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token function">iterator</span><span class="token punctuation">(</span><span class="token function">_M_begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre><p>调用<code>_M_begin</code>:</p><p>可以把<code>_M_before_begin</code>想象成一个head节点，第一个节点就是下一个节点。</p><pre class=" language-cpp"><code class="language-cpp">__node_type<span class="token operator">*</span><span class="token function">_M_begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span>__node_type<span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">(</span>_M_before_begin<span class="token punctuation">.</span>_M_nxt<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre><blockquote><p>end函数</p></blockquote><p>因为是单链表，返回最后一个即可。</p><pre class=" language-cpp"><code class="language-cpp">iterator<span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token function">iterator</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre><blockquote><p>size与empty函数</p></blockquote><pre class=" language-cpp"><code class="language-cpp">size_type<span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">noexcept</span><span class="token punctuation">{</span> <span class="token keyword">return</span> _M_element_count<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">bool</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">noexcept</span><span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre><blockquote><p>桶数量</p></blockquote><pre class=" language-cpp"><code class="language-cpp">size_type<span class="token function">bucket_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">noexcept</span><span class="token punctuation">{</span> <span class="token keyword">return</span> _M_bucket_count<span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre><blockquote><p>计算加载因子</p></blockquote><p>当前元素数量除以桶的数量</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">float</span><span class="token function">load_factor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">noexcept</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token function">bucket_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><blockquote><p>桶的index计算</p></blockquote><p>根据传递进来的key获得桶的index。</p><pre class=" language-cpp"><code class="language-cpp">size_type<span class="token function">bucket</span><span class="token punctuation">(</span><span class="token keyword">const</span> key_type<span class="token operator">&amp;</span> __k<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token function">_M_bucket_index</span><span class="token punctuation">(</span>__k<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">_M_hash_code</span><span class="token punctuation">(</span>__k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre><p>在<code>_Hash_code_base</code>中有如下实现：</p><p>而<code>_M_h1</code>返回的是<code>_H1</code>，<code>_H1</code>不知道是什么情况下，我们可以在<code>unordered_map</code>中查找到是<code>_Hash=hash&lt;_Key&gt;</code>，因此下面这个函数就是数学表达式：<br><code>h1(k)</code>来获取hash code。</p><p>返回桶的hash code。</p><pre class=" language-cpp"><code class="language-cpp">__hash_code<span class="token function">_M_hash_code</span><span class="token punctuation">(</span><span class="token keyword">const</span> _Key<span class="token operator">&amp;</span> __k<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token function">_M_h1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>__k<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre><p>返回桶的index。</p><p><code>_M_bucket_index</code>在同一文件后面找到定义：</p><pre class=" language-cpp"><code class="language-cpp">size_type<span class="token function">_M_bucket_index</span><span class="token punctuation">(</span><span class="token keyword">const</span> key_type<span class="token operator">&amp;</span> __k<span class="token punctuation">,</span> __hash_code __c<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">{</span> <span class="token keyword">return</span> __hash_code_base<span class="token operator">::</span><span class="token function">_M_bucket_index</span><span class="token punctuation">(</span>__k<span class="token punctuation">,</span> __c<span class="token punctuation">,</span> _M_bucket_count<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre><p>我们继续去<code>__hash_code_base</code>查找<code>_M_bucket_index</code>，可在<code>bits/hashtable_policy.h</code>中找到：</p><pre class=" language-cpp"><code class="language-cpp">std<span class="token operator">::</span>size_t<span class="token function">_M_bucket_index</span><span class="token punctuation">(</span><span class="token keyword">const</span> _Key<span class="token operator">&amp;</span><span class="token punctuation">,</span> __hash_code __c<span class="token punctuation">,</span>        std<span class="token operator">::</span>size_t __n<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token function">_M_h2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>__c<span class="token punctuation">,</span> __n<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre><p>同上述h1的查找，可以在<code>unordered_map</code>中查到<code>_H2</code>默认采用<code>_Mod_range_hashing</code>，再看这个源码：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> _Mod_range_hashing<span class="token punctuation">{</span>    <span class="token keyword">typedef</span> std<span class="token operator">::</span>size_t first_argument_type<span class="token punctuation">;</span>    <span class="token keyword">typedef</span> std<span class="token operator">::</span>size_t second_argument_type<span class="token punctuation">;</span>    <span class="token keyword">typedef</span> std<span class="token operator">::</span>size_t result_type<span class="token punctuation">;</span>    result_type    <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>first_argument_type __num<span class="token punctuation">,</span>            second_argument_type __den<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">noexcept</span>    <span class="token punctuation">{</span> <span class="token keyword">return</span> __num <span class="token operator">%</span> __den<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>对应数学表达式就是<code>h2(c,n)</code>。</p><p>因此上述<code>bucket</code>获取桶的index对应的数学表达式就是：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token function">h</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span><span class="token function">hash</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token function">h</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span><span class="token function">hash</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token operator">=</span><span class="token function">h</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span><span class="token function">hash</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token operator">%</span>n<span class="token punctuation">)</span></code></pre><p>实际上就是最终的：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token function">hash</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token operator">%</span>n</code></pre><p>这个就是桶的index计算。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> STL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STL设计之EBO(空基类优化)</title>
      <link href="/2019/10/20/tan-tan-stl-she-ji-zhi-ebo-you-hua/"/>
      <url>/2019/10/20/tan-tan-stl-she-ji-zhi-ebo-you-hua/</url>
      
        <content type="html"><![CDATA[<h1 id="STL设计之EBO-空基类优化"><a href="#STL设计之EBO-空基类优化" class="headerlink" title="STL设计之EBO(空基类优化)"></a>STL设计之EBO(空基类优化)</h1><h2 id="0-导语"><a href="#0-导语" class="headerlink" title="0.导语"></a>0.导语</h2><p>EBO简称Empty Base Optimization。</p><p>本节从空类开始，到STL内部，到测试，再到我们自己实现一个EBO，对比性能，最后再测试，总结。</p><h2 id="1-空类"><a href="#1-空类" class="headerlink" title="1.空类"></a>1.空类</h2><p>定义一个空类：没有成员变量，没有继承，没有数据元素的类。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Empty</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"I am Empty class"</span><span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>由于它是空的，所以这个sizeof是多少呢？</p><pre class=" language-cpp"><code class="language-cpp">std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Empty<span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//1</span></code></pre><p>结果是1，<strong>它是空的怎么不是0呢？</strong></p><p>因为空类同样可以被实例化，每个实例在内存中都有一个独一无二的地址，为了达到这个目的，编译器往往会给一个空类隐含的加一个字节，这样空类在实例化后在内存得到了独一无二的地址．所以上述大小为1.</p><p>根据上面的回答，估计大家或引出另一个问题：<strong>为什么两个不同对象的地址应该不同？</strong></p><p>现在有下面这个例子：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Empty</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"I am Empty class"</span><span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span> <span class="token operator">&lt;</span> <span class="token keyword">typename</span> T <span class="token operator">></span><span class="token keyword">bool</span> <span class="token function">isSame</span><span class="token punctuation">(</span> T <span class="token keyword">const</span> <span class="token operator">&amp;</span> t1<span class="token punctuation">,</span> T <span class="token keyword">const</span> <span class="token operator">&amp;</span> t2 <span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token operator">&amp;</span>t1 <span class="token operator">==</span> <span class="token operator">&amp;</span>t2<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>我们来测试一下：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    Empty a<span class="token punctuation">,</span>b<span class="token punctuation">;</span>    <span class="token function">assert</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isSame</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 编译通过，a与b的地址不同</span>    Empty <span class="token operator">*</span>p<span class="token operator">=</span><span class="token keyword">new</span> Empty<span class="token punctuation">;</span>    Empty <span class="token operator">*</span>q<span class="token operator">=</span><span class="token keyword">new</span> Empty<span class="token punctuation">;</span>    <span class="token function">assert</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isSame</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span>q<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 编译通过，a与b的地址不同</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>上面测试了，两个不同对象地址是不同的，考虑下面场景：</p><pre class=" language-cpp"><code class="language-cpp">Empty a<span class="token punctuation">,</span>b<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 在同一地址具有两个对象将意味着在使用指针引用它们时将无法区分这两个对象。</span>Empty <span class="token operator">*</span>p1<span class="token operator">=</span><span class="token operator">&amp;</span>a<span class="token punctuation">;</span>p1<span class="token operator">-</span><span class="token operator">></span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>此时会发现，如果a的地址与b的地址一样，那么在同一地址具有两个对象将意味着在使用指针引用它们时将无法区分这两个对象。因此两个不同对象的地址不同。</p><h2 id="2-空基类优化"><a href="#2-空基类优化" class="headerlink" title="2.空基类优化"></a>2.空基类优化</h2><p>现在对比一下下面两个用法，第一种，一个类中包含了两一个类作为成员，然后通过这个来获得被包含类的功能。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">notEbo</span>  <span class="token punctuation">{</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    Empty e<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// do other things</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>另一种直接采用继承的方式来获得基类的成员函数及其他功能等等。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">ebo</span><span class="token operator">:</span><span class="token keyword">public</span> Empty <span class="token punctuation">{</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// do other things</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>接下来做个测试：</p><pre class=" language-cpp"><code class="language-cpp">std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>notEbo<span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span>std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>ebo<span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span></code></pre><p>输出：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token number">8</span> <span class="token number">4</span></code></pre><p>第一种，会因为字节对齐，将其原来只占1字节，进行扩充到4的倍数，最后就是8字节。</p><p>对比这两个发现，第二种通过继承方式来获得基类的功能，<strong>并没有产生额外大小的优化称之为EBO(空基类优化)。</strong></p><p>接下来，我们回到STL源码中，看看其中的使用！</p><h2 id="3-STL中的EBO世界"><a href="#3-STL中的EBO世界" class="headerlink" title="3.STL中的EBO世界"></a>3.STL中的EBO世界</h2><p>不管是deque、rb_tree、list等容器，都离不开内存管理，在这几个容器中都包含了相应的内存管理，并通过<code>_xx_impl</code>来继承下面这几个类：</p><pre class=" language-cpp"><code class="language-cpp">std<span class="token operator">::</span>allocator<span class="token operator">&lt;</span>_Tp<span class="token operator">></span>__gnu_cxx<span class="token operator">::</span>bitmap_allocator<span class="token operator">&lt;</span>_Tp<span class="token operator">></span>__gnu_cxx<span class="token operator">::</span>bitmap_allocator<span class="token operator">&lt;</span>_Tp<span class="token operator">></span>__gnu_cxx<span class="token operator">::</span>__mt_alloc<span class="token operator">&lt;</span>_Tp<span class="token operator">></span>__gnu_cxx<span class="token operator">::</span>__pool_alloc<span class="token operator">&lt;</span>_Tp<span class="token operator">></span>__gnu_cxx<span class="token operator">::</span>malloc_allocator<span class="token operator">&lt;</span>_Tp<span class="token operator">></span></code></pre><p>那这和我们的EBO有啥关系呢？</p><p>实际上，上面所列出继承的基类都是内存管理的EBO(空基类)。</p><p>在每个容器中的使用都是调用每个内存管理的<code>rebind&lt;_Tp&gt;::other</code>。</p><p>例如红黑树源码结构：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">typedef</span> <span class="token keyword">typename</span> __gnu_cxx<span class="token operator">::</span>__alloc_traits<span class="token operator">&lt;</span>_Alloc<span class="token operator">></span><span class="token operator">::</span><span class="token keyword">template</span>        rebind<span class="token operator">&lt;</span>_Rb_tree_node<span class="token operator">&lt;</span>_Val<span class="token operator">></span> <span class="token operator">></span><span class="token operator">::</span>other _Node_allocator<span class="token punctuation">;</span><span class="token keyword">struct</span> _Rb_tree_impl <span class="token operator">:</span> <span class="token keyword">public</span> _Node_allocator<span class="token punctuation">{</span><span class="token comment" spellcheck="true">// do somethings</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>接下来我们看上面列出的内存管理类里面的源码结构：这里拿<code>allocator</code>举例：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _Tp<span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">allocator</span><span class="token operator">:</span> <span class="token keyword">public</span> __allocator_base<span class="token operator">&lt;</span>_Tp<span class="token operator">></span><span class="token punctuation">{</span>     <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _Tp1<span class="token operator">></span>     <span class="token keyword">struct</span> rebind <span class="token punctuation">{</span> <span class="token keyword">typedef</span> allocator<span class="token operator">&lt;</span>_Tp1<span class="token operator">></span> other<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>看到了没，通过<code>rebind&lt;_Tp&gt;::other</code>来获得传递进来的内存分配器，也就是前面提到的这些。</p><pre class=" language-cpp"><code class="language-cpp">std<span class="token operator">::</span>allocator<span class="token operator">&lt;</span>_Tp<span class="token operator">></span>__gnu_cxx<span class="token operator">::</span>bitmap_allocator<span class="token operator">&lt;</span>_Tp<span class="token operator">></span>__gnu_cxx<span class="token operator">::</span>bitmap_allocator<span class="token operator">&lt;</span>_Tp<span class="token operator">></span>__gnu_cxx<span class="token operator">::</span>__mt_alloc<span class="token operator">&lt;</span>_Tp<span class="token operator">></span>__gnu_cxx<span class="token operator">::</span>__pool_alloc<span class="token operator">&lt;</span>_Tp<span class="token operator">></span>__gnu_cxx<span class="token operator">::</span>malloc_allocator<span class="token operator">&lt;</span>_Tp<span class="token operator">></span></code></pre><p>搞懂了这些，来测试一波：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    cout<span class="token operator">&lt;&lt;</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>std<span class="token operator">::</span>allocator<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token operator">&lt;&lt;</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>std<span class="token operator">::</span>allocator<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">::</span>rebind<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">::</span>other<span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    cout<span class="token operator">&lt;&lt;</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>__gnu_cxx<span class="token operator">::</span>bitmap_allocator<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token operator">&lt;&lt;</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>__gnu_cxx<span class="token operator">::</span>bitmap_allocator<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">::</span>rebind<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">::</span>other<span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    cout<span class="token operator">&lt;&lt;</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>__gnu_cxx<span class="token operator">::</span>new_allocator<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token operator">&lt;&lt;</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>__gnu_cxx<span class="token operator">::</span>new_allocator<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">::</span>rebind<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">::</span>other<span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    cout<span class="token operator">&lt;&lt;</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>__gnu_cxx<span class="token operator">::</span>__mt_alloc<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token operator">&lt;&lt;</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>__gnu_cxx<span class="token operator">::</span>__mt_alloc<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">::</span>rebind<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">::</span>other<span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    cout<span class="token operator">&lt;&lt;</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>__gnu_cxx<span class="token operator">::</span>__pool_alloc<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token operator">&lt;&lt;</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>__gnu_cxx<span class="token operator">::</span>__pool_alloc<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">::</span>rebind<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">::</span>other<span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    cout<span class="token operator">&lt;&lt;</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>__gnu_cxx<span class="token operator">::</span>malloc_allocator<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token operator">&lt;&lt;</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>__gnu_cxx<span class="token operator">::</span>malloc_allocator<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">::</span>rebind<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">::</span>other<span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>我们来测试这些sizeof是不是1，经过测试输出如下：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token number">1</span> <span class="token number">1</span><span class="token number">1</span> <span class="token number">1</span><span class="token number">1</span> <span class="token number">1</span><span class="token number">1</span> <span class="token number">1</span><span class="token number">1</span> <span class="token number">1</span><span class="token number">1</span> <span class="token number">1</span></code></pre><p>说明内存管理的实现就是通过采用继承的方式，使用空基类优化，来达到尽量降低容器所占的大小。</p><h2 id="4-利用EBO-手动实现一个简单的内存分配与释放"><a href="#4-利用EBO-手动实现一个简单的内存分配与释放" class="headerlink" title="4.利用EBO,手动实现一个简单的内存分配与释放"></a>4.利用EBO,手动实现一个简单的内存分配与释放</h2><p>首先定义一个sizeof(class)=1的类，同STL一样，里面使用allocate与deallocate来进行内存管理。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">MyAllocator</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">allocate</span><span class="token punctuation">(</span>std<span class="token operator">::</span>size_t size<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> std<span class="token operator">::</span><span class="token function">malloc</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">deallocate</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">)</span> <span class="token punctuation">{</span>        std<span class="token operator">::</span><span class="token function">free</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>第一种方式的内存管理：嵌入一个内存管理类</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Allocator</span><span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">MyContainerNotEBO</span> <span class="token punctuation">{</span>    T <span class="token operator">*</span>data_ <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>size_t capacity_<span class="token punctuation">;</span>    Allocator allocator_<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 嵌入一个MyAllocator</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">MyContainerNotEBO</span><span class="token punctuation">(</span>std<span class="token operator">::</span>size_t capacity<span class="token punctuation">)</span>            <span class="token operator">:</span> <span class="token function">capacity_</span><span class="token punctuation">(</span>capacity<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">allocator_</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">data_</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"alloc malloc"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>        data_ <span class="token operator">=</span> <span class="token keyword">reinterpret_cast</span><span class="token operator">&lt;</span>T <span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">(</span>allocator_<span class="token punctuation">.</span><span class="token function">allocate</span><span class="token punctuation">(</span>capacity <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 分配内存</span>    <span class="token punctuation">}</span>    <span class="token operator">~</span><span class="token function">MyContainerNotEBO</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"MyContainerNotEBO free malloc"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>        allocator_<span class="token punctuation">.</span><span class="token function">deallocate</span><span class="token punctuation">(</span>data_<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>第二种方式：采用空基类优化，继承来获得内存管理功能</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Allocator</span><span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">MyContainerEBO</span>        <span class="token operator">:</span> <span class="token keyword">public</span> Allocator <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 继承一个EBO</span>    T <span class="token operator">*</span>data_ <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>size_t capacity_<span class="token punctuation">;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">MyContainerEBO</span><span class="token punctuation">(</span>std<span class="token operator">::</span>size_t capacity<span class="token punctuation">)</span>            <span class="token operator">:</span> <span class="token function">capacity_</span><span class="token punctuation">(</span>capacity<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">data_</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"alloc malloc"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>        data_ <span class="token operator">=</span> <span class="token keyword">reinterpret_cast</span><span class="token operator">&lt;</span>T <span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">allocate</span><span class="token punctuation">(</span>capacity <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token operator">~</span><span class="token function">MyContainerEBO</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"MyContainerEBO free malloc"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">deallocate</span><span class="token punctuation">(</span>data_<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>开始测试：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    MyContainerNotEBO<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> MyAllocator<span class="token operator">></span> notEbo <span class="token operator">=</span> MyContainerNotEBO<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> MyAllocator<span class="token operator">></span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Using Not EBO Test sizeof is "</span> <span class="token operator">&lt;&lt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>notEbo<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    MyContainerEBO<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> MyAllocator<span class="token operator">></span> ebo <span class="token operator">=</span> MyContainerEBO<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> MyAllocator<span class="token operator">></span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Using EBO Test sizeof is "</span> <span class="token operator">&lt;&lt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>ebo<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>测试结果：</p><pre class=" language-cpp"><code class="language-cpp">alloc mallocUsing Not EBO Test <span class="token keyword">sizeof</span> is <span class="token number">24</span>alloc mallocUsing EBO Test <span class="token keyword">sizeof</span> is <span class="token number">16</span>MyContainerEBO free mallocMyContainerNotEBO free malloc</code></pre><p>我们发现采用EBO的设计确实比嵌入设计好很多。至此，本节学习完毕。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> STL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从0到1打牢算法基础之手写一个哈希表</title>
      <link href="/2019/10/20/myhashtable/"/>
      <url>/2019/10/20/myhashtable/</url>
      
        <content type="html"><![CDATA[<h1 id="从0到1打牢算法基础之手写一个哈希表"><a href="#从0到1打牢算法基础之手写一个哈希表" class="headerlink" title="从0到1打牢算法基础之手写一个哈希表"></a>从0到1打牢算法基础之手写一个哈希表</h1><h2 id="0-导语"><a href="#0-导语" class="headerlink" title="0.导语"></a>0.导语</h2><p>目的：手写实现一个哈希表，采用拉链法构建，每个hash(key)对应的是一个红黑树。</p><p>看起来很简单，但可以学到很多东西。实现语言：C++。</p><p>为了打牢算法基础，github开了个仓库，来完成后面算法基础的应用与实现，地址：</p><blockquote><p><a href="https://github.com/Light-City/algPratice" target="_blank" rel="noopener">https://github.com/Light-City/algPratice</a></p></blockquote><h2 id="1-简易版哈希表"><a href="#1-简易版哈希表" class="headerlink" title="1.简易版哈希表"></a>1.简易版哈希表</h2><p>我们将哈希表封装在一个类中,完成遍历的定义与声明以及构造、析构的实现：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> Key<span class="token punctuation">,</span> <span class="token keyword">typename</span> Value<span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">HashTable</span> <span class="token punctuation">{</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">const</span> <span class="token keyword">static</span> <span class="token keyword">int</span> upperTol <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> <span class="token keyword">static</span> <span class="token keyword">int</span> lowerTol <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> <span class="token keyword">static</span> <span class="token keyword">int</span> initCapacity <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    map<span class="token operator">&lt;</span>Key<span class="token punctuation">,</span> Value<span class="token operator">></span> <span class="token operator">*</span><span class="token operator">*</span>hashtable<span class="token punctuation">;</span>    <span class="token keyword">int</span> M<span class="token punctuation">;</span>    <span class="token keyword">int</span> size<span class="token punctuation">;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token comment" spellcheck="true">/**     * 传参构造     * @param M     */</span>    <span class="token function">HashTable</span><span class="token punctuation">(</span><span class="token keyword">int</span> M<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">M</span><span class="token punctuation">(</span>M<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 这里的括号是为了初始化为0,这就可以不用写下面的代码,当然在后面add之类的操作,就不需要动态分配内存.</span>        <span class="token comment" spellcheck="true">// this->hashtable = new map&lt;Key, Value> *[M]();</span>        <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>hashtable <span class="token operator">=</span> <span class="token keyword">new</span> map<span class="token operator">&lt;</span>Key<span class="token punctuation">,</span> Value<span class="token operator">></span> <span class="token operator">*</span><span class="token punctuation">[</span>M<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> M<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>hashtable<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> map<span class="token operator">&lt;</span>Key<span class="token punctuation">,</span> Value<span class="token operator">></span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 默认构造     */</span>    <span class="token function">HashTable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">HashTable</span><span class="token punctuation">(</span>initCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 析构函数,释放内存     */</span>    <span class="token operator">~</span><span class="token function">HashTable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">free</span><span class="token punctuation">(</span>M<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token comment" spellcheck="true">/**     * 释放内存     * @param M     */</span>    <span class="token keyword">void</span> <span class="token function">free</span><span class="token punctuation">(</span><span class="token keyword">int</span> M<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> M<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>hashtable<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>                <span class="token keyword">delete</span> hashtable<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span>hashtable<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>对于哈希表实现，里面有一个比较重要的哈希函数，这里我们先自己定义一个：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">/*** 哈希函数* @param key* @return*/</span><span class="token keyword">int</span> <span class="token function">hashFunc</span><span class="token punctuation">(</span>Key key<span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>hash<span class="token operator">&lt;</span>Key<span class="token operator">></span> h<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token function">h</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0x7fffffff</span><span class="token punctuation">)</span> <span class="token operator">%</span> M<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>这里使用std的hash得到值之后，将其<code>&amp;</code>上<code>0x7fffffff</code>，去掉高位的负号，转为正数，然后余上M。</p><p>现在有了这些我们来实现一下它的增删改查。</p><blockquote><p>增操作</p></blockquote><p>底层采用的是红黑树,插入是使用insert方法，通过构造一个pair来完成。<br>而当key存在的时候，更新值即可，对于更新这一块，如果直接使用insert是不起作用的，比如下面测试：</p><pre class=" language-cpp"><code class="language-cpp"> map<span class="token operator">&lt;</span>string<span class="token punctuation">,</span><span class="token keyword">int</span><span class="token operator">></span> m<span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token string">"a"</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token string">"b"</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> i<span class="token operator">:</span>m<span class="token punctuation">)</span> cout<span class="token operator">&lt;&lt;</span>i<span class="token punctuation">.</span>first<span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token operator">&lt;&lt;</span>i<span class="token punctuation">.</span>second<span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token punctuation">;</span>cout<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>m<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token string">"a"</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> i<span class="token operator">:</span>m<span class="token punctuation">)</span> cout<span class="token operator">&lt;&lt;</span>i<span class="token punctuation">.</span>first<span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token operator">&lt;&lt;</span>i<span class="token punctuation">.</span>second<span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token punctuation">;</span>cout<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>m<span class="token punctuation">[</span><span class="token string">"a"</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> i<span class="token operator">:</span>m<span class="token punctuation">)</span> cout<span class="token operator">&lt;&lt;</span>i<span class="token punctuation">.</span>first<span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token operator">&lt;&lt;</span>i<span class="token punctuation">.</span>second<span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token punctuation">;</span>cout<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span></code></pre><p>输出：</p><pre class=" language-cpp"><code class="language-cpp">a <span class="token number">1</span> b <span class="token number">2</span> a <span class="token number">1</span> b <span class="token number">2</span> a <span class="token number">2</span> b <span class="token number">2</span> </code></pre><p>因此，如果要修改key对应的value，可以通过<code>[]</code>来修改，还可以先删除，再插入，这里就用这个方法。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">/*** 添加新元素* @param key* @param value*/</span><span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span>Key key<span class="token punctuation">,</span> Value value<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 拉链法出来的map如果为空,就动态分配一个map,然后进行插入</span>    <span class="token comment" spellcheck="true">// 如果key不存在就看内存是否存在,不存在,就分配,存在就插入</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>hashtable<span class="token punctuation">[</span><span class="token function">hashFunc</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token constant">NULL</span> <span class="token operator">||</span> hashtable<span class="token punctuation">[</span><span class="token function">hashFunc</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">count</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>hashtable<span class="token punctuation">[</span><span class="token function">hashFunc</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>            hashtable<span class="token punctuation">[</span><span class="token function">hashFunc</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> map<span class="token operator">&lt;</span>Key<span class="token punctuation">,</span> Value<span class="token operator">></span><span class="token punctuation">;</span>        hashtable<span class="token punctuation">[</span><span class="token function">hashFunc</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token function">make_pair</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        size<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">>=</span> <span class="token function">maxCapacity</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token function">resize</span><span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> M<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 否则,修改value.</span>        hashtable<span class="token punctuation">[</span><span class="token function">hashFunc</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">erase</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>        hashtable<span class="token punctuation">[</span><span class="token function">hashFunc</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token function">make_pair</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p>删操作</p></blockquote><p>如果key存在，就删除，size–，否则返回失败标记。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">/*** 移除Key* @param key* @return 0 success -1 fail*/</span>Value <span class="token function">remove</span><span class="token punctuation">(</span>Key key<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Value ret <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 是否包含key,若包含key,则直接删除</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">contains</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        hashtable<span class="token punctuation">[</span><span class="token function">hashFunc</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">erase</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>        size<span class="token operator">--</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//            if (size == 0) delete hashtable[hashFunc(key)];       // 可以添加这行来动态减少内存</span>        ret <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// initCapacity 保证不会越界</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">&lt;</span> <span class="token function">minCapacity</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> M <span class="token operator">/</span> <span class="token number">2</span> <span class="token operator">>=</span> initCapacity<span class="token punctuation">)</span> <span class="token function">resize</span><span class="token punctuation">(</span>M <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> ret<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><blockquote><p>改操作</p></blockquote><p>前面提到过，这里就直接放代码。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">/*** 重设value* @param key* @param value*/</span><span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span>Key key<span class="token punctuation">,</span> Value value<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// key不存在</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">contains</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span>        hrow <span class="token string">"key not exists!"</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 修改value</span>    hashtable<span class="token punctuation">[</span><span class="token function">hashFunc</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">erase</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>    hashtable<span class="token punctuation">[</span><span class="token function">hashFunc</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token function">make_pair</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><blockquote><p>查操作</p></blockquote><p>获取key对应的value。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">/*** 获取key对应的value* @param key* @return*/</span>Value <span class="token function">get</span><span class="token punctuation">(</span>Key key<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">contains</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> hashtable<span class="token punctuation">[</span><span class="token function">hashFunc</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">at</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>最后，上面有<code>contains</code>与<code>resize</code>等函数未提。</p><blockquote><p>key存在与否</p></blockquote><p>首先contains函数实现，就是判断key存在与否：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">/**    * 是否包含key    * @param key    * @return    */</span><span class="token keyword">bool</span> <span class="token function">contains</span><span class="token punctuation">(</span>Key key<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> hashtable<span class="token punctuation">[</span><span class="token function">hashFunc</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token constant">NULL</span> <span class="token operator">||</span> <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>hashtable<span class="token punctuation">[</span><span class="token function">hashFunc</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">count</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">?</span> <span class="token boolean">false</span> <span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><blockquote><p>获取size</p></blockquote><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">/*** 获取哈希表元素个数* @return*/</span><span class="token keyword">int</span> <span class="token function">getSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> size<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><blockquote><p>最大容量与最小容量</p></blockquote><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">/**    * 最大容量    * @return    */</span>Value <span class="token function">maxCapacity</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> M <span class="token operator">*</span> upperTol<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/**    * 最小容量    * @return    */</span>Value <span class="token function">minCapacity</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> M <span class="token operator">*</span> lowerTol<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><blockquote><p>resize函数</p></blockquote><p>完成动态调整内存，将原来内存中的内容拷贝到新分配的空间，释放原空间！</p><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">/*** 动态调整内存,保证时间复杂度O(1)查找* 把扩容后的操作,平摊到前面每次操作,时间复杂度O(2),那就是O(1)了* @param newM*/</span><span class="token keyword">void</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token keyword">int</span> newM<span class="token punctuation">)</span> <span class="token punctuation">{</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"resize "</span> <span class="token operator">&lt;&lt;</span> newM <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    map<span class="token operator">&lt;</span>Key<span class="token punctuation">,</span> Value<span class="token operator">></span> <span class="token operator">*</span><span class="token operator">*</span>newHashTable <span class="token operator">=</span> <span class="token keyword">new</span> map<span class="token operator">&lt;</span>Key<span class="token punctuation">,</span> Value<span class="token operator">></span> <span class="token operator">*</span><span class="token punctuation">[</span>newM<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> newM<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        newHashTable<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> map<span class="token operator">&lt;</span>Key<span class="token punctuation">,</span> Value<span class="token operator">></span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> oldM <span class="token operator">=</span> M<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>M <span class="token operator">=</span> newM<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> oldM<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        map<span class="token operator">&lt;</span>Key<span class="token punctuation">,</span> Value<span class="token operator">></span> m <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span>hashtable<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> p<span class="token operator">:</span>m<span class="token punctuation">)</span>            newHashTable<span class="token punctuation">[</span><span class="token function">hashFunc</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>first<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token function">make_pair</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>first<span class="token punctuation">,</span> p<span class="token punctuation">.</span>second<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">free</span><span class="token punctuation">(</span>oldM<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>hashtable <span class="token operator">=</span> newHashTable<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><blockquote><p>重载&lt;&lt; 操作符</p></blockquote><p>声明：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> K<span class="token punctuation">,</span> <span class="token keyword">typename</span> V<span class="token operator">></span>    <span class="token comment" spellcheck="true">// 重载&lt;&lt;操作符</span>    <span class="token keyword">friend</span> ostream <span class="token operator">&amp;</span><span class="token keyword">operator</span><span class="token operator">&lt;&lt;</span><span class="token punctuation">(</span>ostream <span class="token operator">&amp;</span>out<span class="token punctuation">,</span> HashTable<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> <span class="token operator">&amp;</span>hashTable<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>定义：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> K<span class="token punctuation">,</span> <span class="token keyword">typename</span> V<span class="token operator">></span>ostream <span class="token operator">&amp;</span><span class="token keyword">operator</span><span class="token operator">&lt;&lt;</span><span class="token punctuation">(</span>ostream <span class="token operator">&amp;</span>out<span class="token punctuation">,</span> HashTable<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> <span class="token operator">&amp;</span>hashTable<span class="token punctuation">)</span> <span class="token punctuation">{</span>    hashTable<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> out<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>至此，上述哈希表实现完毕，现在来测试：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"hash.h"</span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    vector<span class="token operator">&lt;</span>string<span class="token operator">></span> words<span class="token punctuation">{</span><span class="token string">"java"</span><span class="token punctuation">,</span> <span class="token string">"c++"</span><span class="token punctuation">,</span> <span class="token string">"c"</span><span class="token punctuation">,</span> <span class="token string">"c++"</span><span class="token punctuation">,</span> <span class="token string">"c#"</span><span class="token punctuation">,</span> <span class="token string">"python"</span><span class="token punctuation">,</span> <span class="token string">"ruby"</span><span class="token punctuation">,</span> <span class="token string">"python"</span><span class="token punctuation">,</span>                         <span class="token string">"c"</span><span class="token punctuation">,</span> <span class="token string">"c"</span><span class="token punctuation">,</span> <span class="token string">"c++"</span><span class="token punctuation">,</span> <span class="token string">"java"</span><span class="token punctuation">,</span> <span class="token string">"c++"</span><span class="token punctuation">,</span> <span class="token string">"rust"</span><span class="token punctuation">,</span> <span class="token string">"python"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    HashTable<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span> <span class="token function">ht</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>string word <span class="token operator">:</span> words<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>ht<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>word<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            ht<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>word<span class="token punctuation">,</span> ht<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>word<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            ht<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>word<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    cout<span class="token operator">&lt;&lt;</span>ht<span class="token punctuation">;</span>    cout<span class="token operator">&lt;&lt;</span><span class="token string">"size="</span><span class="token operator">&lt;&lt;</span>ht<span class="token punctuation">.</span><span class="token function">getSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span><span class="token string">",maxCapacity="</span><span class="token operator">&lt;&lt;</span>ht<span class="token punctuation">.</span><span class="token function">maxCapacity</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span><span class="token string">",minCapacity="</span><span class="token operator">&lt;&lt;</span>ht<span class="token punctuation">.</span><span class="token function">minCapacity</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    string w<span class="token operator">=</span><span class="token string">"c++"</span><span class="token punctuation">;</span>    ht<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ht<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">)</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">""</span> <span class="token operator">&lt;&lt;</span> w <span class="token operator">&lt;&lt;</span> <span class="token string">": "</span> <span class="token operator">&lt;&lt;</span> ht<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token keyword">else</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"No word "</span> <span class="token operator">&lt;&lt;</span> w <span class="token operator">&lt;&lt;</span> <span class="token string">" in words"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    cout<span class="token operator">&lt;&lt;</span>ht<span class="token punctuation">;</span>    ht<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token string">"c#"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    ht<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token string">"java"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    ht<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token string">"c"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cout<span class="token operator">&lt;&lt;</span><span class="token string">"size="</span><span class="token operator">&lt;&lt;</span>ht<span class="token punctuation">.</span><span class="token function">getSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span><span class="token string">",maxCapacity="</span><span class="token operator">&lt;&lt;</span>ht<span class="token punctuation">.</span><span class="token function">maxCapacity</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span><span class="token string">",minCapacity="</span><span class="token operator">&lt;&lt;</span>ht<span class="token punctuation">.</span><span class="token function">minCapacity</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    cout<span class="token operator">&lt;&lt;</span>ht<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>输出结果：</p><pre class=" language-cpp"><code class="language-cpp">resize <span class="token number">2</span>resize <span class="token number">4</span><span class="token punctuation">{</span>c#<span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">,</span>java<span class="token operator">:</span><span class="token number">2</span><span class="token punctuation">,</span>ruby<span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">,</span>c<span class="token operator">:</span><span class="token number">3</span><span class="token punctuation">,</span>rust<span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">,</span>python<span class="token operator">:</span><span class="token number">3</span><span class="token punctuation">,</span>c<span class="token operator">++</span><span class="token operator">:</span><span class="token number">4</span><span class="token punctuation">}</span>size<span class="token operator">=</span><span class="token number">7</span><span class="token punctuation">,</span>maxCapacity<span class="token operator">=</span><span class="token number">12</span><span class="token punctuation">,</span>minCapacity<span class="token operator">=</span><span class="token number">4</span>No word c<span class="token operator">++</span> in words<span class="token punctuation">{</span>c#<span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">,</span>java<span class="token operator">:</span><span class="token number">2</span><span class="token punctuation">,</span>ruby<span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">,</span>c<span class="token operator">:</span><span class="token number">3</span><span class="token punctuation">,</span>rust<span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">,</span>python<span class="token operator">:</span><span class="token number">3</span><span class="token punctuation">}</span>resize <span class="token number">2</span>size<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">,</span>maxCapacity<span class="token operator">=</span><span class="token number">6</span><span class="token punctuation">,</span>minCapacity<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">{</span>python<span class="token operator">:</span><span class="token number">3</span><span class="token punctuation">,</span>ruby<span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">,</span>rust<span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">}</span></code></pre><p>至此，完成了一个简单的哈希表。</p><h2 id="1-优化哈希表"><a href="#1-优化哈希表" class="headerlink" title="1.优化哈希表"></a>1.优化哈希表</h2><p>在gcc2.9版本中，底层的哈希表是以素数作为容量动态修改的，因此这里的优化从这里出发：</p><p>类内部开头添加下面数组：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 素数数组</span><span class="token keyword">const</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> capacity <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">53</span><span class="token punctuation">,</span> <span class="token number">97</span><span class="token punctuation">,</span> <span class="token number">193</span><span class="token punctuation">,</span> <span class="token number">389</span><span class="token punctuation">,</span> <span class="token number">769</span><span class="token punctuation">,</span> <span class="token number">1543</span><span class="token punctuation">,</span> <span class="token number">3079</span><span class="token punctuation">,</span> <span class="token number">6151</span><span class="token punctuation">,</span> <span class="token number">12289</span><span class="token punctuation">,</span> <span class="token number">24593</span><span class="token punctuation">,</span> <span class="token number">49157</span><span class="token punctuation">,</span> <span class="token number">98317</span><span class="token punctuation">,</span>                                <span class="token number">196613</span><span class="token punctuation">,</span> <span class="token number">393241</span><span class="token punctuation">,</span> <span class="token number">786433</span><span class="token punctuation">,</span> <span class="token number">1572869</span><span class="token punctuation">,</span> <span class="token number">3145739</span><span class="token punctuation">,</span> <span class="token number">6291469</span><span class="token punctuation">,</span> <span class="token number">12582917</span><span class="token punctuation">,</span> <span class="token number">25165843</span><span class="token punctuation">,</span>                                <span class="token number">50331653</span><span class="token punctuation">,</span> <span class="token number">100663319</span><span class="token punctuation">,</span> <span class="token number">201326611</span><span class="token punctuation">,</span> <span class="token number">402653189</span><span class="token punctuation">,</span> <span class="token number">805306457</span><span class="token punctuation">,</span> <span class="token number">1610612741</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>去掉带参数的构造函数，修改默认构造为：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">/*** 默认构造* @param M*/</span><span class="token function">HashTable</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>    M <span class="token operator">=</span> capacity<span class="token punctuation">[</span>capacityIndex<span class="token punctuation">]</span><span class="token punctuation">,</span> size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 这里的括号是为了初始化为0,这就可以不用写下面的代码,当然在后面add之类的操作,就不需要动态分配内存.</span>    <span class="token comment" spellcheck="true">// this->hashtable = new map&lt;Key, Value> *[M]();</span>    <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>hashtable <span class="token operator">=</span> <span class="token keyword">new</span> map<span class="token operator">&lt;</span>Key<span class="token punctuation">,</span> Value<span class="token operator">></span> <span class="token operator">*</span><span class="token punctuation">[</span>M<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> M<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>hashtable<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> map<span class="token operator">&lt;</span>Key<span class="token punctuation">,</span> Value<span class="token operator">></span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>修改add函数：<br>在size++后添加下面代码：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">>=</span> <span class="token function">maxCapacity</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> capacityIndex <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;</span> capacity<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    capacityIndex<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token function">resize</span><span class="token punctuation">(</span>capacity<span class="token punctuation">[</span>M<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>每次resize从capacity中取值。</p><blockquote><p>remove函数修改</p></blockquote><p>在size–后修改：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">&lt;</span> <span class="token function">minCapacity</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> capacityIndex <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    capacityIndex<span class="token operator">--</span><span class="token punctuation">;</span>    <span class="token function">resize</span><span class="token punctuation">(</span>capacityIndex<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>至此，哈希表完成！测试代码同上。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 哈希表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ STL源码剖析之map、multimap、initializer_list</title>
      <link href="/2019/10/19/map-multimap/"/>
      <url>/2019/10/19/map-multimap/</url>
      
        <content type="html"><![CDATA[<h1 id="C-STL源码剖析之map、multimap、initializer-list"><a href="#C-STL源码剖析之map、multimap、initializer-list" class="headerlink" title="C++ STL源码剖析之map、multimap、initializer_list"></a>C++ STL源码剖析之map、multimap、initializer_list</h1><p>map/multimap 以rb_tree为底层结构，因此有元素自动排序特点，排序的依据是key。</p><p>map/multimap提供”遍历”操作及iterators。按正常规则(++iter)遍历，便能够获得排序状态。</p><p>我们无法使用map/multimap的iterators改变元素的key(因为key有其严谨排列规则)，但可以用它来改变元素的data。因此map/multimap内部自动将用户指定的key type设定为const，如此便能进制用户对元素key的赋值。</p><p>map元素的key必须独立无二，因此其insert使用的是rb_tree的<code>_M_insert_unique()</code>，而multimap元素的key可以重复，因此其insert使用的是rb_tree的<code>_M_insert_equal()</code>。</p><p>对于本节，我们将从下面几个内容阐述：</p><ul><li>map的key为key,value为key+data,与set是不同的，set是key就是value，value就是key。</li><li>map的key不可修改,map与multimap的插入调用函数不同，影响了其key是否对应value。</li><li>initializer_list使用</li><li>map有<code>[]</code>操作符，而multimap没有<code>[]</code>操作符。</li></ul><h2 id="1-map"><a href="#1-map" class="headerlink" title="1.map"></a>1.map</h2><blockquote><p>key为key，value为key+data</p></blockquote><p>下面map中我们可以看到value_type为一个pair。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> _Key<span class="token punctuation">,</span> <span class="token keyword">typename</span> _Tp<span class="token punctuation">,</span> <span class="token keyword">typename</span> _Compare <span class="token operator">=</span> std<span class="token operator">::</span>less<span class="token operator">&lt;</span>_Key<span class="token operator">></span><span class="token punctuation">,</span><span class="token keyword">typename</span> _Alloc <span class="token operator">=</span> std<span class="token operator">::</span>allocator<span class="token operator">&lt;</span>std<span class="token operator">::</span>pair<span class="token operator">&lt;</span><span class="token keyword">const</span> _Key<span class="token punctuation">,</span> _Tp<span class="token operator">></span> <span class="token operator">></span> <span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">map</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">typedef</span> _Key                                          key_type<span class="token punctuation">;</span>    <span class="token keyword">typedef</span> _Tp                                           mapped_type<span class="token punctuation">;</span>    <span class="token keyword">typedef</span> std<span class="token operator">::</span>pair<span class="token operator">&lt;</span><span class="token keyword">const</span> _Key<span class="token punctuation">,</span> _Tp<span class="token operator">></span>                    value_type<span class="token punctuation">;</span>    <span class="token keyword">typedef</span> _Compare                                      key_compare<span class="token punctuation">;</span>    <span class="token keyword">typedef</span> _Alloc                                        allocator_type<span class="token punctuation">;</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token comment" spellcheck="true">// key为key,value为key+data</span>    <span class="token keyword">typedef</span> _Rb_tree<span class="token operator">&lt;</span>key_type<span class="token punctuation">,</span> value_type<span class="token punctuation">,</span> _Select1st<span class="token operator">&lt;</span>value_type<span class="token operator">></span><span class="token punctuation">,</span>            key_compare<span class="token punctuation">,</span> _Pair_alloc_type<span class="token operator">></span> _Rep_type<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/// The actual tree structure.</span>    _Rep_type _M_t<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p><img src="https://raw.githubusercontent.com/Light-City/cloudimg/master/map_data.png" alt="map_data.png"></p><p>上述默认的仿函数为<code>_Select1st</code>，我们在<code>stl_function</code>中看到源码如下：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _Pair<span class="token operator">></span><span class="token keyword">struct</span> _Select1st<span class="token operator">:</span> <span class="token keyword">public</span> unary_function<span class="token operator">&lt;</span>_Pair<span class="token punctuation">,</span> <span class="token keyword">typename</span> _Pair<span class="token operator">::</span>first_type<span class="token operator">></span><span class="token punctuation">{</span>    <span class="token keyword">typename</span> _Pair<span class="token operator">::</span>first_type<span class="token operator">&amp;</span>    <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>_Pair<span class="token operator">&amp;</span> __x<span class="token punctuation">)</span> <span class="token keyword">const</span>    <span class="token punctuation">{</span> <span class="token keyword">return</span> __x<span class="token punctuation">.</span>first<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>我们看到上述的<code>_Select1st</code>为一个struct，怎么能说它是仿函数呢？<br>因为里面重载了一个()操作符，哈哈～</p><p>下面我们来自己实现一个：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _T1<span class="token operator">></span><span class="token keyword">struct</span> mySelect1st        <span class="token operator">:</span> <span class="token keyword">public</span> unary_function<span class="token operator">&lt;</span>_T1<span class="token punctuation">,</span> <span class="token keyword">typename</span> _T1<span class="token operator">::</span>first_type<span class="token operator">></span><span class="token punctuation">{</span>    <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _T2<span class="token operator">></span>    <span class="token keyword">typename</span> _T2<span class="token operator">::</span>first_type<span class="token operator">&amp;</span>    <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>_T2<span class="token operator">&amp;</span> __x<span class="token punctuation">)</span> <span class="token keyword">const</span>    <span class="token punctuation">{</span> <span class="token keyword">return</span> __x<span class="token punctuation">.</span>first<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token keyword">typedef</span> pair<span class="token operator">&lt;</span><span class="token keyword">const</span> <span class="token keyword">int</span><span class="token punctuation">,</span><span class="token keyword">int</span><span class="token operator">></span> value_type<span class="token punctuation">;</span>    _Rb_tree<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> value_type<span class="token punctuation">,</span> mySelect1st<span class="token operator">&lt;</span>value_type<span class="token operator">></span><span class="token punctuation">,</span> less<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> it<span class="token punctuation">;</span>    it<span class="token punctuation">.</span><span class="token function">_M_insert_unique</span><span class="token punctuation">(</span><span class="token function">make_pair</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    it<span class="token punctuation">.</span><span class="token function">_M_insert_unique</span><span class="token punctuation">(</span><span class="token function">make_pair</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> each<span class="token operator">:</span>it<span class="token punctuation">)</span>        cout<span class="token operator">&lt;&lt;</span>each<span class="token punctuation">.</span>first<span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token operator">&lt;&lt;</span>each<span class="token punctuation">.</span>second<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><blockquote><p>key不能改，data可以改</p></blockquote><p>上述源码中：自动为key添加一个const，所以key不能改。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">typedef</span> std<span class="token operator">::</span>pair<span class="token operator">&lt;</span><span class="token keyword">const</span> _Key<span class="token punctuation">,</span> _Tp<span class="token operator">></span>                    value_type<span class="token punctuation">;</span></code></pre><h2 id="2-insert"><a href="#2-insert" class="headerlink" title="2.insert"></a>2.insert</h2><blockquote><p>insert里面采用<code>_M_insert_unique</code></p></blockquote><p>insert的几种方法：</p><p>（1） 插入 pair</p><pre class=" language-cpp"><code class="language-cpp">std<span class="token operator">::</span>pair<span class="token operator">&lt;</span>iterator<span class="token punctuation">,</span> <span class="token keyword">bool</span><span class="token operator">></span> <span class="token function">insert</span><span class="token punctuation">(</span><span class="token keyword">const</span> value_type<span class="token operator">&amp;</span> __x<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">return</span> _M_t<span class="token punctuation">.</span><span class="token function">_M_insert_unique</span><span class="token punctuation">(</span>__x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre><p>map里面</p><p>（2） 在指定位置，插入pair</p><pre class=" language-cpp"><code class="language-cpp">iterator <span class="token function">insert</span><span class="token punctuation">(</span>iterator __position<span class="token punctuation">,</span> <span class="token keyword">const</span> value_type<span class="token operator">&amp;</span> __x<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">return</span> _M_t<span class="token punctuation">.</span><span class="token function">_M_insert_equal_</span><span class="token punctuation">(</span>__position<span class="token punctuation">,</span> __x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre><p>（3） 从一个范围进行插入</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _InputIterator<span class="token operator">></span><span class="token keyword">void</span><span class="token function">insert</span><span class="token punctuation">(</span>_InputIterator __first<span class="token punctuation">,</span> _InputIterator __last<span class="token punctuation">)</span><span class="token punctuation">{</span> _M_t<span class="token punctuation">.</span><span class="token function">_M_insert_equal</span><span class="token punctuation">(</span>__first<span class="token punctuation">,</span> __last<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre><p>（4）从list中插入</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">void</span><span class="token function">insert</span><span class="token punctuation">(</span>initializer_list<span class="token operator">&lt;</span>value_type<span class="token operator">></span> __l<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">insert</span><span class="token punctuation">(</span>__l<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> __l<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre><p>针对最后一个insert，里面有个<code>initializer_list</code>，举个例子大家就知道了。</p><h2 id="3-initializer-list使用"><a href="#3-initializer-list使用" class="headerlink" title="3.initializer_list使用"></a>3.initializer_list使用</h2><blockquote><p>实际编程实践 </p></blockquote><pre class=" language-cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> v<span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 底层调用vector的构造函数</span>v<span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">}</span><span class="token punctuation">;</span>               <span class="token comment" spellcheck="true">// 底层调用vector的=操作符</span>initializer_list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> ll<span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">}</span><span class="token punctuation">;</span>v<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>ll<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 底层调用下面insert函数</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> x<span class="token operator">:</span>v<span class="token punctuation">)</span> cout<span class="token operator">&lt;&lt;</span>x<span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token punctuation">;</span>cout<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">vv</span><span class="token punctuation">(</span>ll<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 底层调用vector的构造函数</span>vector<span class="token operator">&lt;</span>string<span class="token operator">></span> city<span class="token punctuation">{</span><span class="token string">"Berlin"</span><span class="token punctuation">,</span> <span class="token string">"New York"</span><span class="token punctuation">,</span> <span class="token string">"London"</span><span class="token punctuation">,</span> <span class="token string">"Cairo"</span><span class="token punctuation">,</span><span class="token string">"Tokyo"</span><span class="token punctuation">,</span> <span class="token string">"Cologne"</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>针对这个vector初始化，大家很熟悉了，为何可以这样初始化呢？<br>我们看一下vector源码：</p><pre class=" language-cpp"><code class="language-cpp"> vector<span class="token operator">&amp;</span><span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>initializer_list<span class="token operator">&lt;</span>value_type<span class="token operator">></span> __l<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">assign</span><span class="token punctuation">(</span>__l<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> __l<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span><span class="token punctuation">}</span>iterator<span class="token function">insert</span><span class="token punctuation">(</span>const_iterator __position<span class="token punctuation">,</span> initializer_list<span class="token operator">&lt;</span>value_type<span class="token operator">></span> __l<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">insert</span><span class="token punctuation">(</span>__position<span class="token punctuation">,</span> __l<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> __l<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token function">vector</span><span class="token punctuation">(</span>initializer_list<span class="token operator">&lt;</span>value_type<span class="token operator">></span> __l<span class="token punctuation">,</span><span class="token keyword">const</span> allocator_type<span class="token operator">&amp;</span> __a <span class="token operator">=</span> <span class="token function">allocator_type</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token function">_Base</span><span class="token punctuation">(</span>__a<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">_M_range_initialize</span><span class="token punctuation">(</span>__l<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> __l<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token function">random_access_iterator_tag</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>因为它的构造函数里面，参数有个<code>initializer_list</code>,因此我们可以针对这个对map进行使用。<br>但是map没有类似的构造，它也应用在map构造函数，insert与<code>=</code>处，跟上面是一样的，都是三处，哈哈～</p><p>使用<code>initializer_list</code>三处：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// map构造</span><span class="token function">map</span><span class="token punctuation">(</span>initializer_list<span class="token operator">&lt;</span>value_type<span class="token operator">></span> __l<span class="token punctuation">,</span> <span class="token keyword">const</span> allocator_type<span class="token operator">&amp;</span> __a<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token function">_M_t</span><span class="token punctuation">(</span><span class="token function">_Compare</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">_Pair_alloc_type</span><span class="token punctuation">(</span>__a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span> _M_t<span class="token punctuation">.</span><span class="token function">_M_insert_unique</span><span class="token punctuation">(</span>__l<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> __l<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token comment" spellcheck="true">// =操作符重载</span>map<span class="token operator">&amp;</span><span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>initializer_list<span class="token operator">&lt;</span>value_type<span class="token operator">></span> __l<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">insert</span><span class="token punctuation">(</span>__l<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> __l<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// insert插入</span><span class="token keyword">void</span><span class="token function">insert</span><span class="token punctuation">(</span>std<span class="token operator">::</span>initializer_list<span class="token operator">&lt;</span>value_type<span class="token operator">></span> __list<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token function">insert</span><span class="token punctuation">(</span>__list<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> __list<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre><blockquote><p>实际编程实践</p></blockquote><p>map使用<code>initializer_list</code>(set使用一样)：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 这里要注意，pair的first参数必[须是const</span>initializer_list<span class="token operator">&lt;</span>pair<span class="token operator">&lt;</span><span class="token keyword">const</span> strin<span class="token punctuation">[</span>g<span class="token punctuation">,</span><span class="token keyword">int</span><span class="token operator">>></span> l <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token string">"hello"</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token string">"world"</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>map<span class="token operator">&lt;</span>string<span class="token punctuation">,</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">mm</span><span class="token punctuation">(</span>l<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// map构造函数</span>map<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span> m2<span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token string">"hello"</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token string">"world"</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// map构造函数</span>map<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span> m1<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token string">"hello"</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token string">"world"</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// map构造函数</span>m1 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token string">"h"</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token string">"w"</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">// 底层调用map的=操作符</span>map<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span> mp<span class="token punctuation">;</span>mp<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>l<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// insert插入[</span></code></pre><p>上述会引出另一个问题：</p><pre class=" language-cpp"><code class="language-cpp">map<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span> m1<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token string">"hello"</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token string">"world"</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// map构造函数</span>m1 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token string">"h"</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token string">"w"</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">// 底层调用map的=操作符</span></code></pre><p>这两个为何一个调用的构造，一个调用=操作符呢？</p><p>在初始化的时候，定义及赋值的时候就直接调用构造，后面再次赋值，就是先调用拷贝构造(有可能会被编译器优化)，再调用=操作符。</p><blockquote><p>实例分析</p></blockquote><p>下面用一个具体实例来分析一下：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> _Tp<span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">Foo</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Foo</span><span class="token punctuation">(</span>initializer_list<span class="token operator">&lt;</span>_Tp<span class="token operator">></span> <span class="token operator">&amp;</span>list<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Foo(initializer_list&lt;_Tp> &amp;list)"</span><span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">Foo</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Foo(int )"</span><span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">Foo</span><span class="token punctuation">(</span><span class="token keyword">const</span> Foo<span class="token operator">&amp;</span> f<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"调用了拷贝构造函数"</span><span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    Foo<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>initializer_list<span class="token operator">&lt;</span>_Tp<span class="token operator">></span> __l<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        cout<span class="token operator">&lt;&lt;</span><span class="token string">"调用了=操作符重载"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>调用：</p><pre class=" language-cpp"><code class="language-cpp">Foo<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> foo<span class="token operator">=</span>ll<span class="token punctuation">;</span>foo<span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>编译器未被优化的结果：</p><pre><code>Foo(initializer_list&lt;_Tp&gt; &amp;list)调用了=操作符重载</code></pre><p>我们通过禁用编译器优化：<code>g++ -o rb  rbtree.cpp  -std=c++11 -fno-elide-constructors</code></p><pre><code>Foo(initializer_list&lt;_Tp&gt; &amp;list)调用了拷贝构造函数调用了=操作符重载</code></pre><h2 id="4-multimap"><a href="#4-multimap" class="headerlink" title="4.multimap"></a>4.multimap</h2><p>同map一样multimap不允许修改key。但是插入使用的是<code>_M_insert_equal</code>。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> _Key<span class="token punctuation">,</span> <span class="token keyword">typename</span> _Tp<span class="token punctuation">,</span><span class="token keyword">typename</span> _Compare <span class="token operator">=</span> std<span class="token operator">::</span>less<span class="token operator">&lt;</span>_Key<span class="token operator">></span><span class="token punctuation">,</span><span class="token keyword">typename</span> _Alloc <span class="token operator">=</span> std<span class="token operator">::</span>allocator<span class="token operator">&lt;</span>std<span class="token operator">::</span>pair<span class="token operator">&lt;</span><span class="token keyword">const</span> _Key<span class="token punctuation">,</span> _Tp<span class="token operator">></span> <span class="token operator">></span> <span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">multimap</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>                                          <span class="token keyword">typedef</span> std<span class="token operator">::</span>pair<span class="token operator">&lt;</span><span class="token keyword">const</span> _Key<span class="token punctuation">,</span> _Tp<span class="token operator">></span> value_type<span class="token punctuation">;</span>   <span class="token punctuation">}</span></code></pre><p>下面使用multimap与rbtree两种方式来联系。</p><pre class=" language-cpp"><code class="language-cpp">multimap<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> string<span class="token operator">></span> c<span class="token punctuation">;</span>c<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token function">make_pair</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">"asdqw"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>c<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token function">make_pair</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">"qweq"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> each<span class="token operator">:</span>c<span class="token punctuation">)</span> cout<span class="token operator">&lt;&lt;</span>each<span class="token punctuation">.</span>first<span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token operator">&lt;&lt;</span>each<span class="token punctuation">.</span>second<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token keyword">typedef</span> pair<span class="token operator">&lt;</span><span class="token keyword">const</span> <span class="token keyword">int</span><span class="token punctuation">,</span>string<span class="token operator">></span> valueT<span class="token punctuation">;</span>_Rb_tree<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> valueT<span class="token punctuation">,</span> _Select1st<span class="token operator">&lt;</span>valueT<span class="token operator">></span><span class="token punctuation">,</span> less<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> mulm<span class="token punctuation">;</span>mulm<span class="token punctuation">.</span><span class="token function">_M_insert_equal</span><span class="token punctuation">(</span><span class="token function">make_pair</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token string">"abc"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>mulm<span class="token punctuation">.</span><span class="token function">_M_insert_equal</span><span class="token punctuation">(</span><span class="token function">make_pair</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token string">"cde"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> each<span class="token operator">:</span>mulm<span class="token punctuation">)</span>cout<span class="token operator">&lt;&lt;</span>each<span class="token punctuation">.</span>first<span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token operator">&lt;&lt;</span>each<span class="token punctuation">.</span>second<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span></code></pre><p>输出：</p><pre><code>1 asdqw1 qweq2 abc2 cde</code></pre><h2 id="5-map与multimap的重要操作符"><a href="#5-map与multimap的重要操作符" class="headerlink" title="5.map与multimap的重要操作符"></a>5.map与multimap的重要操作符</h2><p>map与multimap<code>[]</code>操作符，map的<code>[]</code>操作符返回传递给map的第二个参数。</p><p>传递给<code>[]</code>一个key，如果查找到，就是value，否则就是默认值0。</p><pre class=" language-cpp"><code class="language-cpp">mapped_type<span class="token operator">&amp;</span><span class="token keyword">operator</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">const</span> key_type<span class="token operator">&amp;</span> __k<span class="token punctuation">)</span><span class="token punctuation">{</span>    iterator __i <span class="token operator">=</span> <span class="token function">lower_bound</span><span class="token punctuation">(</span>__k<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 找到__k第一个。</span>    <span class="token comment" spellcheck="true">// __i->first is greater than or equivalent to __k.</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>__i <span class="token operator">==</span> <span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token function">key_comp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>__k<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token operator">*</span>__i<span class="token punctuation">)</span><span class="token punctuation">.</span>first<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token macro property">#<span class="token directive keyword">if</span> __cplusplus >= 201103L</span>    __i <span class="token operator">=</span> _M_t<span class="token punctuation">.</span><span class="token function">_M_emplace_hint_unique</span><span class="token punctuation">(</span>__i<span class="token punctuation">,</span> std<span class="token operator">::</span>piecewise_construct<span class="token punctuation">,</span>                    std<span class="token operator">::</span>tuple<span class="token operator">&lt;</span><span class="token keyword">const</span> key_type<span class="token operator">&amp;</span><span class="token operator">></span><span class="token punctuation">(</span>__k<span class="token punctuation">)</span><span class="token punctuation">,</span>                    std<span class="token operator">::</span>tuple<span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token macro property">#<span class="token directive keyword">else</span></span>        __i <span class="token operator">=</span> <span class="token function">insert</span><span class="token punctuation">(</span>__i<span class="token punctuation">,</span> <span class="token function">value_type</span><span class="token punctuation">(</span>__k<span class="token punctuation">,</span> <span class="token function">mapped_type</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token macro property">#<span class="token directive keyword">endif</span></span>    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token operator">*</span>__i<span class="token punctuation">)</span><span class="token punctuation">.</span>second<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 返回key的value，此value为传递进map的第二个参数。</span><span class="token punctuation">}</span></code></pre><p>但是multimap没有<code>[]</code>操作符！！！</p><p>我们思考一下，因为multimap会根据key，有可能会对应多个value，那如果我们通过<code>[]</code>获取对应key的value，此时到底获取的是哪个value呢，所以在STL源码中没有重载这个操作符！</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> STL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ STL源码剖析之set与multiset那些事</title>
      <link href="/2019/10/19/set-multiset/"/>
      <url>/2019/10/19/set-multiset/</url>
      
        <content type="html"><![CDATA[<h1 id="C-STL源码剖析之set与multiset那些事"><a href="#C-STL源码剖析之set与multiset那些事" class="headerlink" title="C++ STL源码剖析之set与multiset那些事"></a>C++ STL源码剖析之set与multiset那些事</h1><p>set/multiset以rb_tree为底层结构，因此有元素自动排序特性。排序的依据是key，而set/multiset元素的value和key合二为一：value就是key。</p><p>我们无法使用set/multiset的iterators改变元素值(因为key有其严谨排列规则)。<br>set/multiset的iterator是其底部RB tree的const-iterator，就是为了禁止用户对元素赋值。</p><p>set元素的key必须独一无二，因此其insert使用的是rb_tree的<code>insert_unique()</code>，而multiset元素的key可以重复，因此其insert使用的是rb_tree的<code>insert_equal()</code>。</p><h2 id="1-set"><a href="#1-set" class="headerlink" title="1.set"></a>1.set</h2><p>针对set源码比较简单，故从下面几个问题出发。</p><blockquote><p>第一个问题：key是value,value也是key。</p></blockquote><p>具体代码再第二个问题中会有，这里给出我们通常写代码后内部逻辑，我们看到里面有个红黑树，而红黑树的定义key与value是一样的，所以回答了这个问题。(源码中typedef都是来自key)。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _Key<span class="token punctuation">,</span> <span class="token keyword">typename</span> _Compare <span class="token operator">=</span> std<span class="token operator">::</span>less<span class="token operator">&lt;</span>_Key<span class="token operator">></span><span class="token punctuation">,</span>    <span class="token keyword">typename</span> _Alloc <span class="token operator">=</span> std<span class="token operator">::</span>allocator<span class="token operator">&lt;</span>_Key<span class="token operator">></span> <span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">set</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// concept requirements</span>    <span class="token keyword">typedef</span> <span class="token keyword">typename</span> _Alloc<span class="token operator">::</span>value_type                   _Alloc_value_type<span class="token punctuation">;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token comment" spellcheck="true">// typedefs:</span>    <span class="token comment" spellcheck="true">//@{</span>    <span class="token comment" spellcheck="true">/// Public typedefs.</span>    <span class="token keyword">typedef</span> _Key     key_type<span class="token punctuation">;</span>    <span class="token keyword">typedef</span> _Key     value_type<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// value也是key</span>    <span class="token keyword">typedef</span> _Compare key_compare<span class="token punctuation">;</span>    <span class="token keyword">typedef</span> _Compare value_compare<span class="token punctuation">;</span>    <span class="token keyword">typedef</span> _Alloc   allocator_type<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//@}</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">typedef</span> _Rb_tree<span class="token operator">&lt;</span>key_type<span class="token punctuation">,</span> value_type<span class="token punctuation">,</span> _Identity<span class="token operator">&lt;</span>value_type<span class="token operator">></span><span class="token punctuation">,</span>            key_compare<span class="token punctuation">,</span> _Key_alloc_type<span class="token operator">></span> _Rep_type<span class="token punctuation">;</span>    _Rep_type _M_t<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// Red-black tree representing set.</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p><img src="https://raw.githubusercontent.com/Light-City/cloudimg/master/set_key.png" alt="set_key.png"></p><blockquote><p>第二个问题：无法使用迭代器改变元素值。</p></blockquote><p>无法使用迭代器改变元素值我们看后面迭代器，发现全部用的是<code>const_iterator</code>，所以第二个问题也回答完毕。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _Key<span class="token punctuation">,</span> <span class="token keyword">typename</span> _Compare <span class="token operator">=</span> std<span class="token operator">::</span>less<span class="token operator">&lt;</span>_Key<span class="token operator">></span><span class="token punctuation">,</span>    <span class="token keyword">typename</span> _Alloc <span class="token operator">=</span> std<span class="token operator">::</span>allocator<span class="token operator">&lt;</span>_Key<span class="token operator">></span> <span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">set</span><span class="token punctuation">{</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">typedef</span> _Rb_tree<span class="token operator">&lt;</span>key_type<span class="token punctuation">,</span> value_type<span class="token punctuation">,</span> _Identity<span class="token operator">&lt;</span>value_type<span class="token operator">></span><span class="token punctuation">,</span>            key_compare<span class="token punctuation">,</span> _Key_alloc_type<span class="token operator">></span> _Rep_type<span class="token punctuation">;</span>    _Rep_type _M_t<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// Red-black tree representing set.</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">typedef</span> <span class="token keyword">typename</span> _Rep_type<span class="token operator">::</span>const_iterator            iterator<span class="token punctuation">;</span>    <span class="token keyword">typedef</span> <span class="token keyword">typename</span> _Rep_type<span class="token operator">::</span>const_iterator            const_iterator<span class="token punctuation">;</span>    <span class="token keyword">typedef</span> <span class="token keyword">typename</span> _Rep_type<span class="token operator">::</span>const_reverse_iterator    reverse_iterator<span class="token punctuation">;</span>    <span class="token keyword">typedef</span> <span class="token keyword">typename</span> _Rep_type<span class="token operator">::</span>const_reverse_iterator const_reverse_iterator<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>经过前面分析，让我们想起了queue、priority_queue、stack，他们都使用的是底层的容器，所以称为容器适配器，而set也是使用底层的容器，所以也可以被称为container adapter,即容器适配器。</p><blockquote><p>第三个问题：插入是唯一的key。</p></blockquote><p>底部调用的是<code>_M_insert_unique</code>。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _InputIterator<span class="token operator">></span><span class="token function">set</span><span class="token punctuation">(</span>_InputIterator __first<span class="token punctuation">,</span> _InputIterator __last<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token function">_M_t</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> _M_t<span class="token punctuation">.</span><span class="token function">_M_insert_unique</span><span class="token punctuation">(</span>__first<span class="token punctuation">,</span> __last<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre><p>我们来简单看一下这个函数实现：<br>下面<code>_M_get_insert_unique_pos</code>返回的是个pair，如果插入的key相同则pair的second为0，根据是否为0可以判断是否key重复，在下面代码中判断时候，当second不为0，也就是不重复的时候，那么就可以直接插入，此时直接构造一个second为true的pair,否则构造一个second为false的pair。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _Key<span class="token punctuation">,</span> <span class="token keyword">typename</span> _Val<span class="token punctuation">,</span> <span class="token keyword">typename</span> _KeyOfValue<span class="token punctuation">,</span>     <span class="token keyword">typename</span> _Compare<span class="token punctuation">,</span> <span class="token keyword">typename</span> _Alloc<span class="token operator">></span><span class="token macro property">#<span class="token directive keyword">if</span> __cplusplus >= 201103L</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _Arg<span class="token operator">></span><span class="token macro property">#<span class="token directive keyword">endif</span></span>pair<span class="token operator">&lt;</span><span class="token keyword">typename</span> _Rb_tree<span class="token operator">&lt;</span>_Key<span class="token punctuation">,</span> _Val<span class="token punctuation">,</span> _KeyOfValue<span class="token punctuation">,</span>               _Compare<span class="token punctuation">,</span> _Alloc<span class="token operator">></span><span class="token operator">::</span>iterator<span class="token punctuation">,</span> <span class="token keyword">bool</span><span class="token operator">></span>_Rb_tree<span class="token operator">&lt;</span>_Key<span class="token punctuation">,</span> _Val<span class="token punctuation">,</span> _KeyOfValue<span class="token punctuation">,</span> _Compare<span class="token punctuation">,</span> _Alloc<span class="token operator">></span><span class="token operator">::</span><span class="token function">_M_insert_unique</span><span class="token punctuation">(</span> _Arg <span class="token operator">&amp;&amp;</span> __v <span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">typedef</span> pair<span class="token operator">&lt;</span>iterator<span class="token punctuation">,</span> <span class="token keyword">bool</span><span class="token operator">></span> _Res<span class="token punctuation">;</span>    pair<span class="token operator">&lt;</span>_Base_ptr<span class="token punctuation">,</span> _Base_ptr<span class="token operator">></span> __res        <span class="token operator">=</span> <span class="token function">_M_get_insert_unique_pos</span><span class="token punctuation">(</span> <span class="token function">_KeyOfValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span> __v <span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span> __res<span class="token punctuation">.</span>second <span class="token punctuation">)</span>        <span class="token keyword">return</span><span class="token punctuation">(</span><span class="token function">_Res</span><span class="token punctuation">(</span> <span class="token function">_M_insert_</span><span class="token punctuation">(</span> __res<span class="token punctuation">.</span>first<span class="token punctuation">,</span> __res<span class="token punctuation">.</span>second<span class="token punctuation">,</span>                     <span class="token function">_GLIBCXX_FORWARD</span><span class="token punctuation">(</span> _Arg<span class="token punctuation">,</span> __v <span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>                 <span class="token boolean">true</span> <span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span><span class="token punctuation">(</span><span class="token function">_Res</span><span class="token punctuation">(</span> <span class="token function">iterator</span><span class="token punctuation">(</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span>_Link_type<span class="token operator">></span><span class="token punctuation">(</span>__res<span class="token punctuation">.</span>first<span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">false</span> <span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>我们再看看上面提到的函数：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _Key<span class="token punctuation">,</span> <span class="token keyword">typename</span> _Val<span class="token punctuation">,</span> <span class="token keyword">typename</span> _KeyOfValue<span class="token punctuation">,</span><span class="token keyword">typename</span> _Compare<span class="token punctuation">,</span> <span class="token keyword">typename</span> _Alloc<span class="token operator">></span>pair<span class="token operator">&lt;</span><span class="token keyword">typename</span> _Rb_tree<span class="token operator">&lt;</span>_Key<span class="token punctuation">,</span> _Val<span class="token punctuation">,</span> _KeyOfValue<span class="token punctuation">,</span>_Compare<span class="token punctuation">,</span> _Alloc<span class="token operator">></span><span class="token operator">::</span>_Base_ptr<span class="token punctuation">,</span><span class="token keyword">typename</span> _Rb_tree<span class="token operator">&lt;</span>_Key<span class="token punctuation">,</span> _Val<span class="token punctuation">,</span> _KeyOfValue<span class="token punctuation">,</span>Compare<span class="token punctuation">,</span> _Alloc<span class="token operator">></span><span class="token operator">::</span>_Base_ptr<span class="token operator">></span>_Rb_tree<span class="token operator">&lt;</span>_Key<span class="token punctuation">,</span> _Val<span class="token punctuation">,</span> _KeyOfValue<span class="token punctuation">,</span> _Compare<span class="token punctuation">,</span> _Alloc<span class="token operator">></span><span class="token operator">::</span><span class="token function">_M_get_insert_unique_pos</span><span class="token punctuation">(</span><span class="token keyword">const</span> key_type<span class="token operator">&amp;</span> __k<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// typedef pair</span>    <span class="token keyword">typedef</span> pair<span class="token operator">&lt;</span>_Base_ptr<span class="token punctuation">,</span> _Base_ptr<span class="token operator">></span> _Res<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// _x表示当前节点,_y表示_x的父节点</span>    _Link_type __x <span class="token operator">=</span> <span class="token function">_M_begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    _Link_type __y <span class="token operator">=</span> <span class="token function">_M_end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">bool</span> __comp <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 寻找插入点</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>__x <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        __y <span class="token operator">=</span> __x<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// __k&lt;__x是否为true</span>        __comp <span class="token operator">=</span> _M_impl<span class="token punctuation">.</span><span class="token function">_M_key_compare</span><span class="token punctuation">(</span>__k<span class="token punctuation">,</span> <span class="token function">_S_key</span><span class="token punctuation">(</span>__x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// __k&lt;__x就往左孩子查找，否则右孩子查找</span>        __x <span class="token operator">=</span> __comp <span class="token operator">?</span> <span class="token function">_S_left</span><span class="token punctuation">(</span>__x<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">_S_right</span><span class="token punctuation">(</span>__x<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    iterator __j <span class="token operator">=</span> <span class="token function">iterator</span><span class="token punctuation">(</span>__y<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// __k&lt;__y，往__y的左孩子插入节点即可，不是做插入，是找到位置即可。</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>__comp<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 特殊位置</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>__j <span class="token operator">==</span> <span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token function">_Res</span><span class="token punctuation">(</span>__x<span class="token punctuation">,</span> __y<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span>        <span class="token operator">--</span>__j<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 左孩子 这里调用了--操作符</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// __j&lt;__k，返回当前节(__x=0)点与父节点</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>_M_impl<span class="token punctuation">.</span><span class="token function">_M_key_compare</span><span class="token punctuation">(</span><span class="token function">_S_key</span><span class="token punctuation">(</span>__j<span class="token punctuation">.</span>_M_node<span class="token punctuation">)</span><span class="token punctuation">,</span> __k<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token function">_Res</span><span class="token punctuation">(</span>__x<span class="token punctuation">,</span> __y<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// _j>=__k,插入失败</span>    <span class="token keyword">return</span> <span class="token function">_Res</span><span class="token punctuation">(</span>__j<span class="token punctuation">.</span>_M_node<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>上述pair的使用给了我一个启发，竟然可以这样用，那么我们来学习一下：</p><pre class=" language-cpp"><code class="language-cpp">cout<span class="token operator">&lt;&lt;</span><span class="token string">"flag: "</span><span class="token operator">&lt;&lt;</span>itree<span class="token punctuation">.</span><span class="token function">_M_insert_unique</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">.</span>second<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 学习返回值</span><span class="token keyword">typedef</span> pair<span class="token operator">&lt;</span><span class="token keyword">int</span> <span class="token punctuation">,</span><span class="token keyword">bool</span><span class="token operator">></span> _Res<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 也来用一下typedef后的pair</span>cout<span class="token operator">&lt;&lt;</span><span class="token function">_Res</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">.</span>first<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 直接包裹</span>_Res r<span class="token operator">=</span><span class="token function">make_pair</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 定义新对象</span>cout<span class="token operator">&lt;&lt;</span>r<span class="token punctuation">.</span>first<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 输出结果</span></code></pre><h2 id="2-multiset"><a href="#2-multiset" class="headerlink" title="2.multiset"></a>2.multiset</h2><p>同理,multiset与set定义基本类似，不同之处，在于插入使用的是另一个函数,这样才使它能够完成重复key的插入！</p><pre class=" language-cpp"><code class="language-cpp"> <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _InputIterator<span class="token operator">></span><span class="token function">multiset</span><span class="token punctuation">(</span>_InputIterator __first<span class="token punctuation">,</span> _InputIterator __last<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token function">_M_t</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> _M_t<span class="token punctuation">.</span><span class="token function">_M_insert_equal</span><span class="token punctuation">(</span>__first<span class="token punctuation">,</span> __last<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre><p>下面来分析一下<code>_M_insert_equal</code>:</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">typename</span> _Rb_tree<span class="token operator">&lt;</span>_Key<span class="token punctuation">,</span> _Val<span class="token punctuation">,</span> _KeyOfValue<span class="token punctuation">,</span> _Compare<span class="token punctuation">,</span> _Alloc<span class="token operator">></span><span class="token operator">::</span>iterator_Rb_tree<span class="token operator">&lt;</span>_Key<span class="token punctuation">,</span> _Val<span class="token punctuation">,</span> _KeyOfValue<span class="token punctuation">,</span> _Compare<span class="token punctuation">,</span> _Alloc<span class="token operator">></span><span class="token operator">::</span><span class="token function">_M_insert_equal</span><span class="token punctuation">(</span>_Arg<span class="token operator">&amp;&amp;</span> __v<span class="token punctuation">)</span><span class="token punctuation">{</span>    pair<span class="token operator">&lt;</span>_Base_ptr<span class="token punctuation">,</span> _Base_ptr<span class="token operator">></span> __res <span class="token operator">=</span> <span class="token function">_M_get_insert_equal_pos</span><span class="token punctuation">(</span><span class="token function">_KeyOfValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>__v<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">_M_insert_</span><span class="token punctuation">(</span>__res<span class="token punctuation">.</span>first<span class="token punctuation">,</span> __res<span class="token punctuation">.</span>second<span class="token punctuation">,</span> <span class="token function">_GLIBCXX_FORWARD</span><span class="token punctuation">(</span>_Arg<span class="token punctuation">,</span> __v<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>我们继续追踪上述的<code>_M_get_insert_equal_pos</code>函数：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _Key<span class="token punctuation">,</span> <span class="token keyword">typename</span> _Val<span class="token punctuation">,</span> <span class="token keyword">typename</span> _KeyOfValue<span class="token punctuation">,</span><span class="token keyword">typename</span> _Compare<span class="token punctuation">,</span> <span class="token keyword">typename</span> _Alloc<span class="token operator">></span>pair<span class="token operator">&lt;</span><span class="token keyword">typename</span> _Rb_tree<span class="token operator">&lt;</span>_Key<span class="token punctuation">,</span> _Val<span class="token punctuation">,</span> _KeyOfValue<span class="token punctuation">,</span>_Compare<span class="token punctuation">,</span> _Alloc<span class="token operator">></span><span class="token operator">::</span>_Base_ptr<span class="token punctuation">,</span><span class="token keyword">typename</span> _Rb_tree<span class="token operator">&lt;</span>_Key<span class="token punctuation">,</span> _Val<span class="token punctuation">,</span> _KeyOfValue<span class="token punctuation">,</span>_Compare<span class="token punctuation">,</span> _Alloc<span class="token operator">></span><span class="token operator">::</span>_Base_ptr<span class="token operator">></span>_Rb_tree<span class="token operator">&lt;</span>_Key<span class="token punctuation">,</span> _Val<span class="token punctuation">,</span> _KeyOfValue<span class="token punctuation">,</span> _Compare<span class="token punctuation">,</span> _Alloc<span class="token operator">></span><span class="token operator">::</span><span class="token function">_M_get_insert_equal_pos</span><span class="token punctuation">(</span><span class="token keyword">const</span> key_type<span class="token operator">&amp;</span> __k<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">typedef</span> pair<span class="token operator">&lt;</span>_Base_ptr<span class="token punctuation">,</span> _Base_ptr<span class="token operator">></span> _Res<span class="token punctuation">;</span>    _Link_type __x <span class="token operator">=</span> <span class="token function">_M_begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    _Link_type __y <span class="token operator">=</span> <span class="token function">_M_end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>__x <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        __y <span class="token operator">=</span> __x<span class="token punctuation">;</span>        __x <span class="token operator">=</span> _M_impl<span class="token punctuation">.</span><span class="token function">_M_key_compare</span><span class="token punctuation">(</span>__k<span class="token punctuation">,</span> <span class="token function">_S_key</span><span class="token punctuation">(</span>__x<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">?</span>            <span class="token function">_S_left</span><span class="token punctuation">(</span>__x<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">_S_right</span><span class="token punctuation">(</span>__x<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token function">_Res</span><span class="token punctuation">(</span>__x<span class="token punctuation">,</span> __y<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>我们对比multiset与set的这几个函数发现，返回的pair有着显著的差异，之前的set需要返回最终是否插入成功，因为key不可重复，而multiset不需要返回是否插入成功，所以pair中不存在bool类型，故它是直接返回的插入点所构成的pair，因此，与之前相比较而言，不管你有多少个key，重复如何，都可以插入进去。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> STL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ STL源码剖析之红黑树</title>
      <link href="/2019/10/19/rb-tree/"/>
      <url>/2019/10/19/rb-tree/</url>
      
        <content type="html"><![CDATA[<h1 id="C-STL源码剖析之红黑树"><a href="#C-STL源码剖析之红黑树" class="headerlink" title="C++ STL源码剖析之红黑树"></a>C++ STL源码剖析之红黑树</h1><h2 id="0-导语"><a href="#0-导语" class="headerlink" title="0.导语"></a>0.导语</h2><p>在STL源码中有两段话，简单翻译后如下：</p><p>STL中Red-black tree（红黑树）class,用来当做SLT关系式容器（如set,multiset,map,<br>multimap）.里面所用的insertion和deletion方法以<br>《Introduction to Algorithms》一书为基础,但是有以下两点不同: </p><p>(1)header不仅指向root,也指向红黑树的最左节点,以便用常数时间实现begin(),并且也指向红黑树的最右边节点,以便<br>set相关泛型算法（如set_union等等）可以有线性时间表现.</p><p>(2)当要删除的节点有两个子节点时，其后继节点连接到其位置，而不是被复制，因此，唯一使无效的迭代器是引用已删除节点的迭代器。</p><p>上述话翻译成图，如下，相比于普通的红黑树多了一个header节点，并且为红色。普通的红黑树是以100节点开始的，且满足下面五条性质：</p><ul><li>每个节点或是红色的,或是黑色的.</li><li>根节点是黑色的.</li><li>每个叶节点（NULL）是黑色的.</li><li>如果一个节点是红色的，则它的两个孩子节点都是黑色的.</li><li>对每个节点，从该节点到其所有后代叶节点的简单路径上，均包含相同数目的黑色节点.</li></ul><p>当然这里的rb_tree也是一样满足这几条性质，迭代器的begin指向红黑树根节点，也就是header的父亲，而end指向header节点。</p><p><img src="https://raw.githubusercontent.com/Light-City/cloudimg/master/rbt.png" alt="st.png">。<br>图中省略号表示节点没有画完，还有其他节点，所以省略。</p><h2 id="1-红黑树节点基类"><a href="#1-红黑树节点基类" class="headerlink" title="1.红黑树节点基类"></a>1.红黑树节点基类</h2><p>红黑树基类，非常简单，在文件开头定义了颜色标记。</p><p>基类中包含了指向自己的指针，分别定义了left、right、parent，同时包含了一个颜色标记常量，而里面有两个核心函数，目的是获取红黑树中最小节点与最大节点。<br>我们知道对于二分搜索树获取最小节点就是左子树一直往下搜，最大节点就是右子树一直往下搜即可。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 颜色标记</span><span class="token keyword">enum</span> _Rb_tree_color <span class="token punctuation">{</span> _S_red <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">,</span> _S_black <span class="token operator">=</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 基类</span><span class="token keyword">struct</span> _Rb_tree_node_base<span class="token punctuation">{</span><span class="token comment" spellcheck="true">// typedef重命名</span><span class="token keyword">typedef</span> _Rb_tree_node_base<span class="token operator">*</span> _Base_ptr<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 颜色</span>_Rb_tree_color    _M_color<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 指向父亲</span>_Base_ptr        _M_parent<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 指向左孩子</span>_Base_ptr        _M_left<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 指向右孩子</span>_Base_ptr        _M_right<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 求红黑树的最小节点</span><span class="token keyword">static</span> _Base_ptr<span class="token function">_S_minimum</span><span class="token punctuation">(</span>_Base_ptr __x<span class="token punctuation">)</span> _GLIBCXX_NOEXCEPT<span class="token punctuation">{</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>__x<span class="token operator">-</span><span class="token operator">></span>_M_left <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> __x <span class="token operator">=</span> __x<span class="token operator">-</span><span class="token operator">></span>_M_left<span class="token punctuation">;</span>    <span class="token keyword">return</span> __x<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 求红黑树最大节点</span><span class="token keyword">static</span> _Base_ptr<span class="token function">_S_maximum</span><span class="token punctuation">(</span>_Base_ptr __x<span class="token punctuation">)</span> _GLIBCXX_NOEXCEPT<span class="token punctuation">{</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>__x<span class="token operator">-</span><span class="token operator">></span>_M_right <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> __x <span class="token operator">=</span> __x<span class="token operator">-</span><span class="token operator">></span>_M_right<span class="token punctuation">;</span>    <span class="token keyword">return</span> __x<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><h2 id="2-红黑树节点"><a href="#2-红黑树节点" class="headerlink" title="2.红黑树节点"></a>2.红黑树节点</h2><p>红黑树节点继承自红黑树基类。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _Val<span class="token operator">></span><span class="token keyword">struct</span> _Rb_tree_node <span class="token operator">:</span> <span class="token keyword">public</span> _Rb_tree_node_base<span class="token punctuation">{</span>    <span class="token keyword">typedef</span> _Rb_tree_node<span class="token operator">&lt;</span>_Value<span class="token operator">></span><span class="token operator">*</span> _Link_type<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//节点指针,指向数据节点</span>    _Value _M_value_field<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//节点数据域,即关键字</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><h2 id="3-红黑树迭代器"><a href="#3-红黑树迭代器" class="headerlink" title="3.红黑树迭代器"></a>3.红黑树迭代器</h2><p>红黑树迭代器里面有一个红黑树基类成员，然后通过该成员进行迭代器的相关操作。<br>同时，我们可以知道该迭代器属于<code>bidirectional_iterator_tag</code>。</p><p>里面也包含了萃取机相关需要的typedef。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _Tp<span class="token operator">></span><span class="token keyword">struct</span> _Rb_tree_iterator<span class="token punctuation">{</span>    <span class="token keyword">typedef</span> _Tp  value_type<span class="token punctuation">;</span>    <span class="token keyword">typedef</span> _Tp<span class="token operator">&amp;</span> reference<span class="token punctuation">;</span>    <span class="token keyword">typedef</span> _Tp<span class="token operator">*</span> pointer<span class="token punctuation">;</span>    <span class="token keyword">typedef</span> bidirectional_iterator_tag iterator_category<span class="token punctuation">;</span>    <span class="token keyword">typedef</span> ptrdiff_t                  difference_type<span class="token punctuation">;</span>    <span class="token keyword">typedef</span> _Rb_tree_iterator<span class="token operator">&lt;</span>_Tp<span class="token operator">></span>        _Self<span class="token punctuation">;</span>    <span class="token keyword">typedef</span> _Rb_tree_node_base<span class="token operator">::</span>_Base_ptr _Base_ptr<span class="token punctuation">;</span>    <span class="token keyword">typedef</span> _Rb_tree_node<span class="token operator">&lt;</span>_Tp<span class="token operator">></span><span class="token operator">*</span>           _Link_type<span class="token punctuation">;</span>    _Base_ptr _M_node<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>   </code></pre><p>获取数据</p><pre class=" language-cpp"><code class="language-cpp">reference<span class="token keyword">operator</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> _GLIBCXX_NOEXCEPT<span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">static_cast</span><span class="token operator">&lt;</span>_Link_type<span class="token operator">></span><span class="token punctuation">(</span>_M_node<span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">_M_valptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>pointer<span class="token keyword">operator</span><span class="token operator">-</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> _GLIBCXX_NOEXCEPT<span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span>_Link_type<span class="token operator">></span> <span class="token punctuation">(</span>_M_node<span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">_M_valptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre><p>重载++操作符</p><pre class=" language-cpp"><code class="language-cpp">_Self<span class="token operator">&amp;</span><span class="token keyword">operator</span><span class="token operator">++</span><span class="token punctuation">(</span><span class="token punctuation">)</span> _GLIBCXX_NOEXCEPT<span class="token punctuation">{</span>    _M_node <span class="token operator">=</span> <span class="token function">_Rb_tree_increment</span><span class="token punctuation">(</span>_M_node<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>而<code>_Rb_tree_increment</code>底层是<code>local_Rb_tree_increment</code>，如下实现：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">static</span> _Rb_tree_node_base <span class="token operator">*</span><span class="token function">local_Rb_tree_increment</span><span class="token punctuation">(</span> _Rb_tree_node_base<span class="token operator">*</span> __x <span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span> __x<span class="token operator">-</span><span class="token operator">></span>_M_right <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">)</span>       <span class="token comment" spellcheck="true">/* 存在右子树,那么下一个节点为右子树的最小节点 */</span>    <span class="token punctuation">{</span>        __x <span class="token operator">=</span> __x<span class="token operator">-</span><span class="token operator">></span>_M_right<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span> __x<span class="token operator">-</span><span class="token operator">></span>_M_left <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">)</span>            __x <span class="token operator">=</span> __x<span class="token operator">-</span><span class="token operator">></span>_M_left<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">else</span>  <span class="token punctuation">{</span>                                <span class="token comment" spellcheck="true">/* 不存在右子树,那么分为两种情况：自底往上搜索,当前节点为父节点的左孩子的时候,父节点就是后继节点； */</span><span class="token comment" spellcheck="true">/* 第二种情况:_x为header节点了,那么_x就是最后的后继节点. 简言之_x为最小节点且往上回溯,一直为父节点的右孩子,直到_x变为父节点,_y为其右孩子 */</span>        _Rb_tree_node_base <span class="token operator">*</span>__y <span class="token operator">=</span> __x<span class="token operator">-</span><span class="token operator">></span>_M_parent<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span> __x <span class="token operator">==</span> __y<span class="token operator">-</span><span class="token operator">></span>_M_right <span class="token punctuation">)</span>        <span class="token punctuation">{</span>            __x    <span class="token operator">=</span> __y<span class="token punctuation">;</span>            __y    <span class="token operator">=</span> __y<span class="token operator">-</span><span class="token operator">></span>_M_parent<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span> __x<span class="token operator">-</span><span class="token operator">></span>_M_right <span class="token operator">!=</span> __y <span class="token punctuation">)</span>            __x <span class="token operator">=</span> __y<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>__x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>重载–操作符：</p><pre class=" language-cpp"><code class="language-cpp">_Self<span class="token operator">&amp;</span><span class="token keyword">operator</span><span class="token operator">--</span><span class="token punctuation">(</span><span class="token punctuation">)</span> _GLIBCXX_NOEXCEPT<span class="token punctuation">{</span>    _M_node <span class="token operator">=</span> <span class="token function">_Rb_tree_decrement</span><span class="token punctuation">(</span>_M_node<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>同理，而<code>_Rb_tree_decrement</code>底层是<code>local_Rb_tree_decrement</code>，如下实现：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">static</span> _Rb_tree_node_base <span class="token operator">*</span><span class="token function">local_Rb_tree_decrement</span><span class="token punctuation">(</span> _Rb_tree_node_base <span class="token operator">*</span> __x <span class="token punctuation">)</span><span class="token keyword">throw</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">/* header节点 */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span> __x<span class="token operator">-</span><span class="token operator">></span>_M_color <span class="token operator">==</span>         _S_red         <span class="token operator">&amp;&amp;</span> __x         <span class="token operator">-</span><span class="token operator">></span>_M_parent<span class="token operator">-</span><span class="token operator">></span>_M_parent <span class="token operator">==</span> __x <span class="token punctuation">)</span>        __x <span class="token operator">=</span> __x<span class="token operator">-</span><span class="token operator">></span>_M_right<span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span> __x<span class="token operator">-</span><span class="token operator">></span>_M_left <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">)</span> <span class="token comment" spellcheck="true">/* 左节点不为空,返回左子树中最大的节点 */</span>    <span class="token punctuation">{</span>        _Rb_tree_node_base <span class="token operator">*</span>__y <span class="token operator">=</span> __x<span class="token operator">-</span><span class="token operator">></span>_M_left<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span> __y<span class="token operator">-</span><span class="token operator">></span>_M_right <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">)</span>            __y <span class="token operator">=</span> __y<span class="token operator">-</span><span class="token operator">></span>_M_right<span class="token punctuation">;</span>        __x <span class="token operator">=</span> __y<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">else</span>  <span class="token punctuation">{</span><span class="token comment" spellcheck="true">/* 自底向上找到当前节点为其父节点的右孩子,那么父节点就是前驱节点 */</span>        _Rb_tree_node_base <span class="token operator">*</span>__y <span class="token operator">=</span> __x<span class="token operator">-</span><span class="token operator">></span>_M_parent<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span> __x <span class="token operator">==</span> __y<span class="token operator">-</span><span class="token operator">></span>_M_left <span class="token punctuation">)</span>        <span class="token punctuation">{</span>            __x    <span class="token operator">=</span> __y<span class="token punctuation">;</span>            __y    <span class="token operator">=</span> __y<span class="token operator">-</span><span class="token operator">></span>_M_parent<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        __x <span class="token operator">=</span> __y<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span>        <span class="token punctuation">(</span>__x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>重载==与!=操作符，直接判断节点指针是否相等。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">bool</span><span class="token keyword">operator</span><span class="token operator">==</span><span class="token punctuation">(</span><span class="token keyword">const</span> _Self<span class="token operator">&amp;</span> __x<span class="token punctuation">)</span> <span class="token keyword">const</span> _GLIBCXX_NOEXCEPT<span class="token punctuation">{</span> <span class="token keyword">return</span> _M_node <span class="token operator">==</span> __x<span class="token punctuation">.</span>_M_node<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">bool</span><span class="token keyword">operator</span><span class="token operator">!=</span><span class="token punctuation">(</span><span class="token keyword">const</span> _Self<span class="token operator">&amp;</span> __x<span class="token punctuation">)</span> <span class="token keyword">const</span> _GLIBCXX_NOEXCEPT<span class="token punctuation">{</span> <span class="token keyword">return</span> _M_node <span class="token operator">!=</span> __x<span class="token punctuation">.</span>_M_node<span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre><p>其他重要函数，黑节点统计：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token function">_Rb_tree_black_count</span><span class="token punctuation">(</span><span class="token keyword">const</span> _Rb_tree_node_base <span class="token operator">*</span>__node<span class="token punctuation">,</span>                     <span class="token keyword">const</span> _Rb_tree_node_base <span class="token operator">*</span>__root<span class="token punctuation">)</span> <span class="token keyword">throw</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>__node <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> __sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">do</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>__node<span class="token operator">-</span><span class="token operator">></span>_M_color <span class="token operator">==</span> _S_black<span class="token punctuation">)</span>            <span class="token operator">++</span>__sum<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>__node <span class="token operator">==</span> __root<span class="token punctuation">)</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        __node <span class="token operator">=</span> __node<span class="token operator">-</span><span class="token operator">></span>_M_parent<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> __sum<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>后面来阐述最重要的插入操作。</p><h2 id="4-红黑树操作"><a href="#4-红黑树操作" class="headerlink" title="4.红黑树操作"></a>4.红黑树操作</h2><p>比较重要的是，里面使用节点基类来声明了一个指针。还包含了一个<code>_Rb_tree_impl</code>用来对红黑树初始化操作与内存管理操作。里面还包含了两种迭代器，一个rbtree，另一个是reverse，说明支持rbegin,rend操作。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _Key<span class="token punctuation">,</span> <span class="token keyword">typename</span> _Val<span class="token punctuation">,</span> <span class="token keyword">typename</span> _KeyOfValue<span class="token punctuation">,</span>           <span class="token keyword">typename</span> _Compare<span class="token punctuation">,</span> <span class="token keyword">typename</span> _Alloc <span class="token operator">=</span> allocator<span class="token operator">&lt;</span>_Val<span class="token operator">></span> <span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">_Rb_tree</span><span class="token punctuation">{</span><span class="token keyword">protected</span><span class="token operator">:</span>    <span class="token keyword">typedef</span> _Rb_tree_node_base<span class="token operator">*</span>         _Base_ptr<span class="token punctuation">;</span> <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _Key_compare<span class="token punctuation">,</span>     <span class="token keyword">bool</span> _Is_pod_comparator <span class="token operator">=</span> <span class="token function">__is_pod</span><span class="token punctuation">(</span>_Key_compare<span class="token punctuation">)</span><span class="token operator">></span>    <span class="token keyword">struct</span> _Rb_tree_impl <span class="token operator">:</span> <span class="token keyword">public</span> _Node_allocator    <span class="token punctuation">{</span>      _Key_compare        _M_key_compare<span class="token punctuation">;</span>      _Rb_tree_node_base     _M_header<span class="token punctuation">;</span>      size_type         _M_node_count<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// Keeps track of size of tree.</span>      <span class="token function">_Rb_tree_impl</span><span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token operator">:</span> <span class="token function">_Node_allocator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">_M_key_compare</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">_M_header</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token function">_M_node_count</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>      <span class="token punctuation">{</span> <span class="token function">_M_initialize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>      <span class="token function">_Rb_tree_impl</span><span class="token punctuation">(</span><span class="token keyword">const</span> _Key_compare<span class="token operator">&amp;</span> __comp<span class="token punctuation">,</span> <span class="token keyword">const</span> _Node_allocator<span class="token operator">&amp;</span> __a<span class="token punctuation">)</span>      <span class="token operator">:</span> <span class="token function">_Node_allocator</span><span class="token punctuation">(</span>__a<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">_M_key_compare</span><span class="token punctuation">(</span>__comp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">_M_header</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token function">_M_node_count</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>      <span class="token punctuation">{</span> <span class="token function">_M_initialize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token keyword">private</span><span class="token operator">:</span>      <span class="token keyword">void</span>      <span class="token function">_M_initialize</span><span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_header<span class="token punctuation">.</span>_M_color <span class="token operator">=</span> _S_red<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_header<span class="token punctuation">.</span>_M_parent <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_header<span class="token punctuation">.</span>_M_left <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_header<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_header<span class="token punctuation">.</span>_M_right <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_header<span class="token punctuation">;</span>      <span class="token punctuation">}</span>         <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">public</span><span class="token operator">:</span>     <span class="token keyword">typedef</span> _Rb_tree_iterator<span class="token operator">&lt;</span>value_type<span class="token operator">></span>       iterator<span class="token punctuation">;</span>    <span class="token keyword">typedef</span> std<span class="token operator">::</span>reverse_iterator<span class="token operator">&lt;</span>iterator<span class="token operator">></span>     reverse_iterator<span class="token punctuation">;</span> <span class="token keyword">private</span><span class="token operator">:</span>_Rb_tree_impl<span class="token operator">&lt;</span>_Compare<span class="token operator">></span> _M_impl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><blockquote><p>获取红黑树根节点、最左与最右节点</p></blockquote><p>回到一开始的图：<br><img src="https://raw.githubusercontent.com/Light-City/cloudimg/master/rbt.png" alt="rbt.png">。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 图中100 节点</span> _Base_ptr<span class="token operator">&amp;</span><span class="token function">_M_root</span><span class="token punctuation">(</span><span class="token punctuation">)</span> _GLIBCXX_NOEXCEPT<span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_header<span class="token punctuation">.</span>_M_parent<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 图中most left标记</span>_Base_ptr<span class="token operator">&amp;</span><span class="token function">_M_leftmost</span><span class="token punctuation">(</span><span class="token punctuation">)</span> _GLIBCXX_NOEXCEPT<span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_header<span class="token punctuation">.</span>_M_left<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 图中most right标记</span> _Base_ptr<span class="token operator">&amp;</span><span class="token function">_M_rightmost</span><span class="token punctuation">(</span><span class="token punctuation">)</span> _GLIBCXX_NOEXCEPT<span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_header<span class="token punctuation">.</span>_M_right<span class="token punctuation">;</span> <span class="token punctuation">}</span> _Link_type <span class="token comment" spellcheck="true">// 图中begin()标记</span><span class="token function">_M_begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> _GLIBCXX_NOEXCEPT<span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span>_Link_type<span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_header<span class="token punctuation">.</span>_M_parent<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 图中end()标记</span>_Link_type<span class="token function">_M_end</span><span class="token punctuation">(</span><span class="token punctuation">)</span> _GLIBCXX_NOEXCEPT<span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token keyword">reinterpret_cast</span><span class="token operator">&lt;</span>_Link_type<span class="token operator">></span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_header<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre><p>我们再看代码是不是非常清晰！</p><h2 id="5-红黑树插入"><a href="#5-红黑树插入" class="headerlink" title="5.红黑树插入"></a>5.红黑树插入</h2><h3 id="5-1-旋转过程"><a href="#5-1-旋转过程" class="headerlink" title="5.1 旋转过程"></a>5.1 旋转过程</h3><p>左旋转是将该节点的右节点设置为它的父节点，该节点将变成刚才右节点的左孩子</p><p>直接看源码中的图与代码对比即可。</p><p>在<code>tree.cc</code>源码中实现函数为<code>local_Rb_tree_rotate_left</code>与<code>local_Rb_tree_rotate_right</code>。<br>下面我们将源码进行剖析成比较容易理解的代码，具体见注释。<br>大家会发现函数名与变量名与源码不同，是因为下面是当时自己实现的，但是不影响源码阅读，就直接拿来对比了。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">/*** 当前节点的左旋转过程* 将该节点的右节点设置为它的父节点，该节点将变成刚才右节点的左孩子* @param _x*/</span><span class="token comment" spellcheck="true">//    _x                      _y</span><span class="token comment" spellcheck="true">//  /   \     左旋转         /  \</span><span class="token comment" spellcheck="true">// T1   _y   --------->   _x    T3</span><span class="token comment" spellcheck="true">//     / \              /   \</span><span class="token comment" spellcheck="true">//    T2 T3            T1   T2</span><span class="token keyword">void</span> <span class="token function">leftRotate</span><span class="token punctuation">(</span>Node <span class="token operator">*</span>_x<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// step1 处理_x的右孩子</span>    <span class="token comment" spellcheck="true">// 右节点变为_x节点的父亲节点,先保存一下右节点</span>    Node <span class="token operator">*</span>_y <span class="token operator">=</span> _x<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// T2变为node的右节点</span>    _x<span class="token operator">-</span><span class="token operator">></span>right <span class="token operator">=</span> _y<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token constant">NULL</span> <span class="token operator">!=</span> _y<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">)</span>        _y<span class="token operator">-</span><span class="token operator">></span>left<span class="token operator">-</span><span class="token operator">></span>parent <span class="token operator">=</span> _x<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// step2 处理_y与父亲节点关系</span>    _y<span class="token operator">-</span><span class="token operator">></span>parent <span class="token operator">=</span> _x<span class="token operator">-</span><span class="token operator">></span>parent<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 原来_x的父亲变为_y的父亲</span>    <span class="token comment" spellcheck="true">// 说明原来_x为root节点,此时需要将_y设为新root节点</span>    <span class="token comment" spellcheck="true">// 或者判断NULL == _y->parent</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>_x <span class="token operator">==</span> root<span class="token punctuation">)</span>        root <span class="token operator">=</span> _y<span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>_x <span class="token operator">==</span> _x<span class="token operator">-</span><span class="token operator">></span>parent<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 原_x的父节点的左孩子连接新节点_y</span>        _x<span class="token operator">-</span><span class="token operator">></span>parent<span class="token operator">-</span><span class="token operator">></span>left <span class="token operator">=</span> _y<span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token comment" spellcheck="true">// 原_x的父节点的右孩子连接新节点_y</span>        _x<span class="token operator">-</span><span class="token operator">></span>parent<span class="token operator">-</span><span class="token operator">></span>right <span class="token operator">=</span> _y<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// step3 处理_x与_y关系</span>    _y<span class="token operator">-</span><span class="token operator">></span>left <span class="token operator">=</span> _x<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// _y的左孩子为_x</span>    _x<span class="token operator">-</span><span class="token operator">></span>parent <span class="token operator">=</span> _y<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// _x的父亲是_y</span><span class="token punctuation">}</span></code></pre><p>同理，右旋转如下：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//        _x                      _y</span><span class="token comment" spellcheck="true">//      /   \     右旋转         /  \</span><span class="token comment" spellcheck="true">//     _y    T2 ------------->  T0  _x</span><span class="token comment" spellcheck="true">//    /  \                         /  \</span><span class="token comment" spellcheck="true">//   T0  T1                       T1  T2</span><span class="token keyword">void</span> <span class="token function">rightRotate</span><span class="token punctuation">(</span>Node <span class="token operator">*</span>_x<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// step1 处理_x的左孩子</span>    <span class="token comment" spellcheck="true">// 左节点变为_x节点的父亲节点,先保存一下左节点</span>    Node <span class="token operator">*</span>_y <span class="token operator">=</span> _x<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// T1变为_x的左孩子</span>    _x<span class="token operator">-</span><span class="token operator">></span>left <span class="token operator">=</span> _y<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token constant">NULL</span> <span class="token operator">!=</span> _y<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">)</span>        _y<span class="token operator">-</span><span class="token operator">></span>right<span class="token operator">-</span><span class="token operator">></span>parent <span class="token operator">=</span> _x<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// step2 处理_y与父节点之间的关系</span>    <span class="token comment" spellcheck="true">// 或者判断_x->parent==NULL</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>_x <span class="token operator">==</span> root<span class="token punctuation">)</span>        root <span class="token operator">=</span> _y<span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>_x <span class="token operator">==</span> _x<span class="token operator">-</span><span class="token operator">></span>parent<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">)</span>        _x<span class="token operator">-</span><span class="token operator">></span>parent<span class="token operator">-</span><span class="token operator">></span>right <span class="token operator">=</span> _y<span class="token punctuation">;</span>    <span class="token keyword">else</span>        _x<span class="token operator">-</span><span class="token operator">></span>parent<span class="token operator">-</span><span class="token operator">></span>left <span class="token operator">=</span> _y<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// step3 处理_x与_y关系</span>    _y<span class="token operator">-</span><span class="token operator">></span>right <span class="token operator">=</span> _x<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// _y的右孩子为_x</span>    _x<span class="token operator">-</span><span class="token operator">></span>parent <span class="token operator">=</span> _y<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// _x的父亲是_y</span><span class="token punctuation">}</span></code></pre><p>case 1.1: 父节点为红色且其叔叔节点也为红色，则将父亲、叔叔置为黑色，祖父置为红色。</p><p><img src="https://raw.githubusercontent.com/Light-City/cloudimg/master/rb_1.png" alt="rb_1.png"></p><p>case 1.2 若无叔叔节点或者其叔叔节点为黑色分为下面两种：</p><p>情况1.2.1：x的叔叔节点y是黑色且x是一个右孩子</p><p><img src="https://raw.githubusercontent.com/Light-City/cloudimg/master/rb1.2.1.png" alt="rb1.2.1.png"></p><p>情况1.2.2：x的叔叔节点y是黑色且x是一个左孩子</p><p><img src="https://raw.githubusercontent.com/Light-City/cloudimg/master/rb1.2.2.png" alt="rb1.2.2.png"></p><p>对应源代码中：</p><pre class=" language-cpp"><code class="language-cpp">_Rb_tree_node_base <span class="token operator">*</span><span class="token keyword">const</span> __y <span class="token operator">=</span> __xpp<span class="token operator">-</span><span class="token operator">></span>_M_right<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 得到叔叔节点</span><span class="token keyword">if</span> <span class="token punctuation">(</span>__y <span class="token operator">&amp;&amp;</span> __y<span class="token operator">-</span><span class="token operator">></span>_M_color <span class="token operator">==</span> _S_red<span class="token punctuation">)</span>     <span class="token comment" spellcheck="true">// case1: 叔叔节点存在，且为红色</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**        * 解决办法是：颜色翻转，父亲与叔叔的颜色都变为黑色,祖父节点变为红色,然后当前节点设为祖父，依次网上来判断是否破坏了红黑树性质        */</span>    __x<span class="token operator">-</span><span class="token operator">></span>_M_parent<span class="token operator">-</span><span class="token operator">></span>_M_color <span class="token operator">=</span> _S_black<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 将其父节点改为黑色</span>    __y<span class="token operator">-</span><span class="token operator">></span>_M_color <span class="token operator">=</span> _S_black<span class="token punctuation">;</span>               <span class="token comment" spellcheck="true">// 将其叔叔节点改为黑色</span>    __xpp<span class="token operator">-</span><span class="token operator">></span>_M_color <span class="token operator">=</span> _S_red<span class="token punctuation">;</span>               <span class="token comment" spellcheck="true">// 将其祖父节点改为红色</span>    __x <span class="token operator">=</span> __xpp<span class="token punctuation">;</span>                            <span class="token comment" spellcheck="true">// 修改_x,往上回溯</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 无叔叔或者叔叔为黑色</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>__x <span class="token operator">==</span> __x<span class="token operator">-</span><span class="token operator">></span>_M_parent<span class="token operator">-</span><span class="token operator">></span>_M_right<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token comment" spellcheck="true">// 当前节点为父亲节点的右孩子</span>        __x <span class="token operator">=</span> __x<span class="token operator">-</span><span class="token operator">></span>_M_parent<span class="token punctuation">;</span>        <span class="token function">local_Rb_tree_rotate_left</span><span class="token punctuation">(</span>__x<span class="token punctuation">,</span> __root<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 以父节点进行左旋转</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 旋转之后,节点x变成其父节点的左孩子</span>    __x<span class="token operator">-</span><span class="token operator">></span>_M_parent<span class="token operator">-</span><span class="token operator">></span>_M_color <span class="token operator">=</span> _S_black<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 将其父亲节点改为黑色</span>    __xpp<span class="token operator">-</span><span class="token operator">></span>_M_color <span class="token operator">=</span> _S_red<span class="token punctuation">;</span>                       <span class="token comment" spellcheck="true">// 将其祖父节点改为红色</span>    <span class="token function">local_Rb_tree_rotate_right</span><span class="token punctuation">(</span>__xpp<span class="token punctuation">,</span> __root<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 以祖父节点右旋转</span><span class="token punctuation">}</span></code></pre><p>另外一个是上述对称过程：</p><p>case 2.1: 父节点为红色且其叔叔节点也为红色，则将父亲、叔叔置为黑色，祖父置为红色。</p><p><img src="https://raw.githubusercontent.com/Light-City/cloudimg/master/rb2.1.png" alt="rb2.1.png"></p><p>case 2.2 若无叔叔节点或者其叔叔节点为黑色</p><p><img src="https://raw.githubusercontent.com/Light-City/cloudimg/master/rb2.2.1.png" alt="rb2.2.1.png"></p><p>情况2.2.1：x的叔叔节点y是黑色且x是一个左孩子</p><p><img src="https://raw.githubusercontent.com/Light-City/cloudimg/master/rb2.2.2.png" alt="rb2.2.2.png"></p><pre class=" language-cpp"><code class="language-cpp">_Rb_tree_node_base <span class="token operator">*</span><span class="token keyword">const</span> __y <span class="token operator">=</span> __xpp<span class="token operator">-</span><span class="token operator">></span>_M_left<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 保存叔叔节点</span><span class="token keyword">if</span> <span class="token punctuation">(</span>__y <span class="token operator">&amp;&amp;</span> __y<span class="token operator">-</span><span class="token operator">></span>_M_color <span class="token operator">==</span> _S_red<span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token comment" spellcheck="true">// 叔叔节点存在且为红色</span>    __x<span class="token operator">-</span><span class="token operator">></span>_M_parent<span class="token operator">-</span><span class="token operator">></span>_M_color <span class="token operator">=</span> _S_black<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 父亲节点改为黑色</span>    __y<span class="token operator">-</span><span class="token operator">></span>_M_color <span class="token operator">=</span> _S_black<span class="token punctuation">;</span>               <span class="token comment" spellcheck="true">// 祖父节点改为红色</span>    __xpp<span class="token operator">-</span><span class="token operator">></span>_M_color <span class="token operator">=</span> _S_red<span class="token punctuation">;</span>    __x <span class="token operator">=</span> __xpp<span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 若无叔叔节点或者其叔叔节点为黑色</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>__x <span class="token operator">==</span> __x<span class="token operator">-</span><span class="token operator">></span>_M_parent<span class="token operator">-</span><span class="token operator">></span>_M_left<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">// 当前节点为父亲节点的左孩子</span>        __x <span class="token operator">=</span> __x<span class="token operator">-</span><span class="token operator">></span>_M_parent<span class="token punctuation">;</span>        <span class="token function">local_Rb_tree_rotate_right</span><span class="token punctuation">(</span>__x<span class="token punctuation">,</span> __root<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 以父节点右旋转</span>    <span class="token punctuation">}</span>    __x<span class="token operator">-</span><span class="token operator">></span>_M_parent<span class="token operator">-</span><span class="token operator">></span>_M_color <span class="token operator">=</span> _S_black<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 父节点置为黑色</span>    __xpp<span class="token operator">-</span><span class="token operator">></span>_M_color <span class="token operator">=</span> _S_red<span class="token punctuation">;</span>                   <span class="token comment" spellcheck="true">// 祖父节点置为红色</span>    <span class="token function">local_Rb_tree_rotate_left</span><span class="token punctuation">(</span>__xpp<span class="token punctuation">,</span> __root<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 左旋转</span><span class="token punctuation">}</span></code></pre><p><code>_Rb_tree_insert_and_rebalance</code>完整解析：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">void</span><span class="token function">_Rb_tree_insert_and_rebalance</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">bool</span> __insert_left<span class="token punctuation">,</span>                              _Rb_tree_node_base <span class="token operator">*</span>__x<span class="token punctuation">,</span>                              _Rb_tree_node_base <span class="token operator">*</span>__p<span class="token punctuation">,</span>                              _Rb_tree_node_base <span class="token operator">&amp;</span>__header<span class="token punctuation">)</span> <span class="token keyword">throw</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    _Rb_tree_node_base <span class="token operator">*</span> <span class="token operator">&amp;</span>__root <span class="token operator">=</span> __header<span class="token punctuation">.</span>_M_parent<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// Initialize fields in new node to insert.</span>    __x<span class="token operator">-</span><span class="token operator">></span>_M_parent <span class="token operator">=</span> __p<span class="token punctuation">;</span>    __x<span class="token operator">-</span><span class="token operator">></span>_M_left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    __x<span class="token operator">-</span><span class="token operator">></span>_M_right <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    __x<span class="token operator">-</span><span class="token operator">></span>_M_color <span class="token operator">=</span> _S_red<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 处理__header部分</span>    <span class="token comment" spellcheck="true">// Insert.</span>    <span class="token comment" spellcheck="true">// Make new node child of parent and maintain root, leftmost and</span>    <span class="token comment" spellcheck="true">// rightmost nodes.</span>    <span class="token comment" spellcheck="true">// N.B. First node is always inserted left.</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>__insert_left<span class="token punctuation">)</span> <span class="token punctuation">{</span>        __p<span class="token operator">-</span><span class="token operator">></span>_M_left <span class="token operator">=</span> __x<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// also makes leftmost = __x when __p == &amp;__header</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>__p <span class="token operator">==</span> <span class="token operator">&amp;</span>__header<span class="token punctuation">)</span> <span class="token punctuation">{</span>            __header<span class="token punctuation">.</span>_M_parent <span class="token operator">=</span> __x<span class="token punctuation">;</span>            __header<span class="token punctuation">.</span>_M_right <span class="token operator">=</span> __x<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>__p <span class="token operator">==</span> __header<span class="token punctuation">.</span>_M_left<span class="token punctuation">)</span>            __header<span class="token punctuation">.</span>_M_left <span class="token operator">=</span> __x<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// maintain leftmost pointing to min node</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        __p<span class="token operator">-</span><span class="token operator">></span>_M_right <span class="token operator">=</span> __x<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>__p <span class="token operator">==</span> __header<span class="token punctuation">.</span>_M_right<span class="token punctuation">)</span>            __header<span class="token punctuation">.</span>_M_right <span class="token operator">=</span> __x<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// maintain rightmost pointing to max node</span>    <span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// Rebalance.</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>__x <span class="token operator">!=</span> __root           <span class="token operator">&amp;&amp;</span> __x<span class="token operator">-</span><span class="token operator">></span>_M_parent<span class="token operator">-</span><span class="token operator">></span>_M_color <span class="token operator">==</span> _S_red<span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">// 若新插入节点不是为RB-Tree的根节点，且其父节点color属性也是红色,即违反了性质4.</span>    <span class="token punctuation">{</span>        _Rb_tree_node_base <span class="token operator">*</span><span class="token keyword">const</span> __xpp <span class="token operator">=</span> __x<span class="token operator">-</span><span class="token operator">></span>_M_parent<span class="token operator">-</span><span class="token operator">></span>_M_parent<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 祖父节点</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>__x<span class="token operator">-</span><span class="token operator">></span>_M_parent <span class="token operator">==</span> __xpp<span class="token operator">-</span><span class="token operator">></span>_M_left<span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">// 父亲是祖父节点的左孩子</span>        <span class="token punctuation">{</span>            _Rb_tree_node_base <span class="token operator">*</span><span class="token keyword">const</span> __y <span class="token operator">=</span> __xpp<span class="token operator">-</span><span class="token operator">></span>_M_right<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 得到叔叔节点</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>__y <span class="token operator">&amp;&amp;</span> __y<span class="token operator">-</span><span class="token operator">></span>_M_color <span class="token operator">==</span> _S_red<span class="token punctuation">)</span>     <span class="token comment" spellcheck="true">// case1: 叔叔节点存在，且为红色</span>            <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">/**                 * 解决办法是：颜色翻转，父亲与叔叔的颜色都变为黑色,祖父节点变为红色,然后当前节点设为祖父，依次网上来判断是否破坏了红黑树性质                 */</span>                __x<span class="token operator">-</span><span class="token operator">></span>_M_parent<span class="token operator">-</span><span class="token operator">></span>_M_color <span class="token operator">=</span> _S_black<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 将其父节点改为黑色</span>                __y<span class="token operator">-</span><span class="token operator">></span>_M_color <span class="token operator">=</span> _S_black<span class="token punctuation">;</span>               <span class="token comment" spellcheck="true">// 将其叔叔节点改为黑色</span>                __xpp<span class="token operator">-</span><span class="token operator">></span>_M_color <span class="token operator">=</span> _S_red<span class="token punctuation">;</span>               <span class="token comment" spellcheck="true">// 将其祖父节点改为红色</span>                __x <span class="token operator">=</span> __xpp<span class="token punctuation">;</span>                            <span class="token comment" spellcheck="true">// 修改_x,往上回溯</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 无叔叔或者叔叔为黑色</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>__x <span class="token operator">==</span> __x<span class="token operator">-</span><span class="token operator">></span>_M_parent<span class="token operator">-</span><span class="token operator">></span>_M_right<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token comment" spellcheck="true">// 当前节点为父亲节点的右孩子</span>                    __x <span class="token operator">=</span> __x<span class="token operator">-</span><span class="token operator">></span>_M_parent<span class="token punctuation">;</span>                    <span class="token function">local_Rb_tree_rotate_left</span><span class="token punctuation">(</span>__x<span class="token punctuation">,</span> __root<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 以父节点进行左旋转</span>                <span class="token punctuation">}</span>                <span class="token comment" spellcheck="true">// 旋转之后,节点x变成其父节点的左孩子</span>                __x<span class="token operator">-</span><span class="token operator">></span>_M_parent<span class="token operator">-</span><span class="token operator">></span>_M_color <span class="token operator">=</span> _S_black<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 将其父亲节点改为黑色</span>                __xpp<span class="token operator">-</span><span class="token operator">></span>_M_color <span class="token operator">=</span> _S_red<span class="token punctuation">;</span>                       <span class="token comment" spellcheck="true">// 将其祖父节点改为红色</span>                <span class="token function">local_Rb_tree_rotate_right</span><span class="token punctuation">(</span>__xpp<span class="token punctuation">,</span> __root<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 以祖父节点右旋转</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 父亲是祖父节点的右孩子</span>            _Rb_tree_node_base <span class="token operator">*</span><span class="token keyword">const</span> __y <span class="token operator">=</span> __xpp<span class="token operator">-</span><span class="token operator">></span>_M_left<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 保存叔叔节点</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>__y <span class="token operator">&amp;&amp;</span> __y<span class="token operator">-</span><span class="token operator">></span>_M_color <span class="token operator">==</span> _S_red<span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token comment" spellcheck="true">// 叔叔节点存在且为红色</span>                __x<span class="token operator">-</span><span class="token operator">></span>_M_parent<span class="token operator">-</span><span class="token operator">></span>_M_color <span class="token operator">=</span> _S_black<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 父亲节点改为黑色</span>                __y<span class="token operator">-</span><span class="token operator">></span>_M_color <span class="token operator">=</span> _S_black<span class="token punctuation">;</span>               <span class="token comment" spellcheck="true">// 祖父节点改为红色</span>                __xpp<span class="token operator">-</span><span class="token operator">></span>_M_color <span class="token operator">=</span> _S_red<span class="token punctuation">;</span>                __x <span class="token operator">=</span> __xpp<span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 若无叔叔节点或者其叔叔节点为黑色</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>__x <span class="token operator">==</span> __x<span class="token operator">-</span><span class="token operator">></span>_M_parent<span class="token operator">-</span><span class="token operator">></span>_M_left<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">// 当前节点为父亲节点的左孩子</span>                    __x <span class="token operator">=</span> __x<span class="token operator">-</span><span class="token operator">></span>_M_parent<span class="token punctuation">;</span>                    <span class="token function">local_Rb_tree_rotate_right</span><span class="token punctuation">(</span>__x<span class="token punctuation">,</span> __root<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 以父节点右旋转</span>                <span class="token punctuation">}</span>                __x<span class="token operator">-</span><span class="token operator">></span>_M_parent<span class="token operator">-</span><span class="token operator">></span>_M_color <span class="token operator">=</span> _S_black<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 父节点置为黑色</span>                __xpp<span class="token operator">-</span><span class="token operator">></span>_M_color <span class="token operator">=</span> _S_red<span class="token punctuation">;</span>                   <span class="token comment" spellcheck="true">// 祖父节点置为红色</span>                <span class="token function">local_Rb_tree_rotate_left</span><span class="token punctuation">(</span>__xpp<span class="token punctuation">,</span> __root<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 左旋转</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//若新插入节点为根节点,则违反性质2</span>    <span class="token comment" spellcheck="true">//只需将其重新赋值为黑色即可</span>    __root<span class="token operator">-</span><span class="token operator">></span>_M_color <span class="token operator">=</span> _S_black<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="5-2插入总结"><a href="#5-2插入总结" class="headerlink" title="5.2插入总结"></a>5.2插入总结</h2><p>根据上述插入过程与源码分析，我们得出下面三种：<br>假设P代码父亲节点，N代表当前新插入节点，U代表叔叔节点，G代表祖父节点。</p><p>case 1:U为红色，P、N也都为红色，则可以通过改变颜色，自底向上递归调整，下次N就变味G，往上判断即可。如果碰巧将根节点染成了红色, 可以在算法的最后强制root改为黑。</p><p><img src="https://raw.githubusercontent.com/Light-City/cloudimg/master/1_1.png" alt="1_1.png"></p><p>case 2:U为黑色，考虑N是P的左孩子还是右孩子。</p><p>case2.1 如果是右孩子,先进行左旋转，再进入下一种情况。</p><p><img src="https://raw.githubusercontent.com/Light-City/cloudimg/master/2_1.png" alt="2_1.png"></p><p>case2.2 可能是上述情况变化而来，但不一定是！策略为：右旋转，改变颜色。</p><p><img src="https://raw.githubusercontent.com/Light-City/cloudimg/master/rb2_2.png" alt="rb2_2.png"></p><p>经过上述源码的分析得知，红黑树插入为镜像变换，另一种情况刚好相反。</p><p>删除操作，比较复杂，这里就暂时没分析了，后面补上。。。</p><h2 id="6-使用"><a href="#6-使用" class="headerlink" title="6.使用"></a>6.使用</h2><p>前面说了那么多，如何使用呢？</p><p>引入头文件：</p><pre><code>#include&lt;map&gt;或者&lt;set&gt;</code></pre><p>类定义：</p><pre><code>_Rb_tree&lt;int, int, _Identity&lt;int&gt;, less&lt;int&gt;&gt; itree;</code></pre><p>然后调用相应函数即可。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> STL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ STL源码剖析之序列式容器deque</title>
      <link href="/2019/10/16/deque/"/>
      <url>/2019/10/16/deque/</url>
      
        <content type="html"><![CDATA[<h1 id="C-STL源码剖析之序列式容器deque"><a href="#C-STL源码剖析之序列式容器deque" class="headerlink" title="C++ STL源码剖析之序列式容器deque"></a>C++ STL源码剖析之序列式容器deque</h1><h2 id="0-导语"><a href="#0-导语" class="headerlink" title="0.导语"></a>0.导语</h2><p>deque是一种双向开口的分段连续线性空间(简单理解为：双端队列)，可以在头尾端进行元素的插入和删除。</p><p>deque与vector最大的差异就是：</p><ul><li><p>deque允许于常数时间内对头端进行插入或删除元素；</p></li><li><p>deque是分段连续线性空间，随时可以增加一段新的空间；</p></li></ul><p>deque不像vector那样，vector当内存不够时，需重新分配/复制数据/释放原始空间；不过deque的迭代器设置比vector复杂，因为迭代器不能使用普通指针，因此尽量使用vector。</p><h2 id="1-deque中控器"><a href="#1-deque中控器" class="headerlink" title="1.deque中控器"></a>1.deque中控器</h2><p>用户看起来deque使用的是连续空间，实际上是<strong>分段连续线性空间</strong>。为了管理分段空间deque容器引入了map，称之为中控器，map是一块连续的空间，其中每个元素是指向缓冲区的指针，缓冲区才是deque存储数据的主体。</p><p><img src="https://raw.githubusercontent.com/Light-City/cloudimg/master/deque_r.png" alt="deque_r.png"></p><p>在上图中，buffer称为缓冲区，显示map size的一段连续空间就是中控器。</p><p>中控器包含了map size,指向buffer的指针，deque的开始迭代器与结尾迭代器。</p><pre class=" language-cpp"><code class="language-cpp">_Tp        <span class="token operator">*</span><span class="token operator">*</span>_M_map<span class="token punctuation">;</span>size_t        _M_map_size<span class="token punctuation">;</span>iterator    _M_start<span class="token punctuation">;</span>iterator    _M_finish<span class="token punctuation">;</span></code></pre><p>由于buffer也是指针，所以<code>_Tp</code>是指针的指针。</p><p>deque继承自<code>_Deque_base</code>,而<code>_Deque_base</code>里面有一个<code>_M_impl</code>。</p><p><img src="https://raw.githubusercontent.com/Light-City/cloudimg/master/deque_bacse.png" alt="deque_base.png"></p><p>根据下图与上述描述，可以知道，中控器是由<code>_Deque_impl</code>实现的。</p><p><img src="https://raw.githubusercontent.com/Light-City/cloudimg/master/impl.png" alt="impl.png"></p><p>而deque是使用基类<code>_Deque_base</code>来完成内存管理与中控器管理。</p><h2 id="2-高端的迭代器"><a href="#2-高端的迭代器" class="headerlink" title="2.高端的迭代器"></a>2.高端的迭代器</h2><p>对于deque来说，它的迭代器设计的非常棒！</p><p>如下图所示：<br><img src="https://raw.githubusercontent.com/Light-City/cloudimg/master/deque_iterator.png" alt="deque_iterator.png"></p><p>首先来看一下比较重要的成员：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">typedef</span> _Tp                <span class="token operator">*</span><span class="token operator">*</span>_Map_pointer<span class="token punctuation">;</span>_Tp        <span class="token operator">*</span>_M_cur<span class="token punctuation">;</span>_Tp        <span class="token operator">*</span>_M_first<span class="token punctuation">;</span>_Tp        <span class="token operator">*</span>_M_last<span class="token punctuation">;</span>_Map_pointer    _M_node<span class="token punctuation">;</span></code></pre><p>这几个究竟是什么呢，根据名字，很容易知道啥意思，对于deque来说，是分段连续空间，迭代器执行操作，上述的<code>_M_cur</code>指向具体的元素，<code>_M_first</code>指向这段buffer中的第一个元素,<code>_M_last</code>指向最后一个元素(不是有效的元素)，而<code>_M_node</code>则是指向中控器。所以它是一个指针的指针。</p><p>例如现在迭代器执行++操作，当前buffer不够用了，那么此时需要一个指针能够回到中控器，取下一段buffer，重置<code>_M_first</code>与<code>_M_last</code>的指针位置，<code>_M_cur</code>指向新段buffer中的指定位置。</p><p>我们现在回到一开始的图：</p><p><img src="https://raw.githubusercontent.com/Light-City/cloudimg/master/deque_r.png" alt="deque_r.png"></p><p>最上面的的iterator就是上面几个指针的区块配图。</p><p>那buffer计算是什么实现的呢?</p><p>在源码中计算是根据传递进来的类型，如果传递的类型小于512字节，那么buffersize就是512/sizeof(_Tp)，超过512，就是1。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">static</span> size_t <span class="token function">_S_buffer_size</span><span class="token punctuation">(</span><span class="token punctuation">)</span>_GLIBCXX_NOEXCEPT<span class="token punctuation">{</span>    <span class="token keyword">return</span><span class="token punctuation">(</span><span class="token function">__deque_buf_size</span><span class="token punctuation">(</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>_Tp<span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><code>__deque_buf_size</code>实现</p><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">ifndef</span> _GLIBCXX_DEQUE_BUF_SIZE</span><span class="token macro property">#<span class="token directive keyword">define</span> _GLIBCXX_DEQUE_BUF_SIZE 512</span><span class="token macro property">#<span class="token directive keyword">endif</span></span><span class="token keyword">inline</span> size_t<span class="token function">__deque_buf_size</span><span class="token punctuation">(</span> size_t            __size <span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span><span class="token punctuation">(</span>__size <span class="token operator">&lt;</span> _GLIBCXX_DEQUE_BUF_SIZE            <span class="token operator">?</span> <span class="token function">size_t</span><span class="token punctuation">(</span> _GLIBCXX_DEQUE_BUF_SIZE <span class="token operator">/</span> __size <span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">size_t</span><span class="token punctuation">(</span> <span class="token number">1</span> <span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>前面几节源码中提到了萃取机技术，针对每个迭代器都需要嵌入下面五种typedef：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">typedef</span> std<span class="token operator">::</span>random_access_iterator_tag iterator_category<span class="token punctuation">;</span><span class="token keyword">typedef</span> _Tp                value_type<span class="token punctuation">;</span><span class="token keyword">typedef</span> _Ptr                pointer<span class="token punctuation">;</span><span class="token keyword">typedef</span> _Ref                reference<span class="token punctuation">;</span><span class="token keyword">typedef</span> ptrdiff_t            difference_type<span class="token punctuation">;</span></code></pre><p>据此，也可以知道deque迭代器的使用的是随机访问迭代器：<code>random_access_iterator_tag</code>。</p><p>而vector使用的迭代器也是这个，根据侯捷老师所讲，连续的buffer是vector，这与迭代器的tag类型不谋而合。</p><p>下面来看一下这个强大的迭代器的一些操作符重载：</p><p>具体的讲解在代码里面说。</p><blockquote><p>取值操作符</p></blockquote><pre class=" language-cpp"><code class="language-cpp">reference<span class="token keyword">operator</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>_GLIBCXX_NOEXCEPT<span class="token punctuation">{</span>    <span class="token keyword">return</span><span class="token punctuation">(</span><span class="token operator">*</span>_M_cur<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>pointer<span class="token keyword">operator</span><span class="token operator">-</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>_GLIBCXX_NOEXCEPT<span class="token punctuation">{</span>    <span class="token keyword">return</span><span class="token punctuation">(</span>_M_cur<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>当然上述的<code>-&gt;</code>也可以直接调用<code>*</code>操作符来实现，例如：</p><pre class=" language-cpp"><code class="language-cpp">pointer<span class="token keyword">operator</span><span class="token operator">-</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>_GLIBCXX_NOEXCEPT<span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token keyword">operator</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><blockquote><p>++与–操作符</p></blockquote><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 前置++操作符</span>_Self <span class="token operator">&amp;</span><span class="token keyword">operator</span><span class="token operator">++</span><span class="token punctuation">(</span><span class="token punctuation">)</span>_GLIBCXX_NOEXCEPT<span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 先++，判断是否到了buffer的末尾，如果到了末尾，就要跳到下一个buffer。</span>    <span class="token operator">++</span>_M_cur<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span> _M_cur <span class="token operator">==</span> _M_last <span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// _M_last指向的不是有效元素，保留节点  </span>    <span class="token punctuation">{</span>        <span class="token function">_M_set_node</span><span class="token punctuation">(</span> _M_node <span class="token operator">+</span> <span class="token number">1</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>        _M_cur <span class="token operator">=</span> _M_first<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 后置++操作符</span>_Self<span class="token keyword">operator</span><span class="token operator">++</span><span class="token punctuation">(</span> <span class="token keyword">int</span> <span class="token punctuation">)</span>_GLIBCXX_NOEXCEPT<span class="token punctuation">{</span>    _Self __tmp <span class="token operator">=</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>    <span class="token operator">++</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>    <span class="token keyword">return</span><span class="token punctuation">(</span>__tmp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 前置--操作符</span>_Self <span class="token operator">&amp;</span><span class="token keyword">operator</span><span class="token operator">--</span><span class="token punctuation">(</span><span class="token punctuation">)</span>_GLIBCXX_NOEXCEPT<span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 先判断是否到了起始位置，如果到了，由于需要进行--操作，那么就应该进入前一个buffer</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span> _M_cur <span class="token operator">==</span> _M_first <span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">_M_set_node</span><span class="token punctuation">(</span> _M_node <span class="token operator">-</span> <span class="token number">1</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>        _M_cur <span class="token operator">=</span> _M_last<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token operator">--</span>_M_cur<span class="token punctuation">;</span>    <span class="token keyword">return</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">//先在容器头部插入与第一个元素相同的元素</span><span class="token comment" spellcheck="true">// 后置--操作符</span>_Self<span class="token keyword">operator</span><span class="token operator">--</span><span class="token punctuation">(</span> <span class="token keyword">int</span> <span class="token punctuation">)</span>_GLIBCXX_NOEXCEPT<span class="token punctuation">{</span>    _Self __tmp <span class="token operator">=</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 定义一个副本 */</span>    <span class="token operator">--</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">/* 迭代器自减操作 */</span>    <span class="token keyword">return</span><span class="token punctuation">(</span>__tmp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><blockquote><p>跳跃n个距离操作符</p></blockquote><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">/** 实现随机取,迭代器可以直接跳跃n个距离* 将迭代器前移n个距离,当n负值时就为下面的operator-=操作*/</span>_Self <span class="token operator">&amp;</span><span class="token keyword">operator</span><span class="token operator">+</span><span class="token operator">=</span><span class="token punctuation">(</span> difference_type __n <span class="token punctuation">)</span>_GLIBCXX_NOEXCEPT<span class="token punctuation">{</span>    <span class="token keyword">const</span> difference_type __offset <span class="token operator">=</span> __n <span class="token operator">+</span> <span class="token punctuation">(</span>_M_cur <span class="token operator">-</span> _M_first<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/*        * 若前移n个距离后，目标依然在同一个缓冲区        * 则直接前移n个距离        */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span> __offset <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> __offset <span class="token operator">&lt;</span> <span class="token function">difference_type</span><span class="token punctuation">(</span> <span class="token function">_S_buffer_size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token punctuation">)</span>        _M_cur <span class="token operator">+</span><span class="token operator">=</span> __n<span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/*            * 若前移n个距离后,目标超出了缓冲区范围            * __offset>0   __offset / difference_type(_S_buffer_size())计算向后移动多少个缓冲区            * __offset&lt;=0  -difference_type((-__offset - 1) / _S_buffer_size()) - 1计算向前移动多少个缓冲区            */</span>        <span class="token keyword">const</span> difference_type __node_offset <span class="token operator">=</span>            __offset <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">?</span> __offset <span class="token operator">/</span> <span class="token function">difference_type</span><span class="token punctuation">(</span> <span class="token function">_S_buffer_size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span>            <span class="token operator">:</span> <span class="token operator">-</span><span class="token function">difference_type</span><span class="token punctuation">(</span> <span class="token punctuation">(</span><span class="token operator">-</span>__offset <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>                        <span class="token operator">/</span> <span class="token function">_S_buffer_size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/* 调整到正确的缓冲区,此时_M_first已经修改了 */</span>        <span class="token function">_M_set_node</span><span class="token punctuation">(</span> _M_node <span class="token operator">+</span> __node_offset <span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/* 修改为正确的指针位置 */</span>        _M_cur <span class="token operator">=</span> _M_first <span class="token operator">+</span> <span class="token punctuation">(</span>__offset <span class="token operator">-</span> __node_offset                        <span class="token operator">*</span> <span class="token function">difference_type</span><span class="token punctuation">(</span> <span class="token function">_S_buffer_size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>下面这几个操作符都是调用上面的<code>+=</code>操作符实现：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">/*    * 操作符+重载    * 返回操作之后的副本    */</span>_Self<span class="token keyword">operator</span><span class="token operator">+</span><span class="token punctuation">(</span> difference_type __n <span class="token punctuation">)</span> <span class="token keyword">const</span>_GLIBCXX_NOEXCEPT<span class="token punctuation">{</span>    _Self __tmp <span class="token operator">=</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 调用operator+=操作 */</span>    <span class="token keyword">return</span><span class="token punctuation">(</span>__tmp <span class="token operator">+</span><span class="token operator">=</span> __n<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/* 利用operator+=操作实现 */</span>_Self <span class="token operator">&amp;</span><span class="token keyword">operator</span><span class="token operator">-</span><span class="token operator">=</span><span class="token punctuation">(</span> difference_type __n <span class="token punctuation">)</span>_GLIBCXX_NOEXCEPT<span class="token punctuation">{</span>    <span class="token keyword">return</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token keyword">this</span> <span class="token operator">+</span><span class="token operator">=</span> <span class="token operator">-</span>__n<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/*    * 操作符-重载    * 返回操作之后的副本    */</span>_Self<span class="token keyword">operator</span><span class="token operator">-</span><span class="token punctuation">(</span> difference_type __n <span class="token punctuation">)</span> <span class="token keyword">const</span>_GLIBCXX_NOEXCEPT<span class="token punctuation">{</span>    _Self __tmp <span class="token operator">=</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/*  保存副本 */</span>    <span class="token keyword">return</span><span class="token punctuation">(</span>__tmp <span class="token operator">-</span><span class="token operator">=</span> __n<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">/* 调用operator-=操作符 */</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/* 返回指定位置的元素，即实现随机存取 */</span>reference<span class="token keyword">operator</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span> difference_type __n <span class="token punctuation">)</span> <span class="token keyword">const</span>_GLIBCXX_NOEXCEPT<span class="token punctuation">{</span>    <span class="token keyword">return</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token keyword">this</span> <span class="token operator">+</span> __n<span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 该函数调用operator+,operator* */</span><span class="token punctuation">}</span></code></pre><blockquote><p>buffer跳跃</p></blockquote><p>前面的++与–等操作符，会调用到<code>_M_set_node</code>函数，该函数的作用是能够进行buffer之间的跳跃，修改<code>_M_node</code>、<code>_M_first</code>、<code>_M_last</code>的指向。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">/**    *  Prepares to traverse new_node.  Sets everything except    *  _M_cur, which should therefore be set by the caller    *  immediately afterwards, based on _M_first and _M_last.    */</span><span class="token keyword">void</span><span class="token function">_M_set_node</span><span class="token punctuation">(</span> _Map_pointer __new_node <span class="token punctuation">)</span>_GLIBCXX_NOEXCEPT<span class="token punctuation">{</span>    _M_node        <span class="token operator">=</span> __new_node<span class="token punctuation">;</span>                                           <span class="token comment" spellcheck="true">/* 指向新的节点 */</span>    _M_first    <span class="token operator">=</span> <span class="token operator">*</span>__new_node<span class="token punctuation">;</span>                                          <span class="token comment" spellcheck="true">/* 指向新节点的头部 */</span>    _M_last        <span class="token operator">=</span> _M_first <span class="token operator">+</span> <span class="token function">difference_type</span><span class="token punctuation">(</span> <span class="token function">_S_buffer_size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">/* 指向新节点的尾部 */</span><span class="token punctuation">}</span></code></pre><p>据此，我们就把deque的迭代器实现细节讲解完毕了。</p><h2 id="3-deque"><a href="#3-deque" class="headerlink" title="3.deque"></a>3.deque</h2><blockquote><p>begin()函数</p></blockquote><p>返回<code>_M_start</code>。</p><pre class=" language-cpp"><code class="language-cpp">iterator<span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span>_GLIBCXX_NOEXCEPT<span class="token punctuation">{</span>    <span class="token keyword">return</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_start<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><blockquote><p>end()函数</p></blockquote><p>返回<code>_M_finish</code>。</p><pre class=" language-cpp"><code class="language-cpp">iterator<span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span>_GLIBCXX_NOEXCEPT<span class="token punctuation">{</span>    <span class="token keyword">return</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_finish<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><blockquote><p>size()函数</p></blockquote><pre class=" language-cpp"><code class="language-cpp">size_type<span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>_GLIBCXX_NOEXCEPT<span class="token punctuation">{</span>    <span class="token keyword">return</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_finish <span class="token operator">-</span> <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_start<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><blockquote><p>resize()函数</p></blockquote><p>根据传递进来的大小，如果超过了总size，就重新分配扩充<code>__new_size-size()</code>空间，否则删除从<code>size()-__new_size</code>数据，例如现在有20个空间，resize(12)，就会把后面8个空间数据删除及空间释放。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">void</span><span class="token function">resize</span><span class="token punctuation">(</span> size_type __new_size <span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">const</span> size_type __len <span class="token operator">=</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span> __new_size <span class="token operator">></span> __len <span class="token punctuation">)</span>        <span class="token function">_M_default_append</span><span class="token punctuation">(</span> __new_size <span class="token operator">-</span> __len <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span> __new_size <span class="token operator">&lt;</span> __len <span class="token punctuation">)</span>        <span class="token function">_M_erase_at_end</span><span class="token punctuation">(</span> <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_start                    <span class="token operator">+</span> <span class="token function">difference_type</span><span class="token punctuation">(</span> __new_size <span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><blockquote><p>empty()函数</p></blockquote><p>判断两个指针位置即可。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">bool</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>_GLIBCXX_NOEXCEPT<span class="token punctuation">{</span>    <span class="token keyword">return</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_finish <span class="token operator">==</span> <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_start<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><blockquote><p>back函数</p></blockquote><pre class=" language-cpp"><code class="language-cpp">reference<span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span>_GLIBCXX_NOEXCEPT       <span class="token comment" spellcheck="true">// 指向finish的前一个位置</span><span class="token punctuation">{</span>    iterator __tmp <span class="token operator">=</span> <span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">--</span>__tmp<span class="token punctuation">;</span>    <span class="token keyword">return</span><span class="token punctuation">(</span><span class="token operator">*</span>__tmp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><blockquote><p>push_front函数</p></blockquote><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">void</span><span class="token function">push_front</span><span class="token punctuation">(</span> <span class="token keyword">const</span> value_type <span class="token operator">&amp;</span>__x <span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//若当前缓冲区存在可用空间</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_start<span class="token punctuation">.</span>_M_cur <span class="token operator">!=</span> <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_start<span class="token punctuation">.</span>_M_first <span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span><span class="token function">construct</span><span class="token punctuation">(</span> <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_start<span class="token punctuation">.</span>_M_cur <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> __x <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 直接构造对象</span>        <span class="token operator">--</span><span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_start<span class="token punctuation">.</span>_M_cur<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 调整指针所指位置</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span>        <span class="token function">_M_push_front_aux</span><span class="token punctuation">(</span> __x <span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 需分配一段新的连续空间</span><span class="token punctuation">}</span></code></pre><blockquote><p>push_back函数</p></blockquote><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">void</span><span class="token function">push_back</span><span class="token punctuation">(</span> <span class="token keyword">const</span> value_type <span class="token operator">&amp;</span>__x <span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//若当前缓冲区存在可用空间</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_finish<span class="token punctuation">.</span>_M_cur            <span class="token operator">!=</span> <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_finish<span class="token punctuation">.</span>_M_last <span class="token operator">-</span> <span class="token number">1</span> <span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span><span class="token function">construct</span><span class="token punctuation">(</span> <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_finish<span class="token punctuation">.</span>_M_cur<span class="token punctuation">,</span> __x <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 直接构造对象</span>        <span class="token operator">++</span><span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_finish<span class="token punctuation">.</span>_M_cur<span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">//调整指针所指位置</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span>     <span class="token comment" spellcheck="true">// 若当前缓冲区不存在可用空间</span>    <span class="token comment" spellcheck="true">// 需分配一段新的连续空间</span>        <span class="token function">_M_push_back_aux</span><span class="token punctuation">(</span> __x <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>上述对应的pop动作与之相反。</p><blockquote><p>insert()函数</p></blockquote><p>insert函数比较有意思，根据传递进来的迭代器位置，看是不在开头与结尾，如果是在开头直接调用<code>push_front</code>函数，结尾直接调<code>push_back</code>函数，否则在容器中直接插入元素。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> _Tp<span class="token punctuation">,</span> <span class="token keyword">typename</span> _Alloc<span class="token operator">></span><span class="token keyword">typename</span> deque<span class="token operator">&lt;</span>_Tp<span class="token punctuation">,</span> _Alloc<span class="token operator">></span><span class="token operator">::</span>iteratordeque<span class="token operator">&lt;</span>_Tp<span class="token punctuation">,</span> _Alloc<span class="token operator">></span><span class="token operator">::</span><span class="token function">insert</span><span class="token punctuation">(</span>iterator __position<span class="token punctuation">,</span> <span class="token keyword">const</span> value_type<span class="token operator">&amp;</span> __x<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>__position<span class="token punctuation">.</span>_M_cur <span class="token operator">==</span> <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_start<span class="token punctuation">.</span>_M_cur<span class="token punctuation">)</span>       <span class="token punctuation">{</span>        <span class="token function">push_front</span><span class="token punctuation">(</span>__x<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_start<span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>__position<span class="token punctuation">.</span>_M_cur <span class="token operator">==</span> <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_finish<span class="token punctuation">.</span>_M_cur<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">push_back</span><span class="token punctuation">(</span>__x<span class="token punctuation">)</span><span class="token punctuation">;</span>        iterator __tmp <span class="token operator">=</span> <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_finish<span class="token punctuation">;</span>        <span class="token operator">--</span>__tmp<span class="token punctuation">;</span>        <span class="token keyword">return</span> __tmp<span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token keyword">else</span>  <span class="token comment" spellcheck="true">//否则在容器直接插入数据</span>        <span class="token keyword">return</span> <span class="token function">_M_insert_aux</span><span class="token punctuation">(</span>__position<span class="token punctuation">.</span><span class="token function">_M_const_cast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> __x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>而上述在容器中直接插入元素函数，会计算插入点，如果比较靠前面，就在前面插入，靠近后面就在后面插入：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _Tp<span class="token punctuation">,</span> <span class="token keyword">typename</span> _Alloc<span class="token operator">></span><span class="token keyword">typename</span> deque<span class="token operator">&lt;</span>_Tp<span class="token punctuation">,</span> _Alloc<span class="token operator">></span><span class="token operator">::</span>iteratordeque<span class="token operator">&lt;</span>_Tp<span class="token punctuation">,</span> _Alloc<span class="token operator">></span><span class="token operator">::</span><span class="token function">_M_insert_aux</span><span class="token punctuation">(</span>iterator __pos<span class="token punctuation">,</span> <span class="token keyword">const</span> value_type<span class="token operator">&amp;</span> __x<span class="token punctuation">)</span><span class="token punctuation">{</span>    value_type __x_copy <span class="token operator">=</span> __x<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// XXX copy</span>    difference_type __index <span class="token operator">=</span> __pos <span class="token operator">-</span> <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_start<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//计算插入点之前元素个数</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">static_cast</span><span class="token operator">&lt;</span>size_type<span class="token operator">></span><span class="token punctuation">(</span>__index<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">//若插入点之前的元素较少</span>        <span class="token punctuation">{</span>        <span class="token function">push_front</span><span class="token punctuation">(</span><span class="token function">_GLIBCXX_MOVE</span><span class="token punctuation">(</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//先在容器头部插入与第一个元素相同的元素</span>        iterator __front1 <span class="token operator">=</span> <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_start<span class="token punctuation">;</span>        <span class="token operator">++</span>__front1<span class="token punctuation">;</span>        iterator __front2 <span class="token operator">=</span> __front1<span class="token punctuation">;</span>        <span class="token operator">++</span>__front2<span class="token punctuation">;</span>        __pos <span class="token operator">=</span> <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_start <span class="token operator">+</span> __index<span class="token punctuation">;</span>        iterator __pos1 <span class="token operator">=</span> __pos<span class="token punctuation">;</span>        <span class="token operator">++</span>__pos1<span class="token punctuation">;</span>        <span class="token function">_GLIBCXX_MOVE3</span><span class="token punctuation">(</span>__front2<span class="token punctuation">,</span> __pos1<span class="token punctuation">,</span> __front1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 元素搬移</span>        <span class="token punctuation">}</span>    <span class="token keyword">else</span>    <span class="token punctuation">{</span>        <span class="token function">push_back</span><span class="token punctuation">(</span><span class="token function">_GLIBCXX_MOVE</span><span class="token punctuation">(</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        iterator __back1 <span class="token operator">=</span> <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_finish<span class="token punctuation">;</span>        <span class="token operator">--</span>__back1<span class="token punctuation">;</span>        iterator __back2 <span class="token operator">=</span> __back1<span class="token punctuation">;</span>        <span class="token operator">--</span>__back2<span class="token punctuation">;</span>        __pos <span class="token operator">=</span> <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_start <span class="token operator">+</span> __index<span class="token punctuation">;</span>        <span class="token function">_GLIBCXX_MOVE_BACKWARD3</span><span class="token punctuation">(</span>__pos<span class="token punctuation">,</span> __back2<span class="token punctuation">,</span> __back1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token operator">*</span>__pos <span class="token operator">=</span> <span class="token function">_GLIBCXX_MOVE</span><span class="token punctuation">(</span>__x_copy<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// 在安插点上设定新值</span>    <span class="token keyword">return</span> __pos<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> STL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ STL源码剖析之容器配接器stack与queue、priority_queue</title>
      <link href="/2019/10/16/queue-stack/"/>
      <url>/2019/10/16/queue-stack/</url>
      
        <content type="html"><![CDATA[<h1 id="C-STL源码剖析之容器配接器stack与queue、priority-queue"><a href="#C-STL源码剖析之容器配接器stack与queue、priority-queue" class="headerlink" title="C++ STL源码剖析之容器配接器stack与queue、priority_queue"></a>C++ STL源码剖析之容器配接器stack与queue、priority_queue</h1><h2 id="0-导语"><a href="#0-导语" class="headerlink" title="0.导语"></a>0.导语</h2><p>为何stack与queue不被称为容器呢？</p><p>下面本节带着这个问题来深入源码分析。</p><h2 id="1-stack"><a href="#1-stack" class="headerlink" title="1.stack"></a>1.stack</h2><p>在stack的源码中我们关注两点：</p><ul><li>默认<code>_Sequence</code>为<code>deque</code></li><li>内部函数实现是调用<code>_Sequence</code>对应容器的函数。</li></ul><p><img src="https://raw.githubusercontent.com/Light-City/cloudimg/master/stack.png" alt="stack.png"></p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _Tp<span class="token punctuation">,</span> <span class="token keyword">typename</span> _Sequence <span class="token operator">=</span> deque<span class="token operator">&lt;</span>_Tp<span class="token operator">></span> <span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">stack</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">typedef</span> <span class="token keyword">typename</span> _Sequence<span class="token operator">::</span>value_type                value_type<span class="token punctuation">;</span>    <span class="token keyword">typedef</span> <span class="token keyword">typename</span> _Sequence<span class="token operator">::</span>reference                 reference<span class="token punctuation">;</span>    <span class="token keyword">typedef</span> <span class="token keyword">typename</span> _Sequence<span class="token operator">::</span>const_reference           const_reference<span class="token punctuation">;</span>    <span class="token keyword">typedef</span> <span class="token keyword">typename</span> _Sequence<span class="token operator">::</span>size_type                 size_type<span class="token punctuation">;</span>    <span class="token keyword">typedef</span>          _Sequence                            container_type<span class="token punctuation">;</span><span class="token keyword">protected</span><span class="token operator">:</span>    <span class="token comment" spellcheck="true">//  See queue::c for notes on this name.</span>    _Sequence c<span class="token punctuation">;</span><span class="token keyword">public</span><span class="token operator">:</span>     reference      <span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token punctuation">{</span>        <span class="token function">__glibcxx_requires_nonempty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> c<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token keyword">void</span>      <span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">const</span> value_type<span class="token operator">&amp;</span> __x<span class="token punctuation">)</span>      <span class="token punctuation">{</span> c<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>__x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p>测试stack底层容器</p></blockquote><p>对于stack来说，底层容器可以是<code>vector</code>、<code>deque</code>、<code>list</code>，但不可以是<code>map</code>、<code>set</code>。<br>由于编译器不会做全面性检查，当调用函数不存在的时候，就编译不通过，所以对于像set虽然不能作为底层容器，但如果具有某些函数，调用仍然是成功的，直到调用的函数不存在。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">test_stack</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    cout<span class="token operator">&lt;&lt;</span><span class="token string">"============test_stack============="</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    clock_t timeStart <span class="token operator">=</span> <span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    stack<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> c<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">long</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        c<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"stack.size()= "</span> <span class="token operator">&lt;&lt;</span> c<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"stack.top()= "</span> <span class="token operator">&lt;&lt;</span> c<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    c<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"stack.size()= "</span> <span class="token operator">&lt;&lt;</span> c<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"stack.top()= "</span> <span class="token operator">&lt;&lt;</span> c<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"use stack milli-seconds : "</span> <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span><span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> timeStart<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    timeStart<span class="token operator">=</span><span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    stack<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> deque<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> c1<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">long</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        c1<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"stack.size()= "</span> <span class="token operator">&lt;&lt;</span> c1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"stack.top()= "</span> <span class="token operator">&lt;&lt;</span> c1<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    c1<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"stack.size()= "</span> <span class="token operator">&lt;&lt;</span> c1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"stack.top()= "</span> <span class="token operator">&lt;&lt;</span> c1<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"use stack milli-seconds : "</span> <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span><span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> timeStart<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// vector可以作为stack的底层容器</span>    stack<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> c2<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">long</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        c2<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"stack.size()= "</span> <span class="token operator">&lt;&lt;</span> c2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"stack.top()= "</span> <span class="token operator">&lt;&lt;</span> c2<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    c2<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"stack.size()= "</span> <span class="token operator">&lt;&lt;</span> c2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"stack.top()= "</span> <span class="token operator">&lt;&lt;</span> c2<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"use stack milli-seconds : "</span> <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span><span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> timeStart<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="2-queue"><a href="#2-queue" class="headerlink" title="2.queue"></a>2.queue</h2><p>在queue的源码中我们关注两点：</p><ul><li>默认<code>_Sequence</code>为<code>deque</code></li><li>内部函数实现是调用<code>_Sequence</code>对应容器的函数。</li></ul><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _Tp<span class="token punctuation">,</span> <span class="token keyword">typename</span> _Sequence <span class="token operator">=</span> deque<span class="token operator">&lt;</span>_Tp<span class="token operator">></span> <span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">queue</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">typedef</span> <span class="token keyword">typename</span> _Sequence<span class="token operator">::</span>value_type                value_type<span class="token punctuation">;</span>    <span class="token keyword">typedef</span> <span class="token keyword">typename</span> _Sequence<span class="token operator">::</span>reference                 reference<span class="token punctuation">;</span>    <span class="token keyword">typedef</span> <span class="token keyword">typename</span> _Sequence<span class="token operator">::</span>const_reference           const_reference<span class="token punctuation">;</span>    <span class="token keyword">typedef</span> <span class="token keyword">typename</span> _Sequence<span class="token operator">::</span>size_type                 size_type<span class="token punctuation">;</span>    <span class="token keyword">typedef</span>          _Sequence                            container_type<span class="token punctuation">;</span><span class="token keyword">protected</span><span class="token operator">:</span>    _Sequence c<span class="token punctuation">;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">const</span> value_type<span class="token operator">&amp;</span> __x<span class="token punctuation">)</span>    <span class="token punctuation">{</span> c<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>__x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>         <span class="token function">__glibcxx_requires_nonempty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      c<span class="token punctuation">.</span><span class="token function">pop_front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>其对应的UML类图如下：</p><p><img src="https://raw.githubusercontent.com/Light-City/cloudimg/master/queue_.png" alt="queue_.png"></p><p>同理，优先队列则是使用<code>vector</code>作为默认容器。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _Tp<span class="token punctuation">,</span> <span class="token keyword">typename</span> _Sequence <span class="token operator">=</span> vector<span class="token operator">&lt;</span>_Tp<span class="token operator">></span><span class="token punctuation">,</span><span class="token keyword">typename</span> _Compare  <span class="token operator">=</span> less<span class="token operator">&lt;</span><span class="token keyword">typename</span> _Sequence<span class="token operator">::</span>value_type<span class="token operator">></span> <span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">priority_queue</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">typedef</span> <span class="token keyword">typename</span> _Sequence<span class="token operator">::</span>value_type                value_type<span class="token punctuation">;</span>    <span class="token keyword">typedef</span> <span class="token keyword">typename</span> _Sequence<span class="token operator">::</span>reference                 reference<span class="token punctuation">;</span>    <span class="token keyword">typedef</span> <span class="token keyword">typename</span> _Sequence<span class="token operator">::</span>const_reference           const_reference<span class="token punctuation">;</span>    <span class="token keyword">typedef</span> <span class="token keyword">typename</span> _Sequence<span class="token operator">::</span>size_type                 size_type<span class="token punctuation">;</span>    <span class="token keyword">typedef</span>          _Sequence                            container_type<span class="token punctuation">;</span><span class="token keyword">protected</span><span class="token operator">:</span>    <span class="token comment" spellcheck="true">//  See queue::c for notes on these names.</span>    _Sequence  c<span class="token punctuation">;</span>    _Compare   comp<span class="token punctuation">;</span><span class="token keyword">public</span><span class="token operator">:</span>    reference    <span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span>     <span class="token punctuation">{</span>        <span class="token function">__glibcxx_requires_nonempty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> c<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span>    <span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">const</span> value_type<span class="token operator">&amp;</span> __x<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        c<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>__x<span class="token punctuation">)</span><span class="token punctuation">;</span>        std<span class="token operator">::</span><span class="token function">push_heap</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> c<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> comp<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><img src="https://raw.githubusercontent.com/Light-City/cloudimg/master/priority_queue.png" alt="priority_queue.png"></p><p>测试这两个容器配接器支持的底层容器：</p><blockquote><p>queue</p></blockquote><p>对于queue底层容器可以是<code>deque</code>，也可以是<code>list</code>，但不能是<code>vector</code>,<code>map</code>,<code>set</code>，使用默认的deque效率在插入方面比其他容器作为底层要快！</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">test_queue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    cout<span class="token operator">&lt;&lt;</span><span class="token string">"============test_queue============="</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    clock_t timeStart <span class="token operator">=</span> <span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    queue<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> c<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">long</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        c<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"stack.size()= "</span> <span class="token operator">&lt;&lt;</span> c<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"stack.front()= "</span> <span class="token operator">&lt;&lt;</span> c<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    c<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"stack.size()= "</span> <span class="token operator">&lt;&lt;</span> c<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"stack.front()= "</span> <span class="token operator">&lt;&lt;</span> c<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"use list milli-seconds : "</span> <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span><span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> timeStart<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    timeStart<span class="token operator">=</span><span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    queue<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> deque<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> c1<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">long</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        c1<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"stack.size()= "</span> <span class="token operator">&lt;&lt;</span> c1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"stack.front()= "</span> <span class="token operator">&lt;&lt;</span> c1<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    c1<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"stack.size()= "</span> <span class="token operator">&lt;&lt;</span> c1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"stack.front()= "</span> <span class="token operator">&lt;&lt;</span> c1<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"use deque milli-seconds : "</span> <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span><span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> timeStart<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><blockquote><p>priority_queue</p></blockquote><p>对于优先队列来说，测试结果发现，采用<code>deque</code>要比默认的<code>vector</code>插入速度快！<br>底层支持vector、deque容器，但不支持list、map、set。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">test_priority_queue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    cout<span class="token operator">&lt;&lt;</span><span class="token string">"============test_priority_queue============="</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    clock_t timeStart <span class="token operator">=</span> <span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    priority_queue<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> deque<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> c1<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">long</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        c1<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"stack.size()= "</span> <span class="token operator">&lt;&lt;</span> c1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"stack.top()= "</span> <span class="token operator">&lt;&lt;</span> c1<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    c1<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"stack.size()= "</span> <span class="token operator">&lt;&lt;</span> c1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"stack.top()= "</span> <span class="token operator">&lt;&lt;</span> c1<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"use deque milli-seconds : "</span> <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span><span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> timeStart<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    priority_queue<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> c2<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">long</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        c2<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"stack.size()= "</span> <span class="token operator">&lt;&lt;</span> c2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"stack.top()= "</span> <span class="token operator">&lt;&lt;</span> c2<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    c2<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"stack.size()= "</span> <span class="token operator">&lt;&lt;</span> c2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"stack.top()= "</span> <span class="token operator">&lt;&lt;</span> c2<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"use stack milli-seconds : "</span> <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span><span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> timeStart<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><strong>因此，stack、queue、priority_queue不被称为容器， 把它称为容器配接器。</strong></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> STL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ STL源码剖析 tr1与std array</title>
      <link href="/2019/10/15/array/"/>
      <url>/2019/10/15/array/</url>
      
        <content type="html"><![CDATA[<h1 id="C-STL源码剖析-tr1与std-array"><a href="#C-STL源码剖析-tr1与std-array" class="headerlink" title="C++ STL源码剖析 tr1与std array"></a>C++ STL源码剖析 tr1与std array</h1><h2 id="0-导语"><a href="#0-导语" class="headerlink" title="0.导语"></a>0.导语</h2><p>源码剖析版本为gcc4.9.1。</p><p>C++ tr1全称Technical Report 1，是针对C++标准库的第一次扩展。即将到来的下一个版本的C++标准c++0x会包括它，以及一些语言本身的扩充。tr1包括大家期待已久的smart pointer，正则表达式以及其他一些支持范型编程的内容。草案阶段，新增的类和模板的名字空间是std::tr1。</p><h2 id="1-std-tr1-array"><a href="#1-std-tr1-array" class="headerlink" title="1.std::tr1::array"></a>1.std::tr1::array</h2><p>使用：</p><pre><code>#include &lt;tr1/array&gt;std::tr1::array&lt;int ,10&gt; a;</code></pre><p>tr1中的array比较简单，模拟语言本身的数组，并且让其支持迭代器操作，使其同其他容器一样，能够调用算法。对于tr1中array没有构造与析构。迭代器是直接使用传递进来的类型定义指针。</p><p>简单的看一下这个静态数组array源码：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _Tp<span class="token punctuation">,</span> std<span class="token operator">::</span>size_t _Nm<span class="token operator">></span><span class="token keyword">struct</span> array<span class="token punctuation">{</span>    <span class="token keyword">typedef</span> _Tp                           value_type<span class="token punctuation">;</span>    <span class="token keyword">typedef</span> value_type<span class="token operator">&amp;</span>                             reference<span class="token punctuation">;</span>    <span class="token keyword">typedef</span> <span class="token keyword">const</span> value_type<span class="token operator">&amp;</span>                       const_reference<span class="token punctuation">;</span>    <span class="token keyword">typedef</span> value_type<span class="token operator">*</span>                        iterator<span class="token punctuation">;</span>    <span class="token keyword">typedef</span> <span class="token keyword">const</span> value_type<span class="token operator">*</span>                  const_iterator<span class="token punctuation">;</span>    <span class="token keyword">typedef</span> std<span class="token operator">::</span>size_t                              size_type<span class="token punctuation">;</span>    <span class="token keyword">typedef</span> std<span class="token operator">::</span>ptrdiff_t                          difference_type<span class="token punctuation">;</span>    <span class="token keyword">typedef</span> std<span class="token operator">::</span>reverse_iterator<span class="token operator">&lt;</span>iterator<span class="token operator">></span>          reverse_iterator<span class="token punctuation">;</span>    <span class="token keyword">typedef</span> std<span class="token operator">::</span>reverse_iterator<span class="token operator">&lt;</span>const_iterator<span class="token operator">></span>   const_reverse_iterator<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>里面使用<code>reverse_iterator</code>作为rbegin与rend操作的迭代器。<br>看上去上面一个迭代器，实际上两个，还有一个iterator,这个直接使用传递进来的类型定义指针，作为迭代器。</p><p>可以将其对比为vector中的正向与反向迭代器。</p><p>值得注意的是，在tr1::array中，支持传递数组大小为0，例如我们使用如下：</p><pre><code>std::tr1::array&lt;int,0&gt; a;</code></pre><p>对于这样的写法，会对应到下面：</p><pre><code>// Support for zero-sized arrays mandatory.value_type _M_instance[_Nm ? _Nm : 1];</code></pre><p>根据传递进来的大小，如果不为0，就是传递进来的大小，否则为1。</p><h2 id="2-std-array"><a href="#2-std-array" class="headerlink" title="2.std::array"></a>2.std::array</h2><p>使用</p><pre><code>std::array&lt;int ,10&gt; a;</code></pre><p>std中的array包含了</p><p><img src="https://raw.githubusercontent.com/Light-City/cloudimg/master/std_array.png" alt="std_array.png"></p><p>对比tr1与std的array</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _Tp<span class="token punctuation">,</span> std<span class="token operator">::</span>size_t _Nm<span class="token operator">></span><span class="token keyword">struct</span> array<span class="token punctuation">{</span>    <span class="token keyword">typedef</span> _Tp                           value_type<span class="token punctuation">;</span>    <span class="token keyword">typedef</span> value_type<span class="token operator">*</span>                  pointer<span class="token punctuation">;</span>    <span class="token keyword">typedef</span> <span class="token keyword">const</span> value_type<span class="token operator">*</span>                       const_pointer<span class="token punctuation">;</span>    <span class="token keyword">typedef</span> value_type<span class="token operator">&amp;</span>                             reference<span class="token punctuation">;</span>    <span class="token keyword">typedef</span> <span class="token keyword">const</span> value_type<span class="token operator">&amp;</span>                       const_reference<span class="token punctuation">;</span>    <span class="token keyword">typedef</span> value_type<span class="token operator">*</span>                        iterator<span class="token punctuation">;</span>    <span class="token keyword">typedef</span> <span class="token keyword">const</span> value_type<span class="token operator">*</span>                  const_iterator<span class="token punctuation">;</span>    <span class="token keyword">typedef</span> std<span class="token operator">::</span>size_t                              size_type<span class="token punctuation">;</span>    <span class="token keyword">typedef</span> std<span class="token operator">::</span>ptrdiff_t                             difference_type<span class="token punctuation">;</span>    <span class="token keyword">typedef</span> std<span class="token operator">::</span>reverse_iterator<span class="token operator">&lt;</span>iterator<span class="token operator">></span>          reverse_iterator<span class="token punctuation">;</span>    <span class="token keyword">typedef</span> std<span class="token operator">::</span>reverse_iterator<span class="token operator">&lt;</span>const_iterator<span class="token operator">></span>   const_reverse_iterator<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// Support for zero-sized arrays mandatory.</span>    <span class="token keyword">typedef</span> _GLIBCXX_STD_C<span class="token operator">::</span>__array_traits<span class="token operator">&lt;</span>_Tp<span class="token punctuation">,</span> _Nm<span class="token operator">></span> _AT_Type<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// # define _GLIBCXX_STD_C std</span>    <span class="token keyword">typename</span> _AT_Type<span class="token operator">::</span>_Type                         _M_elems<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>发现array里面有两处值得注意的地方：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// Support for zero-sized arrays mandatory.</span><span class="token keyword">typedef</span> _GLIBCXX_STD_C<span class="token operator">::</span>__array_traits<span class="token operator">&lt;</span>_Tp<span class="token punctuation">,</span> _Nm<span class="token operator">></span> _AT_Type<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// # define _GLIBCXX_STD_C std</span><span class="token keyword">typename</span> _AT_Type<span class="token operator">::</span>_Type                         _M_elems<span class="token punctuation">;</span></code></pre><p>在源码中去找__array_traits，看到：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _Tp<span class="token punctuation">,</span> std<span class="token operator">::</span>size_t _Nm<span class="token operator">></span><span class="token keyword">struct</span> __array_traits<span class="token punctuation">{</span>    <span class="token keyword">typedef</span> _Tp _Type<span class="token punctuation">[</span>_Nm<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token keyword">constexpr</span> _Tp<span class="token operator">&amp;</span>    <span class="token function">_S_ref</span><span class="token punctuation">(</span><span class="token keyword">const</span> _Type<span class="token operator">&amp;</span> __t<span class="token punctuation">,</span> std<span class="token operator">::</span>size_t __n<span class="token punctuation">)</span> <span class="token keyword">noexcept</span>    <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token keyword">const_cast</span><span class="token operator">&lt;</span>_Tp<span class="token operator">&amp;</span><span class="token operator">></span><span class="token punctuation">(</span>__t<span class="token punctuation">[</span>__n<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>上面两行的代码可以理解为下面：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">typedef</span> _Tp _Type<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">typedef</span> _Type _M_elems<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 一个含有100个元素的数组。</span></code></pre><p>在实际写代码的时候，如果要定义一个数组，我们可以这样写：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//或者</span><span class="token keyword">typedef</span> <span class="token keyword">int</span> T<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">typedef</span> T a<span class="token punctuation">;</span></code></pre><p>针对传进来的size处理，相比于tr1，更加复杂，使用了模板偏特化来处理传递size为0情况。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _Tp<span class="token punctuation">,</span> std<span class="token operator">::</span>size_t _Nm<span class="token operator">></span><span class="token keyword">struct</span> __array_traits<span class="token punctuation">{</span>    <span class="token keyword">typedef</span> _Tp _Type<span class="token punctuation">[</span>_Nm<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token keyword">constexpr</span> _Tp<span class="token operator">&amp;</span>    <span class="token function">_S_ref</span><span class="token punctuation">(</span><span class="token keyword">const</span> _Type<span class="token operator">&amp;</span> __t<span class="token punctuation">,</span> std<span class="token operator">::</span>size_t __n<span class="token punctuation">)</span> <span class="token keyword">noexcept</span>    <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token keyword">const_cast</span><span class="token operator">&lt;</span>_Tp<span class="token operator">&amp;</span><span class="token operator">></span><span class="token punctuation">(</span>__t<span class="token punctuation">[</span>__n<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _Tp<span class="token operator">></span><span class="token keyword">struct</span> __array_traits<span class="token operator">&lt;</span>_Tp<span class="token punctuation">,</span> <span class="token number">0</span><span class="token operator">></span><span class="token punctuation">{</span>    <span class="token keyword">struct</span> _Type <span class="token punctuation">{</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token keyword">constexpr</span> _Tp<span class="token operator">&amp;</span>    <span class="token function">_S_ref</span><span class="token punctuation">(</span><span class="token keyword">const</span> _Type<span class="token operator">&amp;</span><span class="token punctuation">,</span> std<span class="token operator">::</span>size_t<span class="token punctuation">)</span> <span class="token keyword">noexcept</span>    <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">static_cast</span><span class="token operator">&lt;</span>_Tp<span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> STL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于二分搜索法的floor与ceil</title>
      <link href="/2019/10/13/er-fen-cha-zhao-fa/"/>
      <url>/2019/10/13/er-fen-cha-zhao-fa/</url>
      
        <content type="html"><![CDATA[<h1 id="基于二分搜索法的floor与ceil"><a href="#基于二分搜索法的floor与ceil" class="headerlink" title="基于二分搜索法的floor与ceil"></a>基于二分搜索法的floor与ceil</h1><h2 id="1-基本的二分搜索"><a href="#1-基本的二分搜索" class="headerlink" title="1.基本的二分搜索"></a>1.基本的二分搜索</h2><p>在闭区间[left,right]范围内查找target。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">search1</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> right <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// left与right均不会越界，可以取等</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;=</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> mid <span class="token operator">=</span>left<span class="token operator">+</span> <span class="token punctuation">(</span>right<span class="token operator">-</span>left<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> mid<span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    left <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// mid处理过了，需要mid+1</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">></span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>                right <span class="token operator">=</span> mid<span class="token number">-1</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// mid处理过了,需要mid-1</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>如果上述right改为nums.size()，判断与right均会发生变化：</p><p>此时处理的范围为[left,right)</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">search2</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> right <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// right会越界</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> mid <span class="token operator">=</span>left<span class="token operator">+</span> <span class="token punctuation">(</span>right<span class="token operator">-</span>left<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> mid<span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    left <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// mid处理过了，需要mid+1 left不会越界</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">></span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>                right <span class="token operator">=</span> mid<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 处理范围为[left,right)，right为开区间，不可取得right，一定要维护[left,right)这个条件不变</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>上述都比较简单，现在我们考虑有如下例子：</p><pre class=" language-cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> nums<span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> target<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span></code></pre><p>此时使用上述二分查找算法，搜索出来的index为3。那如果我想要获取最左侧等于target的index或最右侧等于target的index呢？此时上述算法失效！</p><h2 id="2-最左侧index"><a href="#2-最左侧index" class="headerlink" title="2.最左侧index"></a>2.最左侧index</h2><p>所谓最左侧index为第一个等于target对应的index</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">search3</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> right <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;=</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> mid <span class="token operator">=</span>left<span class="token operator">+</span> <span class="token punctuation">(</span>right<span class="token operator">-</span>left<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>                right<span class="token operator">=</span>mid<span class="token number">-1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>                left <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">></span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>                right <span class="token operator">=</span> mid<span class="token number">-1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>left<span class="token operator">==</span>nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 如果最后left==nums.size()，表示nums中的所有元素都小于target,查找失败！</span>        <span class="token keyword">return</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">==</span> target <span class="token operator">?</span> left <span class="token operator">:</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><h2 id="3-最右侧index"><a href="#3-最右侧index" class="headerlink" title="3.最右侧index"></a>3.最右侧index</h2><p>所谓最右侧index为最后一个等于target对应的index</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">search4</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> right <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;=</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> mid <span class="token operator">=</span>left<span class="token operator">+</span> <span class="token punctuation">(</span>right<span class="token operator">-</span>left<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>                left <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 注意</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>                left <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">></span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>                right <span class="token operator">=</span> mid<span class="token number">-1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>right<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 或者写if(left==0) return -1; 如果right&lt;0，那么此时nums中所有元素均大于target</span>        <span class="token keyword">return</span> nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">==</span> target <span class="token operator">?</span> right <span class="token operator">:</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>测试上述算法：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> nums<span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> target<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>    cout<span class="token operator">&lt;&lt;</span><span class="token function">Solution</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">search1</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span>target<span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// 3</span>    cout<span class="token operator">&lt;&lt;</span><span class="token function">Solution</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">search2</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span>target<span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// 3</span>    <span class="token comment" spellcheck="true">// 寻找第一个等于target的index,最左侧index</span>    cout<span class="token operator">&lt;&lt;</span><span class="token function">Solution</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">search3</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span>target<span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// 1</span>    cout<span class="token operator">&lt;&lt;</span><span class="token function">Solution</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">search4</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span>target<span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// 4</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>测试成功。</p><h2 id="4-floor"><a href="#4-floor" class="headerlink" title="4.floor"></a>4.floor</h2><p>对于上述最左侧index，我们可以将这个算法的返回值进行修改，这样就得到了我们想要的floor函数，floor函数定义是：<strong>当存在大量重复元素时，floor找的是第一个，当不存在指定的元素时，floor找的是比其小最大的一个。</strong></p><p>注意边界，当所有元素小于target时，返回的index为最后一个index，当所有元素大于target时，返回-1.</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">floor1</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> right <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;=</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> mid <span class="token operator">=</span>left<span class="token operator">+</span> <span class="token punctuation">(</span>right<span class="token operator">-</span>left<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>                right<span class="token operator">=</span>mid<span class="token number">-1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>                left <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">></span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>                right <span class="token operator">=</span> mid<span class="token number">-1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 所有元素均大于target</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>right <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 所有元素均小于target</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">==</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> left <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">==</span> target <span class="token operator">?</span> left <span class="token operator">:</span> left<span class="token number">-1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>将该算法使用另外一种写法：</p><p>使用(left,right]定义</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">floor2</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 寻找比target小的最大索引</span>    <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> right <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// (left,right]</span>    <span class="token keyword">while</span><span class="token punctuation">(</span> left <span class="token operator">&lt;</span> right <span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 使用向上取整避免死循环</span>        <span class="token keyword">int</span> mid <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token punctuation">(</span>right<span class="token operator">-</span>left<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span> nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">>=</span> target <span class="token punctuation">)</span>            right <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">else</span>            left <span class="token operator">=</span> mid<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 如果该索引+1就是target本身, 该索引+1即为返回值</span>    <span class="token keyword">if</span><span class="token punctuation">(</span> left <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>left<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> target <span class="token punctuation">)</span>        <span class="token keyword">return</span> left <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 否则, 该索引即为返回值</span>    <span class="token keyword">return</span> left<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="5-ceil"><a href="#5-ceil" class="headerlink" title="5.ceil"></a>5.ceil</h2><p>对于上述最右侧index，我们可以将这个算法的返回值进行修改，这样就得到了我们想要的ceil函数，ceil函数定义是：<strong>当存在大量重复的元素时，ceil找的是第一个。当不存在指定的元素时，ceil是比其大最小的一个。</strong></p><p>注意边界，当所有元素小于target时，返回的index为最后一个index，当所有元素大于target时，返回0.</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">ceil1</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> right <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;=</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> mid <span class="token operator">=</span>left<span class="token operator">+</span> <span class="token punctuation">(</span>right<span class="token operator">-</span>left<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>                left <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 注意</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>                left <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">></span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>                right <span class="token operator">=</span> mid<span class="token number">-1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 所有元素均大于target</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>right <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 所有元素均小于target</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">==</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> left <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">==</span> target <span class="token operator">?</span> right <span class="token operator">:</span> right<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>将该算法使用另外一种写法：</p><p>使用(left,right]定义</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">ceil2</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 寻找比target大的最小索引值</span>    <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> right <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span> left <span class="token operator">&lt;</span> right <span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 使用普通的向下取整即可避免死循环</span>        <span class="token keyword">int</span> mid <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token punctuation">(</span>right<span class="token operator">-</span>left<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span> nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> target <span class="token punctuation">)</span>            left <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token comment" spellcheck="true">// arr[mid] > target</span>            right <span class="token operator">=</span> mid<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 如果该索引-1就是target本身, 该索引+1即为返回值</span>    <span class="token keyword">if</span><span class="token punctuation">(</span> right <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>right<span class="token number">-1</span><span class="token punctuation">]</span> <span class="token operator">==</span> target <span class="token punctuation">)</span>        <span class="token keyword">return</span> right<span class="token number">-1</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 否则, 该索引即为返回值</span>    <span class="token keyword">return</span> right<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="6-全部算法测试"><a href="#6-全部算法测试" class="headerlink" title="6.全部算法测试"></a>6.全部算法测试</h2><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> nums <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> target <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token function">Solution</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">search1</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> target<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// 3</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token function">Solution</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">search2</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> target<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// 3</span>    <span class="token comment" spellcheck="true">// 寻找第一个等于target的index,最左侧index</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token function">Solution</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">search3</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> target<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// 1</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token function">Solution</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">search4</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> target<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// 4</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token function">Solution</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ceil1</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 0</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token function">Solution</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ceil2</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 0</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token function">Solution</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ceil1</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 5</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token function">Solution</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ceil2</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 5</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token function">Solution</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ceil1</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 6</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token function">Solution</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ceil2</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 6</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token function">Solution</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">floor1</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// -1</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token function">Solution</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">floor2</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// -1</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token function">Solution</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">floor1</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 5</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token function">Solution</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">floor2</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 5</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token function">Solution</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">floor1</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 6</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token function">Solution</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">floor2</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 6</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 二分搜索法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ STL源码剖析之动态数组vector</title>
      <link href="/2019/10/13/vector/"/>
      <url>/2019/10/13/vector/</url>
      
        <content type="html"><![CDATA[<h1 id="STL源码剖析之动态数组vector"><a href="#STL源码剖析之动态数组vector" class="headerlink" title="STL源码剖析之动态数组vector"></a>STL源码剖析之动态数组vector</h1><h2 id="0-导语"><a href="#0-导语" class="headerlink" title="0.导语"></a>0.导语</h2><p>vector的数据安排以及操作方式，与array非常相似。两者的唯一差别在于空间的运用的灵活性，array是静态的，一旦配置了就不能改变，而 vector是动态空间，随着元素的加入，它的内部机制会自行扩充空间以容纳新元素。下面一起来看一下vector的”内部机制”，怎么来实现空间配置策略的。</p><h2 id="1-vector"><a href="#1-vector" class="headerlink" title="1.vector"></a>1.vector</h2><p>在<code>_Vector_base</code>中开头有两行比较难理解，下面一个一个分析：</p><h3 id="1-1-Tp-alloc-type"><a href="#1-1-Tp-alloc-type" class="headerlink" title="1.1 _Tp_alloc_type"></a>1.1 _Tp_alloc_type</h3><p>开头处定义：</p><pre><code> typedef typename __gnu_cxx::__alloc_traits&lt;_Alloc&gt;::template rebind&lt;_Tp&gt;::other _Tp_alloc_type;</code></pre><p>在<code>__gnu_cxx::__alloc_traits</code>中：对应文件为：<code>ext/alloc_traits.h</code></p><pre class=" language-cpp"><code class="language-cpp"> <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _Tp<span class="token operator">></span>      <span class="token keyword">struct</span> rebind      <span class="token punctuation">{</span> <span class="token keyword">typedef</span> <span class="token keyword">typename</span> _Base_type<span class="token operator">::</span><span class="token keyword">template</span> rebind_alloc<span class="token operator">&lt;</span>_Tp<span class="token operator">></span> other<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>等价于</p><pre><code>typename __gnu_cxx::__alloc_traits&lt;_Alloc&gt;::template rebind&lt;_Tp&gt;::other </code></pre><p>等价于：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">typename</span> _Base_type<span class="token operator">::</span><span class="token keyword">template</span> rebind_alloc<span class="token operator">&lt;</span>_Tp<span class="token operator">></span></code></pre><p>而<code>_Base_type</code>是：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">typedef</span> std<span class="token operator">::</span>allocator_traits<span class="token operator">&lt;</span>_Alloc<span class="token operator">></span>           _Base_type<span class="token punctuation">;</span></code></pre><p>所以上述等价于：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">typename</span> std<span class="token operator">::</span>allocator_traits<span class="token operator">&lt;</span>_Alloc<span class="token operator">></span><span class="token operator">::</span><span class="token keyword">template</span> rebind_alloc<span class="token operator">&lt;</span>_Tp<span class="token operator">></span></code></pre><p>继续到<code>allocator_traits</code>中寻找</p><p>找到了：</p><pre class=" language-cpp"><code class="language-cpp">  <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _Up<span class="token operator">></span>    <span class="token keyword">using</span> rebind_alloc <span class="token operator">=</span> allocator<span class="token operator">&lt;</span>_Up<span class="token operator">></span><span class="token punctuation">;</span></code></pre><p>于是：</p><pre class=" language-cpp"><code class="language-cpp">std<span class="token operator">::</span>allocator_traits<span class="token operator">&lt;</span>_Alloc<span class="token operator">></span><span class="token operator">::</span><span class="token keyword">template</span> rebind_alloc<span class="token operator">&lt;</span>_Tp<span class="token operator">></span></code></pre><p>等价于：</p><pre class=" language-cpp"><code class="language-cpp">allocator<span class="token operator">&lt;</span>_Tp<span class="token operator">></span></code></pre><blockquote><p>小结</p></blockquote><pre class=" language-cpp"><code class="language-cpp"> <span class="token keyword">typedef</span> <span class="token keyword">typename</span> __gnu_cxx<span class="token operator">::</span>__alloc_traits<span class="token operator">&lt;</span>_Alloc<span class="token operator">></span><span class="token operator">::</span><span class="token keyword">template</span> rebind<span class="token operator">&lt;</span>_Tp<span class="token operator">></span><span class="token operator">::</span>other _Tp_alloc_type<span class="token punctuation">;</span></code></pre><p>等价于：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">typedef</span> allocator<span class="token operator">&lt;</span>_Tp<span class="token operator">></span> _Tp_alloc_type</code></pre><h3 id="1-2-pointer"><a href="#1-2-pointer" class="headerlink" title="1.2 pointer"></a>1.2 pointer</h3><p>而<code>pointer</code>：</p><pre class=" language-cpp"><code class="language-cpp"> <span class="token keyword">typedef</span> <span class="token keyword">typename</span> __gnu_cxx<span class="token operator">::</span>__alloc_traits<span class="token operator">&lt;</span>_Tp_alloc_type<span class="token operator">></span><span class="token operator">::</span>pointer           pointer<span class="token punctuation">;</span></code></pre><p>等价于：</p><pre class=" language-cpp"><code class="language-cpp"> <span class="token keyword">typedef</span> <span class="token keyword">typename</span> __gnu_cxx<span class="token operator">::</span>__alloc_traits<span class="token operator">&lt;</span>allocator<span class="token operator">&lt;</span>_Tp<span class="token operator">>></span><span class="token operator">::</span>pointer           pointer<span class="token punctuation">;</span></code></pre><p>根据下面两行：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">typedef</span> std<span class="token operator">::</span>allocator_traits<span class="token operator">&lt;</span>_Alloc<span class="token operator">></span>           _Base_type<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">typename</span> _Base_type<span class="token operator">::</span>pointer            pointer<span class="token punctuation">;</span></code></pre><p>又等价于：</p><pre><code> typedef std::allocator_traits&lt;_Alloc&gt;::pointer           pointer;</code></pre><p>在<code>allocator_traits</code>中找到下面：</p><pre class=" language-cpp"><code class="language-cpp">  <span class="token comment" spellcheck="true">/**   * @brief   The allocator's pointer type.   *   * @c Alloc::pointer if that type exists, otherwise @c value_type*  */</span>  <span class="token keyword">typedef</span> __pointer pointer<span class="token punctuation">;</span></code></pre><p>注释中说了如果存在就是<code>Alloc::pointer</code>，否则为<code>value_type *</code>。</p><blockquote><p>小结</p></blockquote><pre class=" language-cpp"><code class="language-cpp"> <span class="token keyword">typedef</span> <span class="token keyword">typename</span> __gnu_cxx<span class="token operator">::</span>__alloc_traits<span class="token operator">&lt;</span>_Tp_alloc_type<span class="token operator">></span><span class="token operator">::</span>pointer           pointer<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 或者</span> <span class="token keyword">typedef</span> <span class="token keyword">typename</span> __gnu_cxx<span class="token operator">::</span>__alloc_traits<span class="token operator">&lt;</span>allocator<span class="token operator">&lt;</span>_Tp<span class="token operator">>></span><span class="token operator">::</span>pointer           pointer<span class="token punctuation">;</span></code></pre><p>等价于</p><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">/*** @brief   The allocator's pointer type.** @c Alloc::pointer if that type exists, otherwise @c value_type**/</span><span class="token keyword">typedef</span> __pointer pointer<span class="token punctuation">;</span></code></pre><p>如果存在<code>_Tp_alloc_type::pointer</code>也就是<code>allocator&lt;_Tp&gt;</code>存在就是<code>allocator&lt;_Tp&gt;::pointer</code>，</p><p>这个看<code>allocator.h</code>源码：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">typedef</span> _Tp<span class="token operator">*</span>       pointer<span class="token punctuation">;</span></code></pre><p>否则为<code>value_type*</code>。而<code>value_type</code>为：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">typedef</span> <span class="token keyword">typename</span> _Alloc<span class="token operator">::</span>value_type value_type<span class="token punctuation">;</span></code></pre><p>所以<code>value_type*</code>推导出为：</p><pre class=" language-cpp"><code class="language-cpp">_Tp<span class="token operator">::</span>value_type<span class="token operator">*</span></code></pre><h3 id="1-3-vector的内存管理"><a href="#1-3-vector的内存管理" class="headerlink" title="1.3 vector的内存管理"></a>1.3 vector的内存管理</h3><p><code>_Vector_base</code>中有一个<strong>内存管理器</strong><code>_Vector_impl</code>类，该结构体继承<code>allocator</code>(根据上述1.1等价条件得出)。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _Tp<span class="token punctuation">,</span> <span class="token keyword">typename</span> _Alloc<span class="token operator">></span><span class="token keyword">struct</span> _Vector_base <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//__alloc_traits -> allocator_traits</span>    <span class="token comment" spellcheck="true">// typedef allocator&lt;_Tp> _Tp_alloc_type</span>    <span class="token keyword">typedef</span> <span class="token keyword">typename</span> __gnu_cxx<span class="token operator">::</span>__alloc_traits<span class="token operator">&lt;</span>_Alloc<span class="token operator">></span><span class="token operator">::</span><span class="token keyword">template</span>    rebind<span class="token operator">&lt;</span>_Tp<span class="token operator">></span><span class="token operator">::</span>other _Tp_alloc_type<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//  _Tp::value_type* or _Tp*</span>    <span class="token keyword">typedef</span> <span class="token keyword">typename</span> __gnu_cxx<span class="token operator">::</span>__alloc_traits<span class="token operator">&lt;</span>_Tp_alloc_type<span class="token operator">></span><span class="token operator">::</span>pointer            pointer<span class="token punctuation">;</span>    <span class="token keyword">struct</span> _Vector_impl            <span class="token operator">:</span> <span class="token keyword">public</span> _Tp_alloc_type <span class="token punctuation">{</span>        pointer _M_start<span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// 使用空间起始位置    </span>        pointer _M_finish<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 使用空间结束位置</span>        pointer _M_end_of_storage<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 可使用空间结束位置 </span>        <span class="token function">_Vector_impl</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token operator">:</span> <span class="token function">_Tp_alloc_type</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">_M_start</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">_M_finish</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">_M_end_of_storage</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>        <span class="token function">_Vector_impl</span><span class="token punctuation">(</span>_Tp_alloc_type <span class="token keyword">const</span> <span class="token operator">&amp;</span>__a<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">// vector数据交换，只交换内存地址，不交换数据</span>        <span class="token keyword">void</span> <span class="token function">_M_swap_data</span><span class="token punctuation">(</span>_Vector_impl <span class="token operator">&amp;</span>__x<span class="token punctuation">)</span>        _GLIBCXX_NOEXCEPT        <span class="token punctuation">{</span>            std<span class="token operator">::</span><span class="token function">swap</span><span class="token punctuation">(</span>_M_start<span class="token punctuation">,</span> __x<span class="token punctuation">.</span>_M_start<span class="token punctuation">)</span><span class="token punctuation">;</span>            std<span class="token operator">::</span><span class="token function">swap</span><span class="token punctuation">(</span>_M_finish<span class="token punctuation">,</span> __x<span class="token punctuation">.</span>_M_finish<span class="token punctuation">)</span><span class="token punctuation">;</span>            std<span class="token operator">::</span><span class="token function">swap</span><span class="token punctuation">(</span>_M_end_of_storage<span class="token punctuation">,</span> __x<span class="token punctuation">.</span>_M_end_of_storage<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">typedef</span> _Alloc allocator_type<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 前面我们知道_Vector_impl继承自allocator分配器，而这个又是_Tp_alloc_type，所以这里返回的就是_M_impl的基类。</span>    _Tp_alloc_type <span class="token operator">&amp;</span>    <span class="token function">_M_get_Tp_allocator</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    _GLIBCXX_NOEXCEPT    <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">static_cast</span><span class="token operator">&lt;</span>_Tp_alloc_type <span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token keyword">const</span> _Tp_alloc_type <span class="token operator">&amp;</span>    <span class="token function">_M_get_Tp_allocator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>    _GLIBCXX_NOEXCEPT    <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">static_cast</span><span class="token operator">&lt;</span><span class="token keyword">const</span> _Tp_alloc_type <span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    allocator_type    <span class="token comment" spellcheck="true">// 获取传递进来的分配器      </span>    <span class="token function">get_allocator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>    _GLIBCXX_NOEXCEPT    <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token function">allocator_type</span><span class="token punctuation">(</span><span class="token function">_M_get_Tp_allocator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token function">_Vector_base</span><span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token operator">:</span> <span class="token function">_M_impl</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token function">_Vector_base</span><span class="token punctuation">(</span><span class="token keyword">const</span> allocator_type <span class="token operator">&amp;</span>__a<span class="token punctuation">)</span>    _GLIBCXX_NOEXCEPT            <span class="token operator">:</span> <span class="token function">_M_impl</span><span class="token punctuation">(</span>__a<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token function">_Vector_base</span><span class="token punctuation">(</span>size_t __n<span class="token punctuation">)</span>            <span class="token operator">:</span> <span class="token function">_M_impl</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">_M_create_storage</span><span class="token punctuation">(</span>__n<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token function">_Vector_base</span><span class="token punctuation">(</span>size_t __n<span class="token punctuation">,</span> <span class="token keyword">const</span> allocator_type <span class="token operator">&amp;</span>__a<span class="token punctuation">)</span>            <span class="token operator">:</span> <span class="token function">_M_impl</span><span class="token punctuation">(</span>__a<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">_M_create_storage</span><span class="token punctuation">(</span>__n<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token macro property">#<span class="token directive keyword">if</span> __cplusplus >= 201103L</span>    <span class="token function">_Vector_base</span><span class="token punctuation">(</span>_Tp_alloc_type<span class="token operator">&amp;&amp;</span> __a<span class="token punctuation">)</span> <span class="token keyword">noexcept</span>    <span class="token operator">:</span> <span class="token function">_M_impl</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>__a<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 移动构造函数，只交换3个指针，不copy数据</span>    <span class="token function">_Vector_base</span><span class="token punctuation">(</span>_Vector_base<span class="token operator">&amp;&amp;</span> __x<span class="token punctuation">)</span> <span class="token keyword">noexcept</span>    <span class="token operator">:</span> <span class="token function">_M_impl</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>__x<span class="token punctuation">.</span><span class="token function">_M_get_Tp_allocator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span> <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span><span class="token function">_M_swap_data</span><span class="token punctuation">(</span>__x<span class="token punctuation">.</span>_M_impl<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token function">_Vector_base</span><span class="token punctuation">(</span>_Vector_base<span class="token operator">&amp;&amp;</span> __x<span class="token punctuation">,</span> <span class="token keyword">const</span> allocator_type<span class="token operator">&amp;</span> __a<span class="token punctuation">)</span>    <span class="token operator">:</span> <span class="token function">_M_impl</span><span class="token punctuation">(</span>__a<span class="token punctuation">)</span>    <span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>__x<span class="token punctuation">.</span><span class="token function">get_allocator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> __a<span class="token punctuation">)</span>    <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span><span class="token function">_M_swap_data</span><span class="token punctuation">(</span>__x<span class="token punctuation">.</span>_M_impl<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">else</span>    <span class="token punctuation">{</span>      size_t __n <span class="token operator">=</span> __x<span class="token punctuation">.</span>_M_impl<span class="token punctuation">.</span>_M_finish <span class="token operator">-</span> __x<span class="token punctuation">.</span>_M_impl<span class="token punctuation">.</span>_M_start<span class="token punctuation">;</span>      <span class="token function">_M_create_storage</span><span class="token punctuation">(</span>__n<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token macro property">#<span class="token directive keyword">endif</span></span>    <span class="token operator">~</span><span class="token function">_Vector_base</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    _GLIBCXX_NOEXCEPT    <span class="token punctuation">{</span>        <span class="token function">_M_deallocate</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_start<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_end_of_storage                                              <span class="token operator">-</span> <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_start<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">public</span><span class="token operator">:</span>    _Vector_impl _M_impl<span class="token punctuation">;</span>    pointer <span class="token function">_M_allocate</span><span class="token punctuation">(</span>size_t __n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">typedef</span> __gnu_cxx<span class="token operator">::</span>__alloc_traits <span class="token operator">&lt;</span>_Tp_alloc_type<span class="token operator">></span> _Tr<span class="token punctuation">;</span>        <span class="token keyword">return</span> __n <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">?</span> _Tr<span class="token operator">::</span><span class="token function">allocate</span><span class="token punctuation">(</span>_M_impl<span class="token punctuation">,</span> __n<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 同_M_deallocate，一直往后调用的就是malloc函数</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">_M_deallocate</span><span class="token punctuation">(</span>pointer __p<span class="token punctuation">,</span> size_t __n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">typedef</span> __gnu_cxx<span class="token operator">::</span>__alloc_traits <span class="token operator">&lt;</span>_Tp_alloc_type<span class="token operator">></span> _Tr<span class="token punctuation">;</span>         <span class="token keyword">if</span> <span class="token punctuation">(</span>__p<span class="token punctuation">)</span>            _Tr<span class="token operator">::</span><span class="token function">deallocate</span><span class="token punctuation">(</span>_M_impl<span class="token punctuation">,</span> __p<span class="token punctuation">,</span> __n<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 最后调用allocator_traits的deallocate,而该函数又是根据传递进来的_M_impl进行deallocate,一直往后，最后调用的就是free函数</span>    <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">_M_create_storage</span><span class="token punctuation">(</span>size_t __n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_start <span class="token operator">=</span> <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">_M_allocate</span><span class="token punctuation">(</span>__n<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_finish <span class="token operator">=</span> <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_start<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_end_of_storage <span class="token operator">=</span> <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_start <span class="token operator">+</span> __n<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>小结：<code>_Vector_base</code>专门负责<code>vector</code>的内存管理，内部类<code>_M_impl</code>通过继承<code>_Tp_alloc_type</code>(也就是allocator)得到内存分配释放的功能，<em>M</em>allocate和<em>M</em>deallocate分别分配和释放vector所用内存，vector只需要负责元素构造和析构。</p><p>在vector中，默认内存分配器为<code>std::allocator&lt;_Tp&gt;</code></p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _Tp<span class="token punctuation">,</span> <span class="token keyword">typename</span> _Alloc <span class="token operator">=</span> std<span class="token operator">::</span>allocator<span class="token operator">&lt;</span>_Tp<span class="token operator">>></span><span class="token keyword">class</span> <span class="token class-name">vector</span> <span class="token operator">:</span> <span class="token keyword">protected</span> _Vector_base<span class="token operator">&lt;</span>_Tp<span class="token punctuation">,</span> _Alloc<span class="token operator">></span> <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><p>vector代码中使用基类的内存函数及typedef等：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _Tp<span class="token punctuation">,</span> <span class="token keyword">typename</span> _Alloc <span class="token operator">=</span> std<span class="token operator">::</span>allocator<span class="token operator">&lt;</span>_Tp<span class="token operator">>></span><span class="token keyword">class</span> <span class="token class-name">vector</span> <span class="token operator">:</span> <span class="token keyword">protected</span> _Vector_base<span class="token operator">&lt;</span>_Tp<span class="token punctuation">,</span> _Alloc<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">typedef</span> _Vector_base<span class="token operator">&lt;</span>_Tp<span class="token punctuation">,</span> _Alloc<span class="token operator">></span> _Base<span class="token punctuation">;</span>    <span class="token keyword">typedef</span> <span class="token keyword">typename</span> _Base<span class="token operator">::</span>_Tp_alloc_type _Tp_alloc_type<span class="token punctuation">;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">typedef</span> <span class="token keyword">typename</span> _Base<span class="token operator">::</span>pointer pointer<span class="token punctuation">;</span><span class="token keyword">protected</span><span class="token operator">:</span>    <span class="token keyword">using</span> _Base<span class="token operator">::</span>_M_allocate<span class="token punctuation">;</span>    <span class="token keyword">using</span> _Base<span class="token operator">::</span>_M_deallocate<span class="token punctuation">;</span>    <span class="token keyword">using</span> _Base<span class="token operator">::</span>_M_impl<span class="token punctuation">;</span>    <span class="token keyword">using</span> _Base<span class="token operator">::</span>_M_get_Tp_allocator<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="2-vector迭代器"><a href="#2-vector迭代器" class="headerlink" title="2.vector迭代器"></a>2.vector迭代器</h2><p>在vector中使用了两种迭代器，分别是正向<code>__normal_iterator</code>与反向迭代器<code>reverse_iterator</code>:</p><p>正向：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">typedef</span> __gnu_cxx<span class="token operator">::</span>__normal_iterator <span class="token operator">&lt;</span>pointer<span class="token punctuation">,</span> vector<span class="token operator">></span> iterator<span class="token punctuation">;</span><span class="token keyword">typedef</span> __gnu_cxx<span class="token operator">::</span>__normal_iterator <span class="token operator">&lt;</span>const_pointer<span class="token punctuation">,</span> vector<span class="token operator">></span> const_iterator<span class="token punctuation">;</span></code></pre><p>反向：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">typedef</span> std<span class="token operator">::</span>reverse_iterator<span class="token operator">&lt;</span>const_iterator<span class="token operator">></span> const_reverse_iterator<span class="token punctuation">;</span><span class="token keyword">typedef</span> std<span class="token operator">::</span>reverse_iterator<span class="token operator">&lt;</span>iterator<span class="token operator">></span> reverse_iterator<span class="token punctuation">;</span></code></pre><p><code>__normal_iterator</code>与<code>reverse_iterator</code>都定义于stl_iterator.h，封装了vector元素的指针。</p><h3 id="2-1-正向"><a href="#2-1-正向" class="headerlink" title="2.1 正向"></a>2.1 正向</h3><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _Iterator<span class="token punctuation">,</span> <span class="token keyword">typename</span> _Container<span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">__normal_iterator</span><span class="token punctuation">{</span><span class="token keyword">protected</span><span class="token operator">:</span>    _Iterator _M_current<span class="token punctuation">;</span>    <span class="token keyword">typedef</span> iterator_traits<span class="token operator">&lt;</span>_Iterator<span class="token operator">></span>        __traits_type<span class="token punctuation">;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">typedef</span> _Iterator                    iterator_type<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// iterator必须包含的五种typedef</span>    <span class="token keyword">typedef</span> <span class="token keyword">typename</span> __traits_type<span class="token operator">::</span>iterator_category iterator_category<span class="token punctuation">;</span>    <span class="token keyword">typedef</span> <span class="token keyword">typename</span> __traits_type<span class="token operator">::</span>value_type      value_type<span class="token punctuation">;</span>    <span class="token keyword">typedef</span> <span class="token keyword">typename</span> __traits_type<span class="token operator">::</span>difference_type     difference_type<span class="token punctuation">;</span>    <span class="token keyword">typedef</span> <span class="token keyword">typename</span> __traits_type<span class="token operator">::</span>reference     reference<span class="token punctuation">;</span>    <span class="token keyword">typedef</span> <span class="token keyword">typename</span> __traits_type<span class="token operator">::</span>pointer       pointer<span class="token punctuation">;</span>    _GLIBCXX_CONSTEXPR <span class="token function">__normal_iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> _GLIBCXX_NOEXCEPT    <span class="token operator">:</span> <span class="token function">_M_current</span><span class="token punctuation">(</span><span class="token function">_Iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>    <span class="token keyword">explicit</span>    <span class="token function">__normal_iterator</span><span class="token punctuation">(</span><span class="token keyword">const</span> _Iterator<span class="token operator">&amp;</span> __i<span class="token punctuation">)</span> _GLIBCXX_NOEXCEPT    <span class="token operator">:</span> <span class="token function">_M_current</span><span class="token punctuation">(</span>__i<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// Allow iterator to const_iterator conversion</span>    <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _Iter<span class="token operator">></span>    <span class="token function">__normal_iterator</span><span class="token punctuation">(</span><span class="token keyword">const</span> __normal_iterator<span class="token operator">&lt;</span>_Iter<span class="token punctuation">,</span>            <span class="token keyword">typename</span> __enable_if<span class="token operator">&lt;</span>            <span class="token punctuation">(</span>std<span class="token operator">::</span>__are_same<span class="token operator">&lt;</span>_Iter<span class="token punctuation">,</span> <span class="token keyword">typename</span> _Container<span class="token operator">::</span>pointer<span class="token operator">></span><span class="token operator">::</span>__value<span class="token punctuation">)</span><span class="token punctuation">,</span>            _Container<span class="token operator">></span><span class="token operator">::</span>__type<span class="token operator">></span><span class="token operator">&amp;</span> __i<span class="token punctuation">)</span> _GLIBCXX_NOEXCEPT    <span class="token operator">:</span> <span class="token function">_M_current</span><span class="token punctuation">(</span>__i<span class="token punctuation">.</span><span class="token function">base</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// Forward iterator requirements</span>    reference    <span class="token keyword">operator</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> _GLIBCXX_NOEXCEPT    <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token operator">*</span>_M_current<span class="token punctuation">;</span> <span class="token punctuation">}</span>    pointer    <span class="token keyword">operator</span><span class="token operator">-</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> _GLIBCXX_NOEXCEPT    <span class="token punctuation">{</span> <span class="token keyword">return</span> _M_current<span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 前置++</span>    __normal_iterator<span class="token operator">&amp;</span>    <span class="token keyword">operator</span><span class="token operator">++</span><span class="token punctuation">(</span><span class="token punctuation">)</span> _GLIBCXX_NOEXCEPT    <span class="token punctuation">{</span>        <span class="token operator">++</span>_M_current<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 后置++</span>    __normal_iterator    <span class="token keyword">operator</span><span class="token operator">++</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> _GLIBCXX_NOEXCEPT    <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token function">__normal_iterator</span><span class="token punctuation">(</span>_M_current<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 前置--</span>    <span class="token comment" spellcheck="true">// Bidirectional iterator requirements</span>    __normal_iterator<span class="token operator">&amp;</span>    <span class="token keyword">operator</span><span class="token operator">--</span><span class="token punctuation">(</span><span class="token punctuation">)</span> _GLIBCXX_NOEXCEPT    <span class="token punctuation">{</span>        <span class="token operator">--</span>_M_current<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 后置--</span>    __normal_iterator    <span class="token keyword">operator</span><span class="token operator">--</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> _GLIBCXX_NOEXCEPT    <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token function">__normal_iterator</span><span class="token punctuation">(</span>_M_current<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 随机访问迭代器都要重载[]操作符</span>    <span class="token comment" spellcheck="true">// Random access iterator requirements</span>    reference    <span class="token keyword">operator</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>difference_type __n<span class="token punctuation">)</span> <span class="token keyword">const</span> _GLIBCXX_NOEXCEPT    <span class="token punctuation">{</span> <span class="token keyword">return</span> _M_current<span class="token punctuation">[</span>__n<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// +=操作符 跳跃n个difference_type</span>    __normal_iterator<span class="token operator">&amp;</span>    <span class="token keyword">operator</span><span class="token operator">+</span><span class="token operator">=</span><span class="token punctuation">(</span>difference_type __n<span class="token punctuation">)</span> _GLIBCXX_NOEXCEPT    <span class="token punctuation">{</span> _M_current <span class="token operator">+</span><span class="token operator">=</span> __n<span class="token punctuation">;</span> <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// +操作符 跳跃n个difference_type</span>    __normal_iterator    <span class="token keyword">operator</span><span class="token operator">+</span><span class="token punctuation">(</span>difference_type __n<span class="token punctuation">)</span> <span class="token keyword">const</span> _GLIBCXX_NOEXCEPT    <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token function">__normal_iterator</span><span class="token punctuation">(</span>_M_current <span class="token operator">+</span> __n<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// -=操作符 后退n个difference_type</span>    __normal_iterator<span class="token operator">&amp;</span>    <span class="token keyword">operator</span><span class="token operator">-</span><span class="token operator">=</span><span class="token punctuation">(</span>difference_type __n<span class="token punctuation">)</span> _GLIBCXX_NOEXCEPT    <span class="token punctuation">{</span> _M_current <span class="token operator">-</span><span class="token operator">=</span> __n<span class="token punctuation">;</span> <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// -操作符 后退n个difference_type</span>    __normal_iterator    <span class="token keyword">operator</span><span class="token operator">-</span><span class="token punctuation">(</span>difference_type __n<span class="token punctuation">)</span> <span class="token keyword">const</span> _GLIBCXX_NOEXCEPT    <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token function">__normal_iterator</span><span class="token punctuation">(</span>_M_current <span class="token operator">-</span> __n<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token keyword">const</span> _Iterator<span class="token operator">&amp;</span>    <span class="token function">base</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> _GLIBCXX_NOEXCEPT    <span class="token punctuation">{</span> <span class="token keyword">return</span> _M_current<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p><em>M</em>current是指向迭代器位置的指针，这是一个随机访问型指针，operator+和operator-等移动操作可以直接移动到目的地，非随机访问型指针只能一步步移动。</p><h3 id="2-2-反向"><a href="#2-2-反向" class="headerlink" title="2.2 反向"></a>2.2 反向</h3><p>vector还会使用reverse_iterator，即逆序迭代器，顾名思义，其移动方向与普通迭代器相反</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _Iterator<span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">reverse_iterator</span><span class="token operator">:</span> <span class="token keyword">public</span> iterator<span class="token operator">&lt;</span><span class="token keyword">typename</span> iterator_traits<span class="token operator">&lt;</span>_Iterator<span class="token operator">></span><span class="token operator">::</span>iterator_category<span class="token punctuation">,</span>            <span class="token keyword">typename</span> iterator_traits<span class="token operator">&lt;</span>_Iterator<span class="token operator">></span><span class="token operator">::</span>value_type<span class="token punctuation">,</span>            <span class="token keyword">typename</span> iterator_traits<span class="token operator">&lt;</span>_Iterator<span class="token operator">></span><span class="token operator">::</span>difference_type<span class="token punctuation">,</span>            <span class="token keyword">typename</span> iterator_traits<span class="token operator">&lt;</span>_Iterator<span class="token operator">></span><span class="token operator">::</span>pointer<span class="token punctuation">,</span>                    <span class="token keyword">typename</span> iterator_traits<span class="token operator">&lt;</span>_Iterator<span class="token operator">></span><span class="token operator">::</span>reference<span class="token operator">></span><span class="token punctuation">{</span><span class="token keyword">protected</span><span class="token operator">:</span>    _Iterator current<span class="token punctuation">;</span>    <span class="token keyword">typedef</span> iterator_traits<span class="token operator">&lt;</span>_Iterator<span class="token operator">></span>        __traits_type<span class="token punctuation">;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">typedef</span> _Iterator                    iterator_type<span class="token punctuation">;</span>    <span class="token keyword">typedef</span> <span class="token keyword">typename</span> __traits_type<span class="token operator">::</span>difference_type    difference_type<span class="token punctuation">;</span>    <span class="token keyword">typedef</span> <span class="token keyword">typename</span> __traits_type<span class="token operator">::</span>pointer        pointer<span class="token punctuation">;</span>    <span class="token keyword">typedef</span> <span class="token keyword">typename</span> __traits_type<span class="token operator">::</span>reference        reference<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 省略不重要的代码</span>    <span class="token comment" spellcheck="true">// 该迭代器是从后面end()开始，需要往前一步，才可以获取到有效的迭代器位置</span>    reference    <span class="token keyword">operator</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>    <span class="token punctuation">{</span>        _Iterator __tmp <span class="token operator">=</span> current<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">*</span><span class="token operator">--</span>__tmp<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 通过调用上述*操作符直接实现</span>    pointer    <span class="token keyword">operator</span><span class="token operator">-</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>    <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token keyword">operator</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 前置++操作符完成后退任务</span>    reverse_iterator<span class="token operator">&amp;</span>    <span class="token keyword">operator</span><span class="token operator">++</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token operator">--</span>current<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 后置++</span>    reverse_iterator    <span class="token keyword">operator</span><span class="token operator">++</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        reverse_iterator __tmp <span class="token operator">=</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>        <span class="token operator">--</span>current<span class="token punctuation">;</span>        <span class="token keyword">return</span> __tmp<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 前置--操作符完成前进任务</span>    reverse_iterator<span class="token operator">&amp;</span>    <span class="token keyword">operator</span><span class="token operator">--</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token operator">++</span>current<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 后置--</span>    reverse_iterator    <span class="token keyword">operator</span><span class="token operator">--</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        reverse_iterator __tmp <span class="token operator">=</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>        <span class="token operator">++</span>current<span class="token punctuation">;</span>        <span class="token keyword">return</span> __tmp<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// +操作符</span>    reverse_iterator    <span class="token keyword">operator</span><span class="token operator">+</span><span class="token punctuation">(</span>difference_type __n<span class="token punctuation">)</span> <span class="token keyword">const</span>    <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token function">reverse_iterator</span><span class="token punctuation">(</span>current <span class="token operator">-</span> __n<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// +=操作符</span>    reverse_iterator<span class="token operator">&amp;</span>    <span class="token keyword">operator</span><span class="token operator">+</span><span class="token operator">=</span><span class="token punctuation">(</span>difference_type __n<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        current <span class="token operator">-</span><span class="token operator">=</span> __n<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// -操作符</span>    reverse_iterator    <span class="token keyword">operator</span><span class="token operator">-</span><span class="token punctuation">(</span>difference_type __n<span class="token punctuation">)</span> <span class="token keyword">const</span>    <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token function">reverse_iterator</span><span class="token punctuation">(</span>current <span class="token operator">+</span> __n<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// -=操作符</span>    reverse_iterator<span class="token operator">&amp;</span>    <span class="token keyword">operator</span><span class="token operator">-</span><span class="token operator">=</span><span class="token punctuation">(</span>difference_type __n<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        current <span class="token operator">+</span><span class="token operator">=</span> __n<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// []操作符</span>    reference    <span class="token keyword">operator</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>difference_type __n<span class="token punctuation">)</span> <span class="token keyword">const</span>    <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token keyword">this</span> <span class="token operator">+</span> __n<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><h2 id="3-vector的数据结构"><a href="#3-vector的数据结构" class="headerlink" title="3.vector的数据结构"></a>3.vector的数据结构</h2><p>vector内存由<em>M</em>impl中的M_start，<em>M</em>finish，<em>M</em>end_of_storage三个指针管理，所有关于地址，容量大小等操作都需要用到这三个指针：</p><pre class=" language-cpp"><code class="language-cpp">iterator <span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> _GLIBCXX_NOEXCEPT    <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token function">iterator</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_start<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>iterator <span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span> _GLIBCXX_NOEXCEPT    <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token function">iterator</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_finish<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>reverse_iterator  <span class="token function">rbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span>    <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token function">reverse_iterator</span><span class="token punctuation">(</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>reverse_iterator <span class="token function">rend</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span>    <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token function">reverse_iterator</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>size_type <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> _GLIBCXX_NOEXCEPT    <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token function">size_type</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_finish <span class="token operator">-</span> <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_start<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>size_type <span class="token function">capacity</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> _GLIBCXX_NOEXCEPT    <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token function">size_type</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_end_of_storage <span class="token operator">-</span> <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_start<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">bool</span> <span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> _GLIBCXX_NOEXCEPT    <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre><p><img src="https://raw.githubusercontent.com/Light-City/cloudimg/master/vector_1.png" alt="vector_1.png"></p><p><em>M</em>finish和<em>M</em>end_of_storage之间的空间没有数据，有时候这是一种浪费，c++11提供了一个很有用的函数shrink_to_fit()，将这段未使用空间释放，主要调用了下面代码，</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _Alloc<span class="token operator">></span><span class="token keyword">bool</span> vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token punctuation">,</span> _Alloc<span class="token operator">></span><span class="token operator">::</span><span class="token function">_M_shrink_to_fit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">capacity</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token keyword">int</span><span class="token punctuation">(</span>_S_word_bit<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 64位系统为64bytes</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    __try    <span class="token punctuation">{</span>        <span class="token function">_M_reallocate</span><span class="token punctuation">(</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">__catch</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>         <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-cpp"><code class="language-cpp"> <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _Alloc<span class="token operator">></span><span class="token keyword">void</span> vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token punctuation">,</span> _Alloc<span class="token operator">></span><span class="token operator">::</span><span class="token function">_M_reallocate</span><span class="token punctuation">(</span>size_type __n<span class="token punctuation">)</span><span class="token punctuation">{</span>    _Bit_type<span class="token operator">*</span> __q <span class="token operator">=</span> <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">_M_allocate</span><span class="token punctuation">(</span>__n<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_finish <span class="token operator">=</span> <span class="token function">_M_copy_aligned</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                    <span class="token function">iterator</span><span class="token punctuation">(</span>__q<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">_M_deallocate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_start <span class="token operator">=</span> <span class="token function">iterator</span><span class="token punctuation">(</span>__q<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_end_of_storage <span class="token operator">=</span> __q <span class="token operator">+</span> <span class="token function">_S_nword</span><span class="token punctuation">(</span>__n<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>而<code>_M_copy_aligned</code>通过两个std::copy实现:</p><p>第一次swap把<code>__first</code>的指针与<code>__last</code>的指针之间的数据拷贝到<code>__result</code>指针所指向的起始位置。<br>第二次swap获得<code>__last</code>的指针对应的迭代器。</p><pre class=" language-cpp"><code class="language-cpp">iterator<span class="token function">_M_copy_aligned</span><span class="token punctuation">(</span>const_iterator __first<span class="token punctuation">,</span> const_iterator __last<span class="token punctuation">,</span>        iterator __result<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// _Bit_type * _M_p; _Bit_type为unsigned long类型</span>    _Bit_type<span class="token operator">*</span> __q <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">copy</span><span class="token punctuation">(</span>__first<span class="token punctuation">.</span>_M_p<span class="token punctuation">,</span> __last<span class="token punctuation">.</span>_M_p<span class="token punctuation">,</span> __result<span class="token punctuation">.</span>_M_p<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> std<span class="token operator">::</span><span class="token function">copy</span><span class="token punctuation">(</span><span class="token function">const_iterator</span><span class="token punctuation">(</span>__last<span class="token punctuation">.</span>_M_p<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> __last<span class="token punctuation">,</span>            <span class="token function">iterator</span><span class="token punctuation">(</span>__q<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>先分配size()大小的内存空间，用于存储<code>begin()</code>与<code>end()</code>之间的数据，释放原来的vector空间，新的vector只包含size()数量的数据，并修改<code>_M_start</code>与<code>_M_end_of_storage</code>指向。</p><h2 id="4-vector构造与析构"><a href="#4-vector构造与析构" class="headerlink" title="4.vector构造与析构"></a>4.vector构造与析构</h2><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//使用默认内存分配器</span><span class="token function">vector</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">_Base</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span> <span class="token comment" spellcheck="true">//指定内存分配器</span><span class="token keyword">explicit</span> <span class="token function">vector</span><span class="token punctuation">(</span><span class="token keyword">const</span> allocator_type<span class="token operator">&amp;</span> __a<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">_Base</span><span class="token punctuation">(</span>__a<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//初始化为n个__value值，如果没指定就使用该类型默认值</span><span class="token keyword">explicit</span> <span class="token function">vector</span><span class="token punctuation">(</span>size_type __n<span class="token punctuation">,</span> <span class="token keyword">const</span> value_type<span class="token operator">&amp;</span> __value <span class="token operator">=</span> <span class="token function">value_type</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>             <span class="token keyword">const</span> allocator_type<span class="token operator">&amp;</span> __a <span class="token operator">=</span> <span class="token function">allocator_type</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token function">_Base</span><span class="token punctuation">(</span>__n<span class="token punctuation">,</span> __a<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token function">_M_fill_initialize</span><span class="token punctuation">(</span>__n<span class="token punctuation">,</span> __value<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//拷贝构造函数</span><span class="token function">vector</span><span class="token punctuation">(</span><span class="token keyword">const</span> vector<span class="token operator">&amp;</span> __x<span class="token punctuation">)</span>    <span class="token operator">:</span> <span class="token function">_Base</span><span class="token punctuation">(</span>__x<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    _Alloc_traits<span class="token operator">::</span><span class="token function">_S_select_on_copy</span><span class="token punctuation">(</span>__x<span class="token punctuation">.</span><span class="token function">_M_get_Tp_allocator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_finish <span class="token operator">=</span>    std<span class="token operator">::</span><span class="token function">__uninitialized_copy_a</span><span class="token punctuation">(</span>__x<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> __x<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                                <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_start<span class="token punctuation">,</span>                                <span class="token function">_M_get_Tp_allocator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//c++11的移动构造函数，获取__x的M_start，_M_finish，_M_end_of_storage，并不需要数据拷贝</span><span class="token function">vector</span><span class="token punctuation">(</span>vector<span class="token operator">&amp;&amp;</span> <span class="token punctuation">)</span> <span class="token keyword">noexcept</span>    <span class="token operator">:</span> <span class="token function">_Base</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>__x<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//从list中拷贝数据，也是c++11才有的</span> <span class="token function">vector</span><span class="token punctuation">(</span>initializer_list<span class="token operator">&lt;</span>value_type<span class="token operator">></span> __l<span class="token punctuation">,</span>        <span class="token keyword">const</span> allocator_type<span class="token operator">&amp;</span> __a <span class="token operator">=</span> <span class="token function">allocator_type</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token function">_Base</span><span class="token punctuation">(</span>__a<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">_M_range_initialize</span><span class="token punctuation">(</span>__l<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> __l<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">random_access_iterator_tag</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//支持vector使用两个迭代器范围内的值初始化，除了stl的迭代器，也可以是数组地址</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _InputIterator<span class="token punctuation">,</span>        <span class="token keyword">typename</span> <span class="token operator">=</span> std<span class="token operator">::</span>_RequireInputIter<span class="token operator">&lt;</span>_InputIterator<span class="token operator">>></span><span class="token function">vector</span><span class="token punctuation">(</span>_InputIterator __first<span class="token punctuation">,</span> _InputIterator __last<span class="token punctuation">,</span>        <span class="token keyword">const</span> allocator_type<span class="token operator">&amp;</span> __a <span class="token operator">=</span> <span class="token function">allocator_type</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token function">_Base</span><span class="token punctuation">(</span>__a<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token function">_M_initialize_dispatch</span><span class="token punctuation">(</span>__first<span class="token punctuation">,</span> __last<span class="token punctuation">,</span> <span class="token function">__false_type</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//只析构所有元素，释放内存由vector_base完成</span><span class="token operator">~</span><span class="token function">vector</span><span class="token punctuation">(</span><span class="token punctuation">)</span> _GLIBCXX_NOEXCEPT<span class="token punctuation">{</span> std<span class="token operator">::</span><span class="token function">_Destroy</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_start<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_finish<span class="token punctuation">,</span><span class="token function">_M_get_Tp_allocator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre><h2 id="5-vector"><a href="#5-vector" class="headerlink" title="5.vector"></a>5.vector</h2><p>插入涉及到内存分配，动态调整，与一开始提到的vector与array区别，就在下面体现出：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">typename</span> vector<span class="token operator">&lt;</span>_Tp<span class="token punctuation">,</span> _Alloc<span class="token operator">></span><span class="token operator">::</span>iteratorvector<span class="token operator">&lt;</span>_Tp<span class="token punctuation">,</span> _Alloc<span class="token operator">></span><span class="token operator">::</span><span class="token function">insert</span><span class="token punctuation">(</span>iterator __position<span class="token punctuation">,</span> <span class="token keyword">const</span> value_type<span class="token operator">&amp;</span> __x<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">const</span> size_type __n <span class="token operator">=</span> __position – <span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//插入到最后一个位置，相当于push_back</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_finish <span class="token operator">!=</span> <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_end_of_storage        <span class="token operator">&amp;&amp;</span> __position <span class="token operator">==</span> <span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        _Alloc_traits<span class="token operator">::</span><span class="token function">construct</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_finish<span class="token punctuation">,</span> __x<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">++</span><span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_finish<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span>    <span class="token punctuation">{</span>        <span class="token function">_M_insert_aux</span><span class="token punctuation">(</span>__position<span class="token punctuation">,</span> __x<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token function">iterator</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_start <span class="token operator">+</span> __n<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>其中<code>_M_insert_aux</code>实现：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _Tp<span class="token punctuation">,</span> <span class="token keyword">typename</span> _Alloc<span class="token operator">></span><span class="token keyword">void</span> vector<span class="token operator">&lt;</span>_Tp<span class="token punctuation">,</span> _Alloc<span class="token operator">></span><span class="token operator">::</span><span class="token function">_M_insert_aux</span><span class="token punctuation">(</span>iterator __position<span class="token punctuation">,</span> <span class="token keyword">const</span> _Tp<span class="token operator">&amp;</span> __x<span class="token punctuation">)</span><span class="token punctuation">{</span>       <span class="token comment" spellcheck="true">//内存空间足够</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_finish <span class="token operator">!=</span> <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_end_of_storage<span class="token punctuation">)</span>    <span class="token punctuation">{</span>         _Alloc_traits<span class="token operator">::</span><span class="token function">construct</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_finish<span class="token punctuation">,</span>                                <span class="token function">_GLIBCXX_MOVE</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_finish                                                <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">++</span><span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_finish<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//__position后的元素依次向后移动一个位置</span>        <span class="token function">_GLIBCXX_MOVE_BACKWARD3</span><span class="token punctuation">(</span>__position<span class="token punctuation">.</span><span class="token function">base</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                                <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_finish <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">,</span>                                <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_finish – <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//目标地址赋值</span>        <span class="token operator">*</span>__position <span class="token operator">=</span> <span class="token function">_Tp</span><span class="token punctuation">(</span>std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>_Args<span class="token operator">></span><span class="token punctuation">(</span>__args<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span>    <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//内存加倍</span>        <span class="token keyword">const</span> size_type __len <span class="token operator">=</span>        <span class="token function">_M_check_len</span><span class="token punctuation">(</span><span class="token function">size_type</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"vector::_M_insert_aux"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">const</span> size_type __elems_before <span class="token operator">=</span> __position <span class="token operator">-</span> <span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        pointer <span class="token function">__new_start</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">_M_allocate</span><span class="token punctuation">(</span>__len<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        pointer <span class="token function">__new_finish</span><span class="token punctuation">(</span>__new_start<span class="token punctuation">)</span><span class="token punctuation">;</span>        __try        <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//给position位置赋值</span>            _Alloc_traits<span class="token operator">::</span><span class="token function">construct</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">,</span>                                    __new_start <span class="token operator">+</span> __elems_before<span class="token punctuation">,</span>                                    std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>_Args<span class="token operator">></span><span class="token punctuation">(</span>__args<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                    __x<span class="token punctuation">)</span><span class="token punctuation">;</span>            __new_finish <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//拷贝position位置前元素</span>            __new_finish <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">__uninitialized_move_if_noexcept_a</span>            <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_start<span class="token punctuation">,</span> __position<span class="token punctuation">.</span><span class="token function">base</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                __new_start<span class="token punctuation">,</span> <span class="token function">_M_get_Tp_allocator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token operator">++</span>__new_finish<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//拷贝position位置后元素</span>            __new_finish            <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">__uninitialized_move_if_noexcept_a</span>            <span class="token punctuation">(</span>__position<span class="token punctuation">.</span><span class="token function">base</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_finish<span class="token punctuation">,</span>                __new_finish<span class="token punctuation">,</span> <span class="token function">_M_get_Tp_allocator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token function">__catch</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>__new_finish<span class="token punctuation">)</span>            _Alloc_traits<span class="token operator">::</span><span class="token function">destroy</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">,</span>                                    __new_start <span class="token operator">+</span> __elems_before<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">else</span>            std<span class="token operator">::</span><span class="token function">_Destroy</span><span class="token punctuation">(</span>__new_start<span class="token punctuation">,</span> __new_finish<span class="token punctuation">,</span> <span class="token function">_M_get_Tp_allocator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">_M_deallocate</span><span class="token punctuation">(</span>__new_start<span class="token punctuation">,</span> __len<span class="token punctuation">)</span><span class="token punctuation">;</span>            __throw_exception_again<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//析构原vector所有元素</span>        std<span class="token operator">::</span><span class="token function">_Destroy</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_start<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_finish<span class="token punctuation">,</span>                    <span class="token function">_M_get_Tp_allocator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//释放原vector内存空间</span>        <span class="token function">_M_deallocate</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_start<span class="token punctuation">,</span>                    <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_end_of_storage，<span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_start<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//vector内存地址指向新空间</span>        <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_start <span class="token operator">=</span> __new_start<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_finish <span class="token operator">=</span> __new_finish<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_end_of_storage <span class="token operator">=</span> __new_start <span class="token operator">+</span> __len<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>其中<code>_M_check_len</code>：</p><pre class=" language-cpp"><code class="language-cpp">size_type<span class="token function">_M_check_len</span><span class="token punctuation">(</span>size_type __n<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> __s<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">max_size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> __n<span class="token punctuation">)</span>        <span class="token function">__throw_length_error</span><span class="token punctuation">(</span><span class="token function">__N</span><span class="token punctuation">(</span>__s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> size_type __len <span class="token operator">=</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> std<span class="token operator">::</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> __n<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//如果n小于当前size，内存加倍，否则内存增长n。</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>__len <span class="token operator">&lt;</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> __len <span class="token operator">></span> <span class="token function">max_size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token function">max_size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> __len<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>内存分配策略并不是简单的加倍，如果n小于当前size，内存加倍，否则内存增长n。</p><p>学习资料：</p><blockquote><p>侯捷《STL源码剖析》</p></blockquote><blockquote><p><a href="https://www.cnblogs.com/coderkian/p/3888429.html" target="_blank" rel="noopener">https://www.cnblogs.com/coderkian/p/3888429.html</a></p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> STL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>主题修改</title>
      <link href="/2019/10/12/zhu-ti-pei-zhi/"/>
      <url>/2019/10/12/zhu-ti-pei-zhi/</url>
      
        <content type="html"><![CDATA[<p>看板娘添加：</p><pre><code>npm install --save hexo-helper-live2d</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 主题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>测试高亮</title>
      <link href="/2019/10/12/ce-shi-gao-liang/"/>
      <url>/2019/10/12/ce-shi-gao-liang/</url>
      
        <content type="html"><![CDATA[<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c<span class="token punctuation">,</span>d<span class="token punctuation">;</span>    <span class="token keyword">int</span> s<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span> flag <span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1000</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">10000</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span>i<span class="token operator">/</span><span class="token number">1000</span><span class="token punctuation">;</span>    s<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>i<span class="token operator">%</span><span class="token number">1000</span><span class="token operator">/</span><span class="token number">100</span><span class="token punctuation">;</span>    s<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">=</span>i<span class="token operator">%</span><span class="token number">100</span><span class="token operator">/</span><span class="token number">10</span><span class="token punctuation">;</span>    s<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token operator">=</span>i<span class="token operator">%</span><span class="token number">10</span><span class="token punctuation">;</span>    flag <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>https://github.com/blinkfox<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>tooltipped<span class="token punctuation">"</span></span> <span class="token attr-name">target</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>_blank<span class="token punctuation">"</span></span> <span class="token attr-name">data-tooltip</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>访问我的GitHub<span class="token punctuation">"</span></span> <span class="token attr-name">data-position</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>top<span class="token punctuation">"</span></span> <span class="token attr-name">data-delay</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>50<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>i</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>fa fa-github<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>i</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span></code></pre><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span>  </span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token comment" spellcheck="true">// main 入口函数  </span><span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Hello,World!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// printf 函数打印  </span>  <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>               <span class="token comment" spellcheck="true">// 函数返回值  </span><span class="token punctuation">}</span>  </code></pre><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span>              </span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span>                </span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Hello,World!--Way 1\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//printf 语句打印  </span>  <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"Hello,World!--Way 2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//puts 语句  </span>  <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"Hello,"</span> <span class="token string">" "</span> <span class="token string">"World!--Way 3"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//字符串拼接  </span>  std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Hello,World!--Way 4"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//C++ 教科书上写法  </span>  <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>                                        <span class="token comment" spellcheck="true">//作为注释  </span><span class="token punctuation">}</span> </code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> C </category>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ STL源码剖析之实现一个简单的iterator_category</title>
      <link href="/2019/10/08/iterator/"/>
      <url>/2019/10/08/iterator/</url>
      
        <content type="html"><![CDATA[<h1 id="C-STL源码剖析之实现一个简单的iterator-category"><a href="#C-STL源码剖析之实现一个简单的iterator-category" class="headerlink" title="C++ STL源码剖析之实现一个简单的iterator_category"></a>C++ STL源码剖析之实现一个简单的iterator_category</h1><h2 id="0-导语"><a href="#0-导语" class="headerlink" title="0.导语"></a>0.导语</h2><p>本节使用上节Traits特性，研究iterator源码，来实现一个简单的iterator_category，同时对iterator的源码结构进行分析。</p><p><strong>知其然，知其所以然，源码面前了无秘密！</strong></p><h2 id="1-利用萃取机实现一个简单的iterator-category识别"><a href="#1-利用萃取机实现一个简单的iterator-category识别" class="headerlink" title="1.利用萃取机实现一个简单的iterator_category识别"></a>1.利用萃取机实现一个简单的iterator_category识别</h2><p>上一节指出了迭代器的作用，依旧如下图所示：</p><p><img src="https://raw.githubusercontent.com/Light-City/cloudimg/master/rela.png" alt=""></p><p>迭代器是指向序列元素的指针的一种抽象。通过使用迭代器，我们可以访问序列中的某个元素、改变序列中的某个元素的值、使迭代器向前或向后行走等等。</p><p>迭代器有常见有五种类型: value_type, difference_type, reference_type, pointer_type都比较容易在 traits 和相应偏特化中提取。</p><p>但是，iterator_category一般也有5个，这个相应型别会引发较大规模的写代码工程。</p><ul><li>单向移动只读迭代器 Input Iterator</li><li>单向移动只写迭代器 Output Iterator</li><li>单向移动读写迭代器 Forward Iterator</li><li>双向移动读写迭代器 Bidirectional Iterator</li></ul><p><img src="https://raw.githubusercontent.com/Light-City/cloudimg/master/iterator.png" alt=""></p><p>例如：我们实现了 advanceII, advanceBI, advanceRAI 分别代表迭代器类型是Input Iterator，Bidirectional Iterator和Random Access Iterator的对应实现。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">Iterator</span><span class="token operator">></span><span class="token keyword">void</span> <span class="token function">advance</span><span class="token punctuation">(</span>Iterator<span class="token operator">&amp;</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">is_random_access_iterator</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token function">advanceRAI</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">is_bidirectional_iterator</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token function">advanceBI</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>        <span class="token function">advanceII</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>但这样在执行时期才决定使用哪一个版本，会<strong>影响程序效率</strong>。最好能够在编译期就选择正确的版本。</p><p>而<strong>重载</strong>这个函数机制可以达成这个目标。</p><p>而对于<code>advanceXX()</code>都有两个函数参数，型别都未定(因为都是模板参数)。为了令其同名，形成重载函数，我们必须加上一个型别已确定的函数参数，使函数重载机制得以有效运作起来。</p><p>设计如下：如果<strong>traits</strong>有能力萃取出迭代器的种类，我们便可利用这个”迭代器类型”相应型别作为advancexx的第三个参数，而这个相应型别必须是一个class type，不能只是数值号码类的东西，因为编译器需依赖它来进行<strong>重载决议</strong>。</p><p>下面来进行实现，首先给出一个总体结构图：</p><p><img src="https://raw.githubusercontent.com/Light-City/cloudimg/master/itera.png" alt=""></p><p>定义出下面tag：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> input_iterator_tag <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> output_iterator_tag <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> forward_iterator_tag <span class="token operator">:</span> <span class="token keyword">public</span> input_iterator_tag <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> bidirectional_iterator_tag <span class="token operator">:</span> <span class="token keyword">public</span> forward_iterator_tag <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> random_access_iterator_tag <span class="token operator">:</span> <span class="token keyword">public</span> bidirectional_iterator_tag <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 继承的好处就是，当函数需要用 input_iterator_tag 的时候</span><span class="token comment" spellcheck="true">// 假设你传进一个forward_iterator_tag，它会沿继承向上找，知道符合条件</span></code></pre><p>声明了一些列 tag 之后，我们就可以重载 advance函数，我们把这些函数用下滑线来定义，表示在内部使用，外部不可见。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 继承的好处就是，当函数需要用 input_iterator_tag 的时候</span><span class="token comment" spellcheck="true">// 假设你传进一个forward_iterator_tag，它会沿继承向上找，知道符合条件</span><span class="token comment" spellcheck="true">// input iterator</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">inputIterator</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">distance</span><span class="token operator">></span><span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">__advance</span><span class="token punctuation">(</span>inputIterator<span class="token operator">&amp;</span>i<span class="token punctuation">,</span> distance n<span class="token punctuation">,</span>                      input_iterator_tag<span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"input tag"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// output iterator</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">outputIterator</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">distance</span><span class="token operator">></span><span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">__advance</span><span class="token punctuation">(</span>outputIterator<span class="token operator">&amp;</span>i<span class="token punctuation">,</span> distance n<span class="token punctuation">,</span>                      output_iterator_tag<span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"output tag"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// forward iterator</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">ForwardIterator</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Distance</span><span class="token operator">></span><span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">__advance</span><span class="token punctuation">(</span>ForwardIterator <span class="token operator">&amp;</span>i<span class="token punctuation">,</span> Distance n<span class="token punctuation">,</span>                      forward_iterator_tag<span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"forward tag"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// bidrectional iterator</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">BidiectionalIterator</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Distance</span><span class="token operator">></span><span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">__advance</span><span class="token punctuation">(</span>BidiectionalIterator <span class="token operator">&amp;</span>i<span class="token punctuation">,</span> Distance n<span class="token punctuation">,</span>                      bidiectional_iterator_tag<span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"bidrectional tag"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// RandomAccess iterator</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">RandomAccessIterator</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Distance</span><span class="token operator">></span><span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">__advance</span><span class="token punctuation">(</span>RandomAccessIterator <span class="token operator">&amp;</span>i<span class="token punctuation">,</span> Distance n<span class="token punctuation">,</span>                      random_access_iterator_tag<span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"randomaccess tag"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>定义萃取机：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// traits 型别</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">I</span><span class="token operator">></span><span class="token keyword">struct</span> Iterator_traits <span class="token punctuation">{</span>    <span class="token keyword">typedef</span> <span class="token keyword">typename</span> I<span class="token operator">::</span>iterator_category iterator_category<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 针对原生指针设计的"偏特化版"</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">I</span><span class="token operator">></span><span class="token keyword">struct</span> Iterator_traits<span class="token operator">&lt;</span>I <span class="token operator">*</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">typedef</span> random_access_iterator_tag iterator_category<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">I</span><span class="token operator">></span><span class="token keyword">struct</span> Iterator_traits<span class="token operator">&lt;</span><span class="token keyword">const</span> I <span class="token operator">*</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">typedef</span> random_access_iterator_tag iterator_category<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>对外暴露接口：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 对外接口</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">InputIterator</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Distance</span><span class="token operator">></span><span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">advance</span><span class="token punctuation">(</span>InputIterator <span class="token operator">&amp;</span>i<span class="token punctuation">,</span> Distance n<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 通过Ierator_traits询问它的iterator_category是谁</span>    <span class="token keyword">typedef</span> <span class="token keyword">typename</span> Iterator_traits<span class="token operator">&lt;</span>InputIterator<span class="token operator">></span><span class="token operator">::</span>iterator_category category<span class="token punctuation">;</span>    <span class="token function">__advance</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> n<span class="token punctuation">,</span> <span class="token function">category</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 各型别的重载</span><span class="token punctuation">}</span></code></pre><p>定义class type：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// class type</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">Category</span><span class="token operator">></span><span class="token keyword">struct</span> iterator <span class="token punctuation">{</span>    <span class="token keyword">typedef</span> Category iterator_category<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>开始测试，我们使用上述定义的class type与原生指针来测试，分别进入萃取机的普通萃取机与偏特化萃取机，看看是否得到相应的Tag。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    iterator<span class="token operator">&lt;</span>input_iterator_tag<span class="token operator">></span> input<span class="token punctuation">;</span>    iterator<span class="token operator">&lt;</span>output_iterator_tag<span class="token operator">></span> output<span class="token punctuation">;</span>    iterator<span class="token operator">&lt;</span>forward_iterator_tag<span class="token operator">></span> forward<span class="token punctuation">;</span>    iterator<span class="token operator">&lt;</span>bidiectional_iterator_tag<span class="token operator">></span> bidect<span class="token punctuation">;</span>    iterator<span class="token operator">&lt;</span>random_access_iterator_tag<span class="token operator">></span> random<span class="token punctuation">;</span>    <span class="token function">advance</span><span class="token punctuation">(</span>input<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">advance</span><span class="token punctuation">(</span>output<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">advance</span><span class="token punctuation">(</span>forward<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">advance</span><span class="token punctuation">(</span>bidect<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">advance</span><span class="token punctuation">(</span>random<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token function">advance</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>输出结果：</p><pre class=" language-cpp"><code class="language-cpp">input tagoutput tagforward tagbidrectional tagrandomaccess tagrandomaccess tag</code></pre><p>一切如我们预期一样，通过萃取机，我们获得了每个迭代器的tag，以及原生指针的tag。</p><p>我们再想得复杂一些，如果我们想知道advance的返回类型，那如何做呢？</p><p>首先修改<code>advance</code>返回：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 对外接口</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">InputIterator</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Distance</span><span class="token operator">></span><span class="token keyword">inline</span> <span class="token keyword">typename</span> Iterator_traits<span class="token operator">&lt;</span>InputIterator<span class="token operator">></span><span class="token operator">::</span>iterator_category<span class="token function">advance</span><span class="token punctuation">(</span>InputIterator <span class="token operator">&amp;</span>i<span class="token punctuation">,</span> Distance n<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 通过Ierator_traits询问它的iterator_category是谁</span>    <span class="token keyword">typedef</span> <span class="token keyword">typename</span> Iterator_traits<span class="token operator">&lt;</span>InputIterator<span class="token operator">></span><span class="token operator">::</span>iterator_category category<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">__advance</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> n<span class="token punctuation">,</span> <span class="token function">category</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 各型别的重载</span><span class="token punctuation">}</span></code></pre><p>紧接着修改<code>__advance</code>返回：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// input iterator</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">inputIterator</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">distance</span><span class="token operator">></span><span class="token keyword">inline</span> <span class="token keyword">typename</span> Iterator_traits<span class="token operator">&lt;</span>inputIterator<span class="token operator">></span><span class="token operator">::</span>iterator_category<span class="token function">__advance</span><span class="token punctuation">(</span>inputIterator <span class="token operator">&amp;</span>i<span class="token punctuation">,</span> distance n<span class="token punctuation">,</span>          input_iterator_tag<span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"input tag"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">input_iterator_tag</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// output iterator</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">outputIterator</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">distance</span><span class="token operator">></span><span class="token keyword">inline</span> <span class="token keyword">typename</span> Iterator_traits<span class="token operator">&lt;</span>outputIterator<span class="token operator">></span><span class="token operator">::</span>iterator_category<span class="token function">__advance</span><span class="token punctuation">(</span>outputIterator <span class="token operator">&amp;</span>i<span class="token punctuation">,</span> distance n<span class="token punctuation">,</span>          output_iterator_tag<span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"output tag"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">output_iterator_tag</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// forward iterator</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">ForwardIterator</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Distance</span><span class="token operator">></span><span class="token keyword">inline</span> <span class="token keyword">typename</span> Iterator_traits<span class="token operator">&lt;</span>ForwardIterator<span class="token operator">></span><span class="token operator">::</span>iterator_category<span class="token function">__advance</span><span class="token punctuation">(</span>ForwardIterator <span class="token operator">&amp;</span>i<span class="token punctuation">,</span> Distance n<span class="token punctuation">,</span>          forward_iterator_tag<span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"forward tag"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">forward_iterator_tag</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// bidrectional iterator</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">BidiectionalIterator</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Distance</span><span class="token operator">></span><span class="token keyword">inline</span> <span class="token keyword">typename</span> Iterator_traits<span class="token operator">&lt;</span>BidiectionalIterator<span class="token operator">></span><span class="token operator">::</span>iterator_category<span class="token function">__advance</span><span class="token punctuation">(</span>BidiectionalIterator <span class="token operator">&amp;</span>i<span class="token punctuation">,</span> Distance n<span class="token punctuation">,</span>          bidiectional_iterator_tag<span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"bidrectional tag"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">bidiectional_iterator_tag</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// RandomAccess iterator</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">RandomAccessIterator</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Distance</span><span class="token operator">></span><span class="token keyword">inline</span> <span class="token keyword">typename</span> Iterator_traits<span class="token operator">&lt;</span>RandomAccessIterator<span class="token operator">></span><span class="token operator">::</span>iterator_category<span class="token function">__advance</span><span class="token punctuation">(</span>RandomAccessIterator <span class="token operator">&amp;</span>i<span class="token punctuation">,</span> Distance n<span class="token punctuation">,</span>          random_access_iterator_tag<span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"randomaccess tag"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">random_access_iterator_tag</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>只需要把<code>void</code>修改为相应的萃取机即可。</p><p>最后测试修改，添加上返回：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    iterator<span class="token operator">&lt;</span>input_iterator_tag<span class="token operator">></span> input<span class="token punctuation">;</span>    iterator<span class="token operator">&lt;</span>output_iterator_tag<span class="token operator">></span> output<span class="token punctuation">;</span>    iterator<span class="token operator">&lt;</span>forward_iterator_tag<span class="token operator">></span> forward<span class="token punctuation">;</span>    iterator<span class="token operator">&lt;</span>bidiectional_iterator_tag<span class="token operator">></span> bidect<span class="token punctuation">;</span>    iterator<span class="token operator">&lt;</span>random_access_iterator_tag<span class="token operator">></span> random<span class="token punctuation">;</span>    input_iterator_tag inputIteratorTag <span class="token operator">=</span> <span class="token function">advance</span><span class="token punctuation">(</span>input<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    output_iterator_tag outputIteratorTag <span class="token operator">=</span> <span class="token function">advance</span><span class="token punctuation">(</span>output<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    forward_iterator_tag forwardIteratorTag <span class="token operator">=</span> <span class="token function">advance</span><span class="token punctuation">(</span>forward<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    bidiectional_iterator_tag bidiectionalIteratorTag <span class="token operator">=</span> <span class="token function">advance</span><span class="token punctuation">(</span>bidect<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    random_access_iterator_tag randomAccessIteratorTag <span class="token operator">=</span> <span class="token function">advance</span><span class="token punctuation">(</span>random<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    random_access_iterator_tag v <span class="token operator">=</span> <span class="token function">advance</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>至此，一个简单的迭代器类型在编译器判别实现完毕。</p><h2 id="2-STL源码剖析Iterator"><a href="#2-STL源码剖析Iterator" class="headerlink" title="2.STL源码剖析Iterator"></a>2.STL源码剖析Iterator</h2><p>在<code>bits/stl_iterator_base_types.h</code>中也是如上述所示(实际上，上面就是STL源码的简单版，很接近)，来我们一起来看。</p><p>（1）<code>tag</code></p><pre class=" language-cpp"><code class="language-cpp"> <span class="token comment" spellcheck="true">///  Marking input iterators.</span>  <span class="token keyword">struct</span> input_iterator_tag <span class="token punctuation">{</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">///  Marking output iterators.</span>  <span class="token keyword">struct</span> output_iterator_tag <span class="token punctuation">{</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/// Forward iterators support a superset of input iterator operations.</span>  <span class="token keyword">struct</span> forward_iterator_tag <span class="token operator">:</span> <span class="token keyword">public</span> input_iterator_tag <span class="token punctuation">{</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/// Bidirectional iterators support a superset of forward iterator</span>  <span class="token comment" spellcheck="true">/// operations.</span>  <span class="token keyword">struct</span> bidirectional_iterator_tag <span class="token operator">:</span> <span class="token keyword">public</span> forward_iterator_tag <span class="token punctuation">{</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/// Random-access iterators support a superset of bidirectional</span>  <span class="token comment" spellcheck="true">/// iterator operations.</span>  <span class="token keyword">struct</span> random_access_iterator_tag <span class="token operator">:</span> <span class="token keyword">public</span> bidirectional_iterator_tag <span class="token punctuation">{</span> <span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>与我上面用的一样。</p><p>（2）<code>iterator_traits</code>萃取机，里面包含五种，而上面只是实现其中的一种：<code>iterator_category</code>。所以在STL中容器与算法之间的桥梁iterator必须包含下面五种 typedef。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _Iterator<span class="token operator">></span><span class="token keyword">struct</span> iterator_traits<span class="token punctuation">{</span>  <span class="token keyword">typedef</span> <span class="token keyword">typename</span> _Iterator<span class="token operator">::</span>iterator_category iterator_category<span class="token punctuation">;</span>  <span class="token keyword">typedef</span> <span class="token keyword">typename</span> _Iterator<span class="token operator">::</span>value_type        value_type<span class="token punctuation">;</span>  <span class="token keyword">typedef</span> <span class="token keyword">typename</span> _Iterator<span class="token operator">::</span>difference_type   difference_type<span class="token punctuation">;</span>  <span class="token keyword">typedef</span> <span class="token keyword">typename</span> _Iterator<span class="token operator">::</span>pointer           pointer<span class="token punctuation">;</span>  <span class="token keyword">typedef</span> <span class="token keyword">typename</span> _Iterator<span class="token operator">::</span>reference         reference<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>（3）<code>iterator</code></p><p>上面提到的class type为下面的简单版，对比一下，没有啥区别，就是模板参数多了一些，typedef多了。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _Category<span class="token punctuation">,</span> <span class="token keyword">typename</span> _Tp<span class="token punctuation">,</span> <span class="token keyword">typename</span> _Distance <span class="token operator">=</span> ptrdiff_t<span class="token punctuation">,</span>       <span class="token keyword">typename</span> _Pointer <span class="token operator">=</span> _Tp<span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> _Reference <span class="token operator">=</span> _Tp<span class="token operator">&amp;</span><span class="token operator">></span><span class="token keyword">struct</span> iterator<span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">/// One of the @link iterator_tags tag types@endlink.</span>  <span class="token keyword">typedef</span> _Category  iterator_category<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/// The type "pointed to" by the iterator.</span>  <span class="token keyword">typedef</span> _Tp        value_type<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/// Distance between iterators is represented as this type.</span>  <span class="token keyword">typedef</span> _Distance  difference_type<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/// This type represents a pointer-to-value_type.</span>  <span class="token keyword">typedef</span> _Pointer   pointer<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/// This type represents a reference-to-value_type.</span>  <span class="token keyword">typedef</span> _Reference reference<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>至此，iterator与traits特性分析完毕。欢迎与我共同探讨STL源码奥秘，如侯捷老师所说：<strong>源码面前了无秘密。</strong></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> STL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ STL 源码剖析之 Traits 编程技法</title>
      <link href="/2019/10/07/traits/"/>
      <url>/2019/10/07/traits/</url>
      
        <content type="html"><![CDATA[<h1 id="C-STL-源码剖析之-Traits-编程技法"><a href="#C-STL-源码剖析之-Traits-编程技法" class="headerlink" title="C++ STL 源码剖析之 Traits 编程技法"></a>C++ STL 源码剖析之 Traits 编程技法</h1><h2 id="0-导语"><a href="#0-导语" class="headerlink" title="0.导语"></a>0.导语</h2><p>在 STL 编程中，容器和算法是独立设计的，即数据结构和算法是独立设计的，连接容器和算法的桥梁就是迭代器了，迭代器使其独立设计成为可能。如下图所示：</p><p><img src="https://raw.githubusercontent.com/Light-City/cloudimg/master/rela.png" alt=""></p><p>上图给出了 STL 的目标就是要把数据和算法分开，分别对其进行设计，之后通过一种名为 iterator 的东西，把这二者再粘接到一起。</p><p>设计模式中，关于 iterator 的描述为：<strong>一种能够顺序访问容器中每个元素的方法，使用该方法不能暴露容器内部的表达方式。而类型萃取技术就是为了要解决和 iterator 有关的问题的。</strong></p><p>它将范型算法(find, count, find_if)用于某个容器中,最重要的是要给算法提供一个访问容器元素的工具，iterator 就扮演着这个重要的角色。</p><p>而在算法中我们可能会定义简单的中间变量或者设定算法的返回变量类型，这时候需要知道迭代器所指元素的类型是什么，但是由于没有 typeof 这类判断类型的函数,我们无法直接获取，那该如何是好？本文就来具体阐述。</p><p>对于迭代器来说就是一种智能指针，因此，它也就拥有了一般指针的所有特点——能够对其进行*和-&gt;操作。但是在遍历容器的时候，不可避免的要对遍历的容器内部有所了解，所以，干脆把迭代器的开发工作交给容器的设计者好了，如此以来，所有实现细节反而得以封装起来不被使用者看到，这正是为什么每一种 STL 容器都提供有专属迭代器的缘故。</p><p>而 Traits 在<code>bits/stl_iterator_base_types.h</code>中：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">_Tp</span><span class="token operator">></span><span class="token keyword">struct</span> iterator_traits<span class="token operator">&lt;</span>_Tp<span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">{</span>    <span class="token keyword">typedef</span> ptrdiff_t difference_type<span class="token punctuation">;</span>    <span class="token keyword">typedef</span> <span class="token keyword">typename</span> _Tp<span class="token operator">::</span>value_type value_type<span class="token punctuation">;</span>    <span class="token keyword">typedef</span> <span class="token keyword">typename</span> _Tp<span class="token operator">::</span>pointer pointer<span class="token punctuation">;</span>    <span class="token keyword">typedef</span> <span class="token keyword">typename</span> _Tp<span class="token operator">::</span>reference reference<span class="token punctuation">;</span>    <span class="token keyword">typedef</span> <span class="token keyword">typename</span> _Tp<span class="token operator">::</span>iterator_category iterator_category<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>看的一脸懵逼吧，没事，看完本节，入门 STL，哈哈~</p><h2 id="1-template-参数推导"><a href="#1-template-参数推导" class="headerlink" title="1.template 参数推导"></a>1.template 参数推导</h2><p>首先，在算法中运用迭代器时，很可能会用到<strong>其相应型别（associated type）</strong>（迭代器所指之物的型别）。假设算法中有必要声明一个变量，以”迭代器所指对象的型别”为型别，该<strong>怎么办呢？</strong></p><p><strong>解决方法是：利用 function template 的参数推导机制。</strong></p><p>例如：</p><p>如果 T 是某个指向特定对象的指针，那么在 func 中需要指针所指向对象的型别的时候，怎么办呢？这个还比较容易，模板的参数推导机制可以完成任务，</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">I</span><span class="token operator">></span><span class="token keyword">inline</span><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span>I iter<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">func_impl</span><span class="token punctuation">(</span>iter<span class="token punctuation">,</span> <span class="token operator">*</span>iter<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 传入iter和iter所指的值，class自动推导</span><span class="token punctuation">}</span></code></pre><p>通过模板的推导机制，我们轻而易举的或得了指针所指向的对象的类型。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">I</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">void</span> <span class="token function">func_impl</span><span class="token punctuation">(</span>I iter<span class="token punctuation">,</span> T t<span class="token punctuation">)</span> <span class="token punctuation">{</span>        T tmp<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 这里就是迭代器所指物的类别</span>        <span class="token comment" spellcheck="true">// ... 功能实现</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    <span class="token function">func</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>但是，<strong>函数的”template 参数推导机制”推导的只是参数，无法推导函数的返回值类型。万一需要推导函数的传回值，就无能为力了</strong>。因此，我们引出下面的方法。</p><h2 id="2-声明内嵌型别"><a href="#2-声明内嵌型别" class="headerlink" title="2.声明内嵌型别"></a>2.声明内嵌型别</h2><p><strong>迭代器所指对象的型别，称之为迭代器的 value type。</strong></p><p>尽管在 func_impl 中我们可以把 T 作为函数的返回值，但是问题是用户需要调用的是 func。</p><pre><code>template &lt;class I, class T&gt;T func_impl(I iter, T t) {        T tmp; // 这里就是迭代器所指物的类别        // ... 功能实现}template &lt;class T&gt;(*T) func(T t) { // !!!Wrong code    return func_impl(t, *t); // forward the task to func_impl}int main() {    int i  =10;    cout&lt;&lt;func(&amp;i)&lt;&lt;endl; // !!! Can’t pass compile}</code></pre><p>如果去编译上述代码，编译失败！</p><p>这个问题解决起来也不难，声明内嵌型别似乎是个好主意，这样我们就可以直接获取。只要做一个 iterator，然后在定义的时候为其指向的对象类型制定一个别名，就好了，像下面这样：</p><pre><code>template &lt;class T&gt;struct MyIter {    typedef T value_type; // 内嵌型别声明    T* ptr;    MyIter(T* p = 0) : ptr(p) {}    T&amp; operator*() const { return *ptr; }};template &lt;class I&gt;typename I::value_typefunc(I ite) {    std::cout &lt;&lt; "class version" &lt;&lt; std::endl;    return *ite;}int main() {    // ...    MyIter&lt;int&gt; ite(new int(8));    cout &lt;&lt; func(ite);    // 输出8}</code></pre><p>很漂亮的解决方案，看上去一切都很完美。但是，实际上还是有问题，因为 func 如果是一个泛型算法，那么它也绝对要接受一个原生指针作为迭代器，但是显然，你无法让下面的代码编译通过：</p><pre><code>int *p = new int(5);cout&lt;&lt;func(p)&lt;&lt;endl; // error</code></pre><p>我们的 func 无法支持原生指针，这显然是不能接受的。此时，template partial specialization 就派上了用场。</p><h2 id="3-救世主-Traits"><a href="#3-救世主-Traits" class="headerlink" title="3.救世主 Traits"></a>3.救世主 Traits</h2><p>前面也提到了，如果直接使用<code>typename I::value_type</code>，算法就无法接收原生指针，因为原生指针根本就没有 value_type 这个内嵌类型。</p><p>因此，我们还需要加入一个中间层对其进行判断，看它是不是原生指针，注意，这就是 traits 技法的妙处所在。</p><p>如果我们只使用上面的做法，也就是内嵌 value_type，那么对于没有 value_type 的指针，我们只能对其进行偏特化，这种偏特化是针对可调用函数 func 的偏特化，假如 func 有 100 万行行代码，那么就会造成极大的视觉污染。</p><p><strong>（1）函数偏特化</strong></p><p>函数偏特化：</p><pre><code>template &lt;class T&gt;struct MyIter {    typedef T value_type; // 内嵌型别声明    T* ptr;    MyIter(T* p = 0) : ptr(p) {}    T&amp; operator*() const { return *ptr; }};template &lt;class I&gt;typename I::value_typefunc(I ite) {    std::cout &lt;&lt; "class version" &lt;&lt; std::endl;    return *ite;}template &lt;class I&gt;Ifunc(I* ite) {    std::cout &lt;&lt; "pointer version" &lt;&lt; std::endl;    return *ite;}template &lt;class I&gt;I func(const I* ite) {    std::cout &lt;&lt; "const pointer version" &lt;&lt; std::endl;    return *ite;}int main() {    // ...    MyIter&lt;int&gt; ite(new int(8));    cout &lt;&lt; func(ite)&lt;&lt;endl;    int *p = new int(52);    cout&lt;&lt;func(p)&lt;&lt;endl;    const int k = 3;    cout&lt;&lt;func(&amp;k)&lt;&lt;endl;}</code></pre><p>输出：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">version</span><span class="token number">8</span>pointer version<span class="token number">52</span><span class="token keyword">const</span> pointer version<span class="token number">3</span></code></pre><p><strong>（2）加入中间层</strong></p><p>在 STL 中 Traits 是什么呢？看下图：</p><p><img src="https://raw.githubusercontent.com/Light-City/cloudimg/master/trai.png" alt=""></p><p>利用一个中间层<code>iterator_traits</code>固定了<code>func</code>的形式，使得重复的代码大量减少，唯一要做的就是稍稍特化一下 iterator_tartis 使其支持 pointer 和 const pointer:)</p><pre><code>#include &lt;iostream&gt;template &lt;class T&gt;struct MyIter {    typedef T value_type; // 内嵌型别声明    T* ptr;    MyIter(T* p = 0) : ptr(p) {}    T&amp; operator*() const { return *ptr; }};// class typetemplate &lt;class T&gt;struct iterator_traits {    typedef typename T::value_type value_type;};// 偏特化1template &lt;class T&gt;struct iterator_traits&lt;T*&gt; {    typedef T value_type;};// 偏特化2template &lt;class T&gt;struct iterator_traits&lt;const T*&gt; {    typedef T value_type;};template &lt;class I&gt;typename iterator_traits&lt;I&gt;::value_type// 首先询问iterator_traits&lt;I&gt;::value_type,如果传递的I为指针,则进入特化版本,iterator_traits直接回答;如果传递进来的I为class type,就去询问T::value_type.func(I ite) {    std::cout &lt;&lt; "normal version" &lt;&lt; std::endl;    return *ite;}int main() {    // ...    MyIter&lt;int&gt; ite(new int(8));    std::cout &lt;&lt; func(ite)&lt;&lt;std::endl;    int *p = new int(52);    std::cout&lt;&lt;func(p)&lt;&lt;std::endl;    const int k = 3;    std::cout&lt;&lt;func(&amp;k)&lt;&lt;std::endl;}</code></pre><p>上述的过程是首先询问<code>iterator_traits&lt;I&gt;::value_type</code>，如果传递的 I 为指针,则进入特化版本,<code>iterator_traits</code>直接回答<code>T</code>;如果传递进来的<code>I</code>为<code>class type</code>,就去询问<code>T::value_type</code>.</p><p>上述的通俗解释为算法(func)问 iterator_traits(我)，但是 iterator_traits(我)发现手上是指针的时候，就由我来替它回答。如果是 class type，iterator_traits(我)就继续问(他—T::value_type)。</p><p><strong>总结：通过定义内嵌类型，我们获得了知晓 iterator 所指元素类型的方法，通过 traits 技法，我们将函数模板对于原生指针和自定义 iterator 的定义都统一起来，我们使用 traits 技法主要是为了解决原生指针和自定义 iterator 之间的不同所造成的代码冗余，这就是 traits 技法的妙处所在。</strong></p><p>学习书籍：</p><blockquote><p>侯捷《 STL 源码剖析》</p></blockquote><p>学习文章：</p><blockquote><p><a href="https://juejin.im/post/5b1a43fb51882513bf1795c6" target="_blank" rel="noopener">https://juejin.im/post/5b1a43fb51882513bf1795c6</a></p></blockquote><blockquote><p><a href="https://www.cnblogs.com/mangoyuan/p/6446046.html" target="_blank" rel="noopener">https://www.cnblogs.com/mangoyuan/p/6446046.html</a></p></blockquote><blockquote><p><a href="http://www.cppblog.com/nacci/archive/2005/11/03/911.aspx" target="_blank" rel="noopener">http://www.cppblog.com/nacci/archive/2005/11/03/911.aspx</a></p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> STL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ STL源码剖析之双向环形链表list</title>
      <link href="/2019/10/06/list/"/>
      <url>/2019/10/06/list/</url>
      
        <content type="html"><![CDATA[<h1 id="C-STL源码剖析之双向环形链表list"><a href="#C-STL源码剖析之双向环形链表list" class="headerlink" title="C++ STL源码剖析之双向环形链表list"></a>C++ STL源码剖析之双向环形链表list</h1><h2 id="0-导语"><a href="#0-导语" class="headerlink" title="0. 导语"></a>0. 导语</h2><p>源码对应的版本为<strong>gcc-4.9.1</strong></p><h3 id="1-list"><a href="#1-list" class="headerlink" title="1.list"></a>1.list</h3><p>list为双向环形链表，其结构为：</p><p><img src="https://raw.githubusercontent.com/Light-City/cloudimg/master/list_1.png" alt=""></p><p>自己绘制的图如下：</p><p><img src="https://raw.githubusercontent.com/Light-City/cloudimg/master/list_a.png" alt="list_all"></p><p>双向环状链表从节点值为3开始插入，红色框表示最后一个节点(end()指向的节点)。黄色线条表示指向前驱节点，黑色线条表示指向后继节点。</p><h3 id="1-1-list源码"><a href="#1-1-list源码" class="headerlink" title="1.1 list源码"></a>1.1 list源码</h3><h4 id="1-1-1-类结构"><a href="#1-1-1-类结构" class="headerlink" title="1.1.1 类结构"></a>1.1.1 类结构</h4><pre class=" language-cpp"><code class="language-cpp"> <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _Tp<span class="token punctuation">,</span> <span class="token keyword">typename</span> _Alloc <span class="token operator">=</span> std<span class="token operator">::</span>allocator<span class="token operator">&lt;</span>_Tp<span class="token operator">></span> <span class="token operator">></span> <span class="token keyword">class</span> <span class="token class-name">list</span> <span class="token operator">:</span> <span class="token keyword">protected</span> _List_base<span class="token operator">&lt;</span>_Tp<span class="token punctuation">,</span> _Alloc<span class="token operator">></span>  <span class="token punctuation">{</span> <span class="token punctuation">}</span></code></pre><p><code>list</code>继承<code>_List_base</code>。</p><h4 id="1-1-2-双向环形链表实现"><a href="#1-1-2-双向环形链表实现" class="headerlink" title="1.1.2 双向环形链表实现"></a>1.1.2 双向环形链表实现</h4><p>【<strong>构造函数</strong>】</p><p><strong>（1）不带任何元素的list</strong></p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">explicit</span><span class="token function">list</span><span class="token punctuation">(</span><span class="token keyword">const</span> allocator_type <span class="token operator">&amp;</span>__a<span class="token punctuation">)</span> _GLIBCXX_NOEXCEPT<span class="token operator">:</span> <span class="token function">_Base</span><span class="token punctuation">(</span><span class="token function">_Node_alloc_type</span><span class="token punctuation">(</span>__a<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><p><strong>（2）带n个元素且赋予初值的list</strong></p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">explicit</span> <span class="token function">list</span><span class="token punctuation">(</span>size_type __n<span class="token punctuation">,</span> <span class="token keyword">const</span> value_type <span class="token operator">&amp;</span>__value <span class="token operator">=</span> <span class="token function">value_type</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token keyword">const</span> allocator_type <span class="token operator">&amp;</span>__a <span class="token operator">=</span> <span class="token function">allocator_type</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">_Base</span><span class="token punctuation">(</span><span class="token function">_Node_alloc_type</span><span class="token punctuation">(</span>__a<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">_M_fill_initialize</span><span class="token punctuation">(</span>__n<span class="token punctuation">,</span> __value<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre><p><strong>（3）从一个范围中进行初始化list</strong></p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _InputIterator<span class="token operator">></span><span class="token function">list</span><span class="token punctuation">(</span>_InputIterator __first<span class="token punctuation">,</span> _InputIterator __last<span class="token punctuation">,</span>     <span class="token keyword">const</span> allocator_type <span class="token operator">&amp;</span>__a <span class="token operator">=</span> <span class="token function">allocator_type</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token operator">:</span> <span class="token function">_Base</span><span class="token punctuation">(</span><span class="token function">_Node_alloc_type</span><span class="token punctuation">(</span>__a<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// Check whether it's an integral type.  If so, it's not an iterator.</span>    <span class="token keyword">typedef</span> <span class="token keyword">typename</span> std<span class="token operator">::</span>__is_integer<span class="token operator">&lt;</span>_InputIterator<span class="token operator">></span><span class="token operator">::</span>__type _Integral<span class="token punctuation">;</span>    <span class="token function">_M_initialize_dispatch</span><span class="token punctuation">(</span>__first<span class="token punctuation">,</span> __last<span class="token punctuation">,</span> <span class="token function">_Integral</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>【<strong>创建节点</strong>】</p><p>做的事情：创建一个新的节点并动态分配内存，返回节点。</p><pre class=" language-cpp"><code class="language-cpp">_Node <span class="token operator">*</span><span class="token function">_M_create_node</span><span class="token punctuation">(</span><span class="token keyword">const</span> value_type <span class="token operator">&amp;</span>__x<span class="token punctuation">)</span> <span class="token punctuation">{</span>    _Node <span class="token operator">*</span>__p <span class="token operator">=</span> <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">_M_get_node</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    __try    <span class="token punctuation">{</span>        <span class="token function">_M_get_Tp_allocator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">construct</span>                <span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">__addressof</span><span class="token punctuation">(</span>__p<span class="token operator">-</span><span class="token operator">></span>_M_data<span class="token punctuation">)</span><span class="token punctuation">,</span> __x<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">__catch</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">_M_put_node</span><span class="token punctuation">(</span>__p<span class="token punctuation">)</span><span class="token punctuation">;</span>        __throw_exception_again<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> __p<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>注意到里面有两个重要的函数<code>_M_get_node</code>与<code>_M_put_node</code>，我们来查看后发现这些方法来自基类，源码为：</p><pre class=" language-cpp"><code class="language-cpp">_List_node<span class="token operator">&lt;</span>_Tp<span class="token operator">></span> <span class="token operator">*</span> <span class="token function">_M_get_node</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> _M_impl<span class="token punctuation">.</span>_Node_alloc_type<span class="token operator">::</span><span class="token function">allocate</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">_M_put_node</span><span class="token punctuation">(</span>_List_node<span class="token operator">&lt;</span>_Tp<span class="token operator">></span> <span class="token operator">*</span>__p<span class="token punctuation">)</span>   _GLIBCXX_NOEXCEPT<span class="token punctuation">{</span> _M_impl<span class="token punctuation">.</span>_Node_alloc_type<span class="token operator">::</span><span class="token function">deallocate</span><span class="token punctuation">(</span>__p<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre><p>对应的就是创建节点动态分配内存，若创建过程中抛出异常，则释放内存。</p><p>【<strong>插入节点</strong>】</p><p>插入节点包括：</p><ul><li>尾部插入n个指定节点值的节点，对应的函数<code>_M_fill_initialize</code></li></ul><p>在list的构造函数中使用：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">explicit</span> <span class="token function">list</span><span class="token punctuation">(</span>size_type __n<span class="token punctuation">,</span> <span class="token keyword">const</span> value_type <span class="token operator">&amp;</span>__value <span class="token operator">=</span> <span class="token function">value_type</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token keyword">const</span> allocator_type <span class="token operator">&amp;</span>__a <span class="token operator">=</span> <span class="token function">allocator_type</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">_Base</span><span class="token punctuation">(</span><span class="token function">_Node_alloc_type</span><span class="token punctuation">(</span>__a<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">_M_fill_initialize</span><span class="token punctuation">(</span>__n<span class="token punctuation">,</span> __value<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre><ul><li>指定位置插入指定节点值的节点，对应的函数<code>_M_insert</code></li></ul><p>其中大家经常使用的<code>push_back</code>与<code>push_front</code>底层就是调用<code>_M_insert</code>函数。</p><p>两者函数区别是：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">_M_insert</span><span class="token punctuation">(</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> __x<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// push_back   尾部插入  </span><span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">_M_insert</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> __x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// push_front 头部插入</span></code></pre><ul><li><strong>双向环形链表插入函数</strong><code>_M_hook</code>   <strong>(最重要！！！)</strong></li></ul><p>像前面提到的<code>push_back</code>、<code>push_front</code>、<code>_M_insert</code>，还有<code>insert</code>都是使用最基础的双向链表插入函数<code>_M_hook</code>实现的。</p><p><strong>下面来深入研究一下：</strong></p><p>其中<code>_M_fill_initialize</code>源码如下：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">_M_fill_initialize</span><span class="token punctuation">(</span>size_type __n<span class="token punctuation">,</span> <span class="token keyword">const</span> value_type <span class="token operator">&amp;</span>__x<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> __n<span class="token punctuation">;</span> <span class="token operator">--</span>__n<span class="token punctuation">)</span>        <span class="token function">push_back</span><span class="token punctuation">(</span>__x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>其中<code>push_back</code>源码如下：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">push_back</span><span class="token punctuation">(</span><span class="token keyword">const</span> value_type <span class="token operator">&amp;</span>__x<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">_M_insert</span><span class="token punctuation">(</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> __x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre><p>其中<code>_M_insert</code>，在指定的位置插入初始值为x的节点。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">_M_insert</span><span class="token punctuation">(</span>iterator __position<span class="token punctuation">,</span> <span class="token keyword">const</span> value_type <span class="token operator">&amp;</span>__x<span class="token punctuation">)</span> <span class="token punctuation">{</span>    _Node <span class="token operator">*</span>__tmp <span class="token operator">=</span> <span class="token function">_M_create_node</span><span class="token punctuation">(</span>__x<span class="token punctuation">)</span><span class="token punctuation">;</span>    __tmp<span class="token operator">-</span><span class="token operator">></span><span class="token function">_M_hook</span><span class="token punctuation">(</span>__position<span class="token punctuation">.</span>_M_node<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>其中<code>_M_hook</code>实现在<code>gcc-4.9.1/libstdc++-v3/src/c++98/list.cc</code>中,当然<code>_List_node_base</code>的其他函数，例如：<code>_M_unhook</code>也在这个文件中。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 在指定的位置前插入this指向的节点</span>void_List_node_base<span class="token operator">::</span><span class="token function">_M_hook</span><span class="token punctuation">(</span>_List_node_base<span class="token operator">*</span> <span class="token keyword">const</span> __position<span class="token punctuation">)</span> _GLIBCXX_USE_NOEXCEPT<span class="token punctuation">{</span>  <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_next <span class="token operator">=</span> __position<span class="token punctuation">;</span>          <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_prev <span class="token operator">=</span> __position<span class="token operator">-</span><span class="token operator">></span>_M_prev<span class="token punctuation">;</span>  __position<span class="token operator">-</span><span class="token operator">></span>_M_prev<span class="token operator">-</span><span class="token operator">></span>_M_next <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>  __position<span class="token operator">-</span><span class="token operator">></span>_M_prev <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>所以上述细分为两个函数：我们把上述代码进行总结：</p><p>（1）在指定的位置插入初始值为x的节点</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">_M_insert</span><span class="token punctuation">(</span>iterator __position<span class="token punctuation">,</span> <span class="token keyword">const</span> value_type <span class="token operator">&amp;</span>__x<span class="token punctuation">)</span> <span class="token punctuation">{</span>    _Node <span class="token operator">*</span>__tmp <span class="token operator">=</span> <span class="token function">_M_create_node</span><span class="token punctuation">(</span>__x<span class="token punctuation">)</span><span class="token punctuation">;</span>    __tmp<span class="token operator">-</span><span class="token operator">></span>_M_next <span class="token operator">=</span> __position<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 第一步</span>    __tmp<span class="token operator">-</span><span class="token operator">></span>_M_prev <span class="token operator">=</span> __position<span class="token operator">-</span><span class="token operator">></span>_M_prev<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 第二步</span>    __position<span class="token operator">-</span><span class="token operator">></span>_M_prev<span class="token operator">-</span><span class="token operator">></span>_M_next <span class="token operator">=</span> __tmp<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 第三步</span>    __position<span class="token operator">-</span><span class="token operator">></span>_M_prev <span class="token operator">=</span> __tmp<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 第四步</span><span class="token punctuation">}</span></code></pre><p>这种插入是在指定位置前插入，(对应到代码就是)例如实现在指定<code>__position</code>节点为7前插入节点值9的节点(对应到代码就是__tmp)，下面阐述了具体的插入流程。</p><p><img src="https://raw.githubusercontent.com/Light-City/cloudimg/master/list_insert.png" alt="list_insert"></p><p>（2）在末尾依次插入n个节点值为x的节点</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">_M_fill_initialize</span><span class="token punctuation">(</span>size_type __n<span class="token punctuation">,</span> <span class="token keyword">const</span> value_type <span class="token operator">&amp;</span>__x<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> __n<span class="token punctuation">;</span> <span class="token operator">--</span>__n<span class="token punctuation">)</span>        <span class="token function">_M_insert</span><span class="token punctuation">(</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> __x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>对于上述的代码大家或许会联想到<code>insert</code>,它有三个。<code>insert</code>实现文件在<code>libstdc++-v3/include/bits/list.tcc</code>。</p><ul><li><strong>第一：在指定迭代器之前插入指定元素值节点。</strong></li></ul><p>实现是调用前面的<code>_M_hook</code>函数。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _Tp<span class="token punctuation">,</span> <span class="token keyword">typename</span> _Alloc<span class="token operator">></span><span class="token keyword">typename</span> list<span class="token operator">&lt;</span>_Tp<span class="token punctuation">,</span> _Alloc<span class="token operator">></span><span class="token operator">::</span>iteratorlist<span class="token operator">&lt;</span>_Tp<span class="token punctuation">,</span> _Alloc<span class="token operator">></span><span class="token operator">::</span><span class="token macro property">#<span class="token directive keyword">if</span> __cplusplus >= 201103L</span><span class="token function">insert</span><span class="token punctuation">(</span>const_iterator __position<span class="token punctuation">,</span> <span class="token keyword">const</span> value_type<span class="token operator">&amp;</span> __x<span class="token punctuation">)</span><span class="token macro property">#<span class="token directive keyword">else</span></span><span class="token function">insert</span><span class="token punctuation">(</span>iterator __position<span class="token punctuation">,</span> <span class="token keyword">const</span> value_type<span class="token operator">&amp;</span> __x<span class="token punctuation">)</span><span class="token macro property">#<span class="token directive keyword">endif</span></span><span class="token punctuation">{</span>  _Node<span class="token operator">*</span> __tmp <span class="token operator">=</span> <span class="token function">_M_create_node</span><span class="token punctuation">(</span>__x<span class="token punctuation">)</span><span class="token punctuation">;</span>  __tmp<span class="token operator">-</span><span class="token operator">></span><span class="token function">_M_hook</span><span class="token punctuation">(</span>__position<span class="token punctuation">.</span><span class="token function">_M_const_cast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>_M_node<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token function">iterator</span><span class="token punctuation">(</span>__tmp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><ul><li><strong>第二：在指定迭代器之前插入n个指定节点值的节点。</strong></li></ul><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">insert</span><span class="token punctuation">(</span>iterator __position<span class="token punctuation">,</span> size_type __n<span class="token punctuation">,</span> <span class="token keyword">const</span> value_type <span class="token operator">&amp;</span>__x<span class="token punctuation">)</span> <span class="token punctuation">{</span>    list <span class="token function">__tmp</span><span class="token punctuation">(</span>__n<span class="token punctuation">,</span> __x<span class="token punctuation">,</span> <span class="token function">get_allocator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">splice</span><span class="token punctuation">(</span>__position<span class="token punctuation">,</span> __tmp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>实现是先调用list构造函数，完成创建一个拥有n个指定节点值的list。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">explicit</span> <span class="token function">list</span><span class="token punctuation">(</span>size_type __n<span class="token punctuation">,</span> <span class="token keyword">const</span> value_type <span class="token operator">&amp;</span>__value <span class="token operator">=</span> <span class="token function">value_type</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token keyword">const</span> allocator_type <span class="token operator">&amp;</span>__a <span class="token operator">=</span> <span class="token function">allocator_type</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">_Base</span><span class="token punctuation">(</span><span class="token function">_Node_alloc_type</span><span class="token punctuation">(</span>__a<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">_M_fill_initialize</span><span class="token punctuation">(</span>__n<span class="token punctuation">,</span> __value<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre><p>然后使用<code>splice</code>函数完成从另一个list中来插入当前list。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">splice</span><span class="token punctuation">(</span>iterator __position<span class="token punctuation">,</span> list <span class="token operator">&amp;</span>__x<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>__x<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">_M_check_equal_allocators</span><span class="token punctuation">(</span>__x<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">_M_transfer</span><span class="token punctuation">(</span>__position<span class="token punctuation">.</span><span class="token function">_M_const_cast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                          __x<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> __x<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>其中<code>_M_transfer</code>追踪代码，可以知道：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// Moves the elements from [first,last) before position.</span><span class="token keyword">void</span><span class="token function">_M_transfer</span><span class="token punctuation">(</span>iterator __position<span class="token punctuation">,</span> iterator __first<span class="token punctuation">,</span> iterator __last<span class="token punctuation">)</span> <span class="token punctuation">{</span>    __position<span class="token punctuation">.</span>_M_node<span class="token operator">-</span><span class="token operator">></span><span class="token function">_M_transfer</span><span class="token punctuation">(</span>__first<span class="token punctuation">.</span>_M_node<span class="token punctuation">,</span> __last<span class="token punctuation">.</span>_M_node<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>再次分析得到其来自list的基类<code>_List_node_base</code>，而<code>_M_transfer</code>实现文件在<code>gcc-4.9.1/libstdc++-v3/src/c++98/list.cc</code>中：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">void</span> _List_node_base<span class="token operator">::</span><span class="token function">_M_transfer</span><span class="token punctuation">(</span>_List_node_base <span class="token operator">*</span> <span class="token keyword">const</span> __first<span class="token punctuation">,</span>    _List_node_base <span class="token operator">*</span> <span class="token keyword">const</span> __last<span class="token punctuation">)</span> _GLIBCXX_USE_NOEXCEPT<span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">!=</span> __last<span class="token punctuation">)</span>  <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// Remove [first, last) from its old position.</span>      __last<span class="token operator">-</span><span class="token operator">></span>_M_prev<span class="token operator">-</span><span class="token operator">></span>_M_next  <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>      __first<span class="token operator">-</span><span class="token operator">></span>_M_prev<span class="token operator">-</span><span class="token operator">></span>_M_next <span class="token operator">=</span> __last<span class="token punctuation">;</span>      <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_prev<span class="token operator">-</span><span class="token operator">></span>_M_next    <span class="token operator">=</span> __first<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// Splice [first, last) into its new position.</span>      _List_node_base<span class="token operator">*</span> <span class="token keyword">const</span> __tmp <span class="token operator">=</span> <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_prev<span class="token punctuation">;</span>      <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_prev                <span class="token operator">=</span> __last<span class="token operator">-</span><span class="token operator">></span>_M_prev<span class="token punctuation">;</span>      __last<span class="token operator">-</span><span class="token operator">></span>_M_prev              <span class="token operator">=</span> __first<span class="token operator">-</span><span class="token operator">></span>_M_prev<span class="token punctuation">;</span>      __first<span class="token operator">-</span><span class="token operator">></span>_M_prev             <span class="token operator">=</span> __tmp<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>仍然是上述的图：</p><p><img src="https://raw.githubusercontent.com/Light-City/cloudimg/master/list_a.png" alt="list_all"></p><p>经过前面分析，我们知道<code>splice</code>是将上述图的所代表的整个list插入指定迭代器前面，例如，我们想要在下面两个节点前面插入，具体图形步骤如下：</p><p><code>this</code>代表的节点为值为8的节点，下图描述的就是在节点10与节点8中间插入整个list。</p><p><code>__last</code>代表的是红色框节点，该节点为<code>end()</code>指向的节点，我们是不需要该节点的，所以在后面处理中，会把该节点从整个list中去除掉。</p><p><code>__first</code>代表的是图中节点值为3的节点。</p><p><strong>第一步：先将最后一个有效节点，也就是红色框的前一个节点的next指针指向指定的节点8。</strong></p><p><img src="https://raw.githubusercontent.com/Light-City/cloudimg/master/step1.png" alt=""></p><p>对应代码为：</p><pre><code>__last-&gt;_M_prev-&gt;_M_next  = this;    </code></pre><p><strong>第二步：<code>_last</code>的next指针指向自己。</strong></p><p><img src="https://raw.githubusercontent.com/Light-City/cloudimg/master/step2.png" alt=""></p><p>对应的代码为：</p><pre><code>__first-&gt;_M_prev-&gt;_M_next = __last;</code></pre><p><strong>第三步：让指定迭代器之前的节点的nex指向原先list的第一个节点(<code>__first</code>)。</strong></p><p><img src="https://raw.githubusercontent.com/Light-City/cloudimg/master/step3.png" alt=""></p><p>对应的代码为：</p><pre><code>this-&gt;_M_prev-&gt;_M_next    = __first;</code></pre><p><strong>第四步：保存指定迭代器的前驱节点(对应到哪图中的节点值为10的节点)。</strong></p><pre><code>_List_node_base* const __tmp = this-&gt;_M_prev;</code></pre><p><strong>第五步：指定迭代器的前驱节点指向原list中实际最后一个节点(end()前一节点)。</strong></p><p><img src="https://raw.githubusercontent.com/Light-City/cloudimg/master/step5.png" alt=""></p><p>对应的代码为：</p><pre><code>this-&gt;_M_prev                = __last-&gt;_M_prev;</code></pre><p><strong>第六步：让原list的最后一个节点(end()指向的节点)的prev指向自己。</strong></p><p><img src="https://raw.githubusercontent.com/Light-City/cloudimg/master/step6.png" alt=""></p><p>对应的代码为：</p><pre><code>__last-&gt;_M_prev              = __first-&gt;_M_prev;</code></pre><p><strong>第七步：让原list第一个节点的prev指向第四步保存的节点。</strong></p><p><img src="https://raw.githubusercontent.com/Light-City/cloudimg/master/step7.png" alt=""></p><p>对应的代码为：</p><pre><code>__first-&gt;_M_prev             = __tmp;</code></pre><p>这样经过以上七步操作，完成了在节点8与节点10之前插入一个list。</p><ul><li><strong>第三：从一个list范围把数据插入到指定迭代器前面。</strong></li></ul><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _InputIterator<span class="token operator">></span><span class="token keyword">void</span><span class="token function">insert</span><span class="token punctuation">(</span>iterator __position<span class="token punctuation">,</span> _InputIterator __first<span class="token punctuation">,</span>       _InputIterator __last<span class="token punctuation">)</span> <span class="token punctuation">{</span>    list <span class="token function">__tmp</span><span class="token punctuation">(</span>__first<span class="token punctuation">,</span> __last<span class="token punctuation">,</span> <span class="token function">get_allocator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">splice</span><span class="token punctuation">(</span>__position<span class="token punctuation">,</span> __tmp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>原理同上，只不过这个<code>__tmp</code>是调用另外一个构造函数。</p><p>【<strong>删除节点</strong>】</p><ul><li>删除指定节点</li></ul><p>删除指定节点分为两个，第一个通过迭代器删除，第二个是通过元素值删除。</p><p><strong>（1）通过迭代器删除，对应函数为erase</strong></p><p>其中<code>pop_front</code>与<code>pop_back</code>、<code>erase</code>、<code>remove</code>底层实现基于<code>_M_erase</code>函数。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">_M_erase</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// pop_front 不断删除起点的元素</span><span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">_M_erase</span><span class="token punctuation">(</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_node<span class="token punctuation">.</span>_M_prev<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// pop_back移除最后一个元素</span></code></pre><p>在<code>libstdc++-v3/include/bits/list.tcc</code>中：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token function">erase</span><span class="token punctuation">(</span>iterator __position<span class="token punctuation">)</span><span class="token macro property">#<span class="token directive keyword">endif</span></span><span class="token punctuation">{</span>  iterator __ret <span class="token operator">=</span> <span class="token function">iterator</span><span class="token punctuation">(</span>__position<span class="token punctuation">.</span>_M_node<span class="token operator">-</span><span class="token operator">></span>_M_next<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">_M_erase</span><span class="token punctuation">(</span>__position<span class="token punctuation">.</span><span class="token function">_M_const_cast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> __ret<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><strong>（2）通过元素值删除，对应函数为remove</strong></p><p>特殊情况处理，当删除元素的地址与迭代器的地址一样的时候，先保存起来，最后判断保存的迭代器是不是end()，如果不是，就删除掉。底层仍旧是通过<code>_M_erase</code>删除。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _Tp<span class="token punctuation">,</span> <span class="token keyword">typename</span> _Alloc<span class="token operator">></span><span class="token keyword">void</span> list<span class="token operator">&lt;</span>_Tp<span class="token punctuation">,</span> _Alloc<span class="token operator">></span><span class="token operator">::</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token keyword">const</span> value_type<span class="token operator">&amp;</span> __value<span class="token punctuation">)</span><span class="token punctuation">{</span>  iterator __first <span class="token operator">=</span> <span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  iterator __last <span class="token operator">=</span> <span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  iterator __extra <span class="token operator">=</span> __last<span class="token punctuation">;</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span>__first <span class="token operator">!=</span> __last<span class="token punctuation">)</span>  <span class="token punctuation">{</span>      iterator __next <span class="token operator">=</span> __first<span class="token punctuation">;</span>      <span class="token operator">++</span>__next<span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>__first <span class="token operator">==</span> __value<span class="token punctuation">)</span>        <span class="token punctuation">{</span>          <span class="token comment" spellcheck="true">// _GLIBCXX_RESOLVE_LIB_DEFECTS</span>          <span class="token comment" spellcheck="true">// 526. Is it undefined if a function in the standard changes</span>          <span class="token comment" spellcheck="true">// in parameters?</span>          <span class="token keyword">if</span> <span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">__addressof</span><span class="token punctuation">(</span><span class="token operator">*</span>__first<span class="token punctuation">)</span> <span class="token operator">!=</span> std<span class="token operator">::</span><span class="token function">__addressof</span><span class="token punctuation">(</span>__value<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token function">_M_erase</span><span class="token punctuation">(</span>__first<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">else</span>        __extra <span class="token operator">=</span> __first<span class="token punctuation">;</span>        <span class="token punctuation">}</span>      __first <span class="token operator">=</span> __next<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>__extra <span class="token operator">!=</span> __last<span class="token punctuation">)</span>    <span class="token function">_M_erase</span><span class="token punctuation">(</span>__extra<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>除了这个remove外，还有一个是<code>remove_if</code>，根据条件来删除。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _Tp<span class="token punctuation">,</span> <span class="token keyword">typename</span> _Alloc<span class="token operator">></span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> _Predicate<span class="token operator">></span><span class="token keyword">void</span> list<span class="token operator">&lt;</span>_Tp<span class="token punctuation">,</span> _Alloc<span class="token operator">></span><span class="token operator">::</span><span class="token function">remove_if</span><span class="token punctuation">(</span>_Predicate __pred<span class="token punctuation">)</span><span class="token punctuation">{</span>    iterator __first <span class="token operator">=</span> <span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    iterator __last <span class="token operator">=</span> <span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>__first <span class="token operator">!=</span> __last<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        iterator __next <span class="token operator">=</span> __first<span class="token punctuation">;</span>        <span class="token operator">++</span>__next<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">__pred</span><span class="token punctuation">(</span><span class="token operator">*</span>__first<span class="token punctuation">)</span><span class="token punctuation">)</span>          <span class="token function">_M_erase</span><span class="token punctuation">(</span>__first<span class="token punctuation">)</span><span class="token punctuation">;</span>        __first <span class="token operator">=</span> __next<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>对上述的<code>remove</code>的if去掉，在里面添加一个判断即可。</p><p>使用如下</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token function">isone</span><span class="token punctuation">(</span><span class="token keyword">int</span> one<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> one<span class="token operator">==</span><span class="token number">2</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> t<span class="token punctuation">;</span>    t<span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    t<span class="token punctuation">.</span><span class="token function">remove_if</span><span class="token punctuation">(</span>isone<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><ul><li>删除一系列节点</li><li>删除所有节点，对应的函数<code>clear</code></li></ul><p><strong>（1）删除指定节点详细分析</strong></p><pre class=" language-cpp"><code class="language-cpp"><span class="token function">_M_erase</span><span class="token punctuation">(</span>iterator __position<span class="token punctuation">)</span>_GLIBCXX_NOEXCEPT<span class="token punctuation">{</span>    __position<span class="token punctuation">.</span>_M_node<span class="token operator">-</span><span class="token operator">></span><span class="token function">_M_unhook</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    _Node <span class="token operator">*</span>__n <span class="token operator">=</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span>_Node <span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">(</span>__position<span class="token punctuation">.</span>_M_node<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">if</span> __cplusplus >= 201103L</span>    <span class="token function">_M_get_Node_allocator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">destroy</span><span class="token punctuation">(</span>__n<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">else</span></span>    <span class="token function">_M_get_Tp_allocator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">destroy</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">__addressof</span><span class="token punctuation">(</span>__n<span class="token operator">-</span><span class="token operator">></span>_M_data<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">endif</span></span>    <span class="token function">_M_put_node</span><span class="token punctuation">(</span>__n<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 释放内存</span><span class="token punctuation">}</span></code></pre><p>其中<code>_M_unhook</code>实现在<code>gcc-4.9.1/libstdc++-v3/src/c++98/list.cc</code>，实现如下：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">void</span> _List_node_base<span class="token operator">::</span><span class="token function">_M_unhook</span><span class="token punctuation">(</span><span class="token punctuation">)</span> _GLIBCXX_USE_NOEXCEPT<span class="token punctuation">{</span>  _List_node_base<span class="token operator">*</span> <span class="token keyword">const</span> __next_node <span class="token operator">=</span> <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_next<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 第一步：保存后继节点</span>  _List_node_base<span class="token operator">*</span> <span class="token keyword">const</span> __prev_node <span class="token operator">=</span> <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_prev<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 第二步：保存前驱节点</span>  __prev_node<span class="token operator">-</span><span class="token operator">></span>_M_next <span class="token operator">=</span> __next_node<span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// 第三步：前驱节点的next指向后继节点</span>  __next_node<span class="token operator">-</span><span class="token operator">></span>_M_prev <span class="token operator">=</span> __prev_node<span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// 第四步：后继节点的prev指向前驱节点</span><span class="token punctuation">}</span></code></pre><p>例如：删除节点值为9的节点，第三与第四步图解：</p><p><img src="https://raw.githubusercontent.com/Light-City/cloudimg/master/list_erase.png" alt="list_erase"></p><p><strong>（2）删除一系列元素详细分析</strong></p><pre class=" language-cpp"><code class="language-cpp">iterator<span class="token macro property">#<span class="token directive keyword">if</span> __cplusplus >= 201103L</span><span class="token function">erase</span><span class="token punctuation">(</span>const_iterator __first<span class="token punctuation">,</span> const_iterator __last<span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token macro property">#<span class="token directive keyword">else</span></span><span class="token function">erase</span><span class="token punctuation">(</span>iterator __first<span class="token punctuation">,</span> iterator __last<span class="token punctuation">)</span><span class="token macro property">#<span class="token directive keyword">endif</span></span><span class="token punctuation">{</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>__first <span class="token operator">!=</span> __last<span class="token punctuation">)</span>        __first <span class="token operator">=</span> <span class="token function">erase</span><span class="token punctuation">(</span>__first<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> __last<span class="token punctuation">.</span><span class="token function">_M_const_cast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>使用erase，删除给定迭代器范围内的数据。</p><p><strong>（3）删除所有元素详细分析</strong></p><p>清空元素，并初始化，回到list默认状态。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span>_GLIBCXX_NOEXCEPT<span class="token punctuation">{</span>    _Base<span class="token operator">::</span><span class="token function">_M_clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    _Base<span class="token operator">::</span><span class="token function">_M_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>其中<code>_M_clear</code>实现在：<code>libstdc++-v3/include/bits/list.tcc</code>中：</p><pre class=" language-cpp"><code class="language-cpp">_List_base<span class="token operator">&lt;</span>_Tp<span class="token punctuation">,</span> _Alloc<span class="token operator">></span><span class="token operator">::</span><span class="token function">_M_clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span> _GLIBCXX_NOEXCEPT<span class="token punctuation">{</span>  <span class="token keyword">typedef</span> _List_node<span class="token operator">&lt;</span>_Tp<span class="token operator">></span>  _Node<span class="token punctuation">;</span>  _Node<span class="token operator">*</span> __cur <span class="token operator">=</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span>_Node<span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">(</span>_M_impl<span class="token punctuation">.</span>_M_node<span class="token punctuation">.</span>_M_next<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span>__cur <span class="token operator">!=</span> <span class="token operator">&amp;</span>_M_impl<span class="token punctuation">.</span>_M_node<span class="token punctuation">)</span>    <span class="token punctuation">{</span>      _Node<span class="token operator">*</span> __tmp <span class="token operator">=</span> __cur<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 保存节点</span>      __cur <span class="token operator">=</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span>_Node<span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">(</span>__cur<span class="token operator">-</span><span class="token operator">></span>_M_next<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 往后遍历</span>    <span class="token macro property">#<span class="token directive keyword">if</span> __cplusplus >= 201103L</span>      <span class="token function">_M_get_Node_allocator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">destroy</span><span class="token punctuation">(</span>__tmp<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token macro property">#<span class="token directive keyword">else</span></span>      <span class="token function">_M_get_Tp_allocator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">destroy</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">__addressof</span><span class="token punctuation">(</span>__tmp<span class="token operator">-</span><span class="token operator">></span>_M_data<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token macro property">#<span class="token directive keyword">endif</span></span>      <span class="token function">_M_put_node</span><span class="token punctuation">(</span>__tmp<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 释放内存</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><code>_M_init</code>实现，全部指向自己即可。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">_M_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span>_GLIBCXX_NOEXCEPT<span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_node<span class="token punctuation">.</span>_M_next <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_node<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_node<span class="token punctuation">.</span>_M_prev <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_node<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>【<strong>元素访问</strong>】</p><p>每个都实现了两个版本：引用与常引用。</p><ul><li>front 返回第一个元素</li></ul><pre class=" language-cpp"><code class="language-cpp">reference <span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span>_GLIBCXX_NOEXCEPT<span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token operator">*</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>const_reference<span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>_GLIBCXX_NOEXCEPT<span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token operator">*</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre><ul><li>返回最后一个元素</li></ul><pre class=" language-cpp"><code class="language-cpp">reference<span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span>_GLIBCXX_NOEXCEPT<span class="token punctuation">{</span>    iterator __tmp <span class="token operator">=</span> <span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">--</span>__tmp<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token operator">*</span>__tmp<span class="token punctuation">;</span><span class="token punctuation">}</span>const_reference<span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>_GLIBCXX_NOEXCEPT<span class="token punctuation">{</span>    const_iterator __tmp <span class="token operator">=</span> <span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">--</span>__tmp<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token operator">*</span>__tmp<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>【<strong>算法</strong>】</p><ul><li>unique</li></ul><p>从容器中的每个连续的相等元素组中除去除第一个元素外的所有元素。</p><p>请注意，只有与<a href="http://www.cplusplus.com/list" target="_blank" rel="noopener">列表</a>容器紧邻的元素相比，该元素才从<a href="http://www.cplusplus.com/list" target="_blank" rel="noopener">列表</a>容器中删除。因此，此功能对于排序列表特别有用。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _Tp<span class="token punctuation">,</span> <span class="token keyword">typename</span> _Alloc<span class="token operator">></span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> _BinaryPredicate<span class="token operator">></span>  <span class="token keyword">void</span>  list<span class="token operator">&lt;</span>_Tp<span class="token punctuation">,</span> _Alloc<span class="token operator">></span><span class="token operator">::</span>  <span class="token function">unique</span><span class="token punctuation">(</span>_BinaryPredicate __binary_pred<span class="token punctuation">)</span>  <span class="token punctuation">{</span>    iterator __first <span class="token operator">=</span> <span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    iterator __last <span class="token operator">=</span> <span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>__first <span class="token operator">==</span> __last<span class="token punctuation">)</span>  <span class="token keyword">return</span><span class="token punctuation">;</span>    iterator __next <span class="token operator">=</span> __first<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">++</span>__next <span class="token operator">!=</span> __last<span class="token punctuation">)</span>  <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 满足条件就删除</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">__binary_pred</span><span class="token punctuation">(</span><span class="token operator">*</span>__first<span class="token punctuation">,</span> <span class="token operator">*</span>__next<span class="token punctuation">)</span><span class="token punctuation">)</span>       <span class="token comment" spellcheck="true">// 删除</span>      <span class="token function">_M_erase</span><span class="token punctuation">(</span>__next<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>      __first <span class="token operator">=</span> __next<span class="token punctuation">;</span>    __next <span class="token operator">=</span> __first<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token punctuation">}</span></code></pre><p>举例如下：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// list::unique</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;cmath></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;list></span></span><span class="token comment" spellcheck="true">// a binary predicate implemented as a function:</span><span class="token keyword">bool</span> <span class="token function">same_integral_part</span> <span class="token punctuation">(</span><span class="token keyword">double</span> first<span class="token punctuation">,</span> <span class="token keyword">double</span> second<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token punctuation">(</span> <span class="token keyword">int</span><span class="token punctuation">(</span>first<span class="token punctuation">)</span><span class="token operator">==</span><span class="token keyword">int</span><span class="token punctuation">(</span>second<span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token comment" spellcheck="true">// a binary predicate implemented as a class:</span><span class="token keyword">struct</span> is_near <span class="token punctuation">{</span>  <span class="token keyword">bool</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">double</span> first<span class="token punctuation">,</span> <span class="token keyword">double</span> second<span class="token punctuation">)</span>  <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token function">fabs</span><span class="token punctuation">(</span>first<span class="token operator">-</span>second<span class="token punctuation">)</span><span class="token operator">&lt;</span><span class="token number">5.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">double</span> mydoubles<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">{</span> <span class="token number">12.15</span><span class="token punctuation">,</span>  <span class="token number">2.72</span><span class="token punctuation">,</span> <span class="token number">73.0</span><span class="token punctuation">,</span>  <span class="token number">12.77</span><span class="token punctuation">,</span>  <span class="token number">3.14</span><span class="token punctuation">,</span>                       <span class="token number">12.77</span><span class="token punctuation">,</span> <span class="token number">73.35</span><span class="token punctuation">,</span> <span class="token number">72.25</span><span class="token punctuation">,</span> <span class="token number">15.3</span><span class="token punctuation">,</span>  <span class="token number">72.25</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>  std<span class="token operator">::</span>list<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">></span> <span class="token function">mylist</span> <span class="token punctuation">(</span>mydoubles<span class="token punctuation">,</span>mydoubles<span class="token operator">+</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  mylist<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">//  2.72,  3.14, 12.15, 12.77, 12.77,</span>                             <span class="token comment" spellcheck="true">// 15.3,  72.25, 72.25, 73.0,  73.35</span>  mylist<span class="token punctuation">.</span><span class="token function">unique</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">//  2.72,  3.14, 12.15, 12.77</span>                             <span class="token comment" spellcheck="true">// 15.3,  72.25, 73.0,  73.35</span>  mylist<span class="token punctuation">.</span><span class="token function">unique</span> <span class="token punctuation">(</span>same_integral_part<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//  2.72,  3.14, 12.15</span>                                       <span class="token comment" spellcheck="true">// 15.3,  72.25, 73.0</span>  mylist<span class="token punctuation">.</span><span class="token function">unique</span> <span class="token punctuation">(</span><span class="token function">is_near</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">//  2.72, 12.15, 72.25</span>  std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"mylist contains:"</span><span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span>std<span class="token operator">::</span>list<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">></span><span class="token operator">::</span>iterator it<span class="token operator">=</span>mylist<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> it<span class="token operator">!=</span>mylist<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>it<span class="token punctuation">)</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">' '</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>it<span class="token punctuation">;</span>  std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>上述排序后会删除所有的重复元素，只剩下一个，而不排序只会删除重复且连续的元素。</p><ul><li>merge</li></ul><p>merge源码实现采用前面<code>_M_transfer</code>函数，假设现在有两个list，分别是list1与list2。list1中的元素与list2中的元素进行比较，如果list1中元素值小于list2中元素值，则对list1迭代器++，不进行任何操作，而如果list1中的元素值大于list2中的元素值，那么每次将list2这个小的元素对应的迭代器塞入<code>_M_transfer</code>函数中，通过这个函数完成向list1中刚才比较的迭代器前面插入list2较小的元素，那么最后所有元素都会被插入到list1中。</p><p>当list1已经遍历完毕，而list2还没有遍历完毕，那么只需要执行一次<code>_M_transfer</code>，将list2链表从当前迭代器开始到最后的end插入到list1的末尾即可。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _Tp<span class="token punctuation">,</span> <span class="token keyword">typename</span> _Alloc<span class="token operator">></span><span class="token keyword">void</span>list<span class="token operator">&lt;</span>_Tp<span class="token punctuation">,</span> _Alloc<span class="token operator">></span><span class="token operator">::</span><span class="token macro property">#<span class="token directive keyword">if</span> __cplusplus >= 201103L</span><span class="token function">merge</span><span class="token punctuation">(</span>list<span class="token operator">&amp;&amp;</span> __x<span class="token punctuation">)</span><span class="token macro property">#<span class="token directive keyword">else</span></span><span class="token function">merge</span><span class="token punctuation">(</span>list<span class="token operator">&amp;</span> __x<span class="token punctuation">)</span><span class="token macro property">#<span class="token directive keyword">endif</span></span><span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// _GLIBCXX_RESOLVE_LIB_DEFECTS</span>  <span class="token comment" spellcheck="true">// 300. list::merge() specification incomplete</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">!=</span> <span class="token operator">&amp;</span>__x<span class="token punctuation">)</span>  <span class="token punctuation">{</span>      <span class="token function">_M_check_equal_allocators</span><span class="token punctuation">(</span>__x<span class="token punctuation">)</span><span class="token punctuation">;</span>      iterator __first1 <span class="token operator">=</span> <span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      iterator __last1 <span class="token operator">=</span> <span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      iterator __first2 <span class="token operator">=</span> __x<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      iterator __last2 <span class="token operator">=</span> __x<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">while</span> <span class="token punctuation">(</span>__first1 <span class="token operator">!=</span> __last1 <span class="token operator">&amp;&amp;</span> __first2 <span class="token operator">!=</span> __last2<span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>__first2 <span class="token operator">&lt;</span> <span class="token operator">*</span>__first1<span class="token punctuation">)</span>         <span class="token punctuation">{</span>            iterator __next <span class="token operator">=</span> __first2<span class="token punctuation">;</span>            <span class="token function">_M_transfer</span><span class="token punctuation">(</span>__first1<span class="token punctuation">,</span> __first2<span class="token punctuation">,</span> <span class="token operator">++</span>__next<span class="token punctuation">)</span><span class="token punctuation">;</span>            __first2 <span class="token operator">=</span> __next<span class="token punctuation">;</span>         <span class="token punctuation">}</span>        <span class="token keyword">else</span>          <span class="token operator">++</span>__first1<span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>__first2 <span class="token operator">!=</span> __last2<span class="token punctuation">)</span>        <span class="token function">_M_transfer</span><span class="token punctuation">(</span>__last1<span class="token punctuation">,</span> __first2<span class="token punctuation">,</span> __last2<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>使用：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> l1 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> l2 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    l1<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    l2<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    l1<span class="token punctuation">.</span><span class="token function">merge</span><span class="token punctuation">(</span>l2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><ul><li>sort</li></ul><p>由于STL本身的排序算法sort接受的输入迭代器是随机访问迭代器，但是双向list链表容器的访问方式是双向迭代器，因此，不能使用STL本身的排序算法sort，必须自己定义属于自己访问的排序算法。我们从源码的剖析中，可以看到该排序算法思想类似于归并排序。</p><p>sort中splice调用的是：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">splice</span><span class="token punctuation">(</span>const_iterator __position<span class="token punctuation">,</span> list<span class="token operator">&amp;</span> __x<span class="token punctuation">,</span> const_iterator __i<span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">{</span> <span class="token function">splice</span><span class="token punctuation">(</span>__position<span class="token punctuation">,</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>__x<span class="token punctuation">)</span><span class="token punctuation">,</span> __i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre><p>进一步分析：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">void</span><span class="token function">splice</span><span class="token punctuation">(</span>iterator __position<span class="token punctuation">,</span> list <span class="token operator">&amp;</span>__x<span class="token punctuation">,</span> iterator __i<span class="token punctuation">)</span><span class="token punctuation">{</span>    iterator __j <span class="token operator">=</span> __i<span class="token punctuation">.</span><span class="token function">_M_const_cast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">++</span>__j<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>__position <span class="token operator">==</span> __i <span class="token operator">||</span> __position <span class="token operator">==</span> __j<span class="token punctuation">)</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">!=</span> <span class="token operator">&amp;</span>__x<span class="token punctuation">)</span>        <span class="token function">_M_check_equal_allocators</span><span class="token punctuation">(</span>__x<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span><span class="token punctuation">(</span>__position<span class="token punctuation">.</span><span class="token function">_M_const_cast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                      __i<span class="token punctuation">.</span><span class="token function">_M_const_cast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> __j<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>最后调用的是<code>_M_transfer</code>。</p><p>在sort中还有一个函数<code>swap</code>，完成两个链表交换，实现代码在<code>gcc-4.9.1/libstdc++-v3/src/c++98/list.cc</code>中：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">void</span>_List_node_base<span class="token operator">::</span><span class="token function">swap</span><span class="token punctuation">(</span>_List_node_base<span class="token operator">&amp;</span> __x<span class="token punctuation">,</span>          _List_node_base<span class="token operator">&amp;</span> __y<span class="token punctuation">)</span> _GLIBCXX_USE_NOEXCEPT<span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span> __x<span class="token punctuation">.</span>_M_next <span class="token operator">!=</span> <span class="token operator">&amp;</span>__x <span class="token punctuation">)</span>    <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span> __y<span class="token punctuation">.</span>_M_next <span class="token operator">!=</span> <span class="token operator">&amp;</span>__y <span class="token punctuation">)</span>        <span class="token punctuation">{</span>          <span class="token comment" spellcheck="true">// Both __x and __y are not empty.</span>          std<span class="token operator">::</span><span class="token function">swap</span><span class="token punctuation">(</span>__x<span class="token punctuation">.</span>_M_next<span class="token punctuation">,</span>__y<span class="token punctuation">.</span>_M_next<span class="token punctuation">)</span><span class="token punctuation">;</span>          std<span class="token operator">::</span><span class="token function">swap</span><span class="token punctuation">(</span>__x<span class="token punctuation">.</span>_M_prev<span class="token punctuation">,</span>__y<span class="token punctuation">.</span>_M_prev<span class="token punctuation">)</span><span class="token punctuation">;</span>          __x<span class="token punctuation">.</span>_M_next<span class="token operator">-</span><span class="token operator">></span>_M_prev <span class="token operator">=</span> __x<span class="token punctuation">.</span>_M_prev<span class="token operator">-</span><span class="token operator">></span>_M_next <span class="token operator">=</span> <span class="token operator">&amp;</span>__x<span class="token punctuation">;</span>          __y<span class="token punctuation">.</span>_M_next<span class="token operator">-</span><span class="token operator">></span>_M_prev <span class="token operator">=</span> __y<span class="token punctuation">.</span>_M_prev<span class="token operator">-</span><span class="token operator">></span>_M_next <span class="token operator">=</span> <span class="token operator">&amp;</span>__y<span class="token punctuation">;</span>        <span class="token punctuation">}</span>      <span class="token keyword">else</span>        <span class="token punctuation">{</span>              <span class="token comment" spellcheck="true">// __x is not empty, __y is empty.</span>              __y<span class="token punctuation">.</span>_M_next <span class="token operator">=</span> __x<span class="token punctuation">.</span>_M_next<span class="token punctuation">;</span>              __y<span class="token punctuation">.</span>_M_prev <span class="token operator">=</span> __x<span class="token punctuation">.</span>_M_prev<span class="token punctuation">;</span>              __y<span class="token punctuation">.</span>_M_next<span class="token operator">-</span><span class="token operator">></span>_M_prev <span class="token operator">=</span> __y<span class="token punctuation">.</span>_M_prev<span class="token operator">-</span><span class="token operator">></span>_M_next <span class="token operator">=</span> <span class="token operator">&amp;</span>__y<span class="token punctuation">;</span>              __x<span class="token punctuation">.</span>_M_next <span class="token operator">=</span> __x<span class="token punctuation">.</span>_M_prev <span class="token operator">=</span> <span class="token operator">&amp;</span>__x<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>      <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span> __y<span class="token punctuation">.</span>_M_next <span class="token operator">!=</span> <span class="token operator">&amp;</span>__y <span class="token punctuation">)</span>        <span class="token punctuation">{</span>          <span class="token comment" spellcheck="true">// __x is empty, __y is not empty.</span>          __x<span class="token punctuation">.</span>_M_next <span class="token operator">=</span> __y<span class="token punctuation">.</span>_M_next<span class="token punctuation">;</span>          __x<span class="token punctuation">.</span>_M_prev <span class="token operator">=</span> __y<span class="token punctuation">.</span>_M_prev<span class="token punctuation">;</span>          __x<span class="token punctuation">.</span>_M_next<span class="token operator">-</span><span class="token operator">></span>_M_prev <span class="token operator">=</span> __x<span class="token punctuation">.</span>_M_prev<span class="token operator">-</span><span class="token operator">></span>_M_next <span class="token operator">=</span> <span class="token operator">&amp;</span>__x<span class="token punctuation">;</span>          __y<span class="token punctuation">.</span>_M_next <span class="token operator">=</span> __y<span class="token punctuation">.</span>_M_prev <span class="token operator">=</span> <span class="token operator">&amp;</span>__y<span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>具体的实现思路是，判断两个链表为空还是不为空，然后修改next指针与prev指针。</p><p>下面来看看强大的sort：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _Tp<span class="token punctuation">,</span> <span class="token keyword">typename</span> _Alloc<span class="token operator">></span><span class="token keyword">void</span>list<span class="token operator">&lt;</span>_Tp<span class="token punctuation">,</span> _Alloc<span class="token operator">></span><span class="token operator">::</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// Do nothing if the list has length 0 or 1.</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_node<span class="token punctuation">.</span>_M_next <span class="token operator">!=</span> <span class="token operator">&amp;</span><span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_node        <span class="token operator">&amp;&amp;</span> <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_node<span class="token punctuation">.</span>_M_next<span class="token operator">-</span><span class="token operator">></span>_M_next <span class="token operator">!=</span> <span class="token operator">&amp;</span><span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>_M_impl<span class="token punctuation">.</span>_M_node<span class="token punctuation">)</span> <span class="token punctuation">{</span>        list __carry<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 辅助链表，用于从a中提取元素以及临时保存两个链表的合并结果</span>        list __tmp<span class="token punctuation">[</span><span class="token number">64</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 保存着当前每一个归并层次的结果, i号链表保存的元素个数为2的i次方或者0</span>        list <span class="token operator">*</span>__fill <span class="token operator">=</span> <span class="token operator">&amp;</span>__tmp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 表示当前最大归并排序的层次，while循环之后__fill变成log2(list.size())</span>        list <span class="token operator">*</span>__counter<span class="token punctuation">;</span>        <span class="token keyword">do</span> <span class="token punctuation">{</span>            __carry<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>__carry<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//把当前链表的第一个节点放在carry链表头</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>__counter <span class="token operator">=</span> <span class="token operator">&amp;</span>__tmp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                 __counter <span class="token operator">!=</span> __fill <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>__counter<span class="token operator">-</span><span class="token operator">></span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token operator">++</span>__counter<span class="token punctuation">)</span> <span class="token punctuation">{</span>                __counter<span class="token operator">-</span><span class="token operator">></span><span class="token function">merge</span><span class="token punctuation">(</span>__carry<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 两个有序链表合并</span>                __carry<span class="token punctuation">.</span><span class="token function">swap</span><span class="token punctuation">(</span><span class="token operator">*</span>__counter<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 类似于交换链表carry和counter[i]内容    </span>            <span class="token punctuation">}</span>            __carry<span class="token punctuation">.</span><span class="token function">swap</span><span class="token punctuation">(</span><span class="token operator">*</span>__counter<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 类似于交换链表carry和counter[i]内容    </span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>__counter <span class="token operator">==</span> __fill<span class="token punctuation">)</span>                <span class="token operator">++</span>__fill<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 每两个进行归并，依次网上，直到最后*(__fill-1)保存最后的排序结果。然后交换到当前list中。</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>__counter <span class="token operator">=</span> <span class="token operator">&amp;</span>__tmp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> __counter <span class="token operator">!=</span> __fill<span class="token punctuation">;</span> <span class="token operator">++</span>__counter<span class="token punctuation">)</span>            __counter<span class="token operator">-</span><span class="token operator">></span><span class="token function">merge</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span>__counter <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">swap</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span>__fill <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>上述代码看起来比较难懂，在网上查找后发现，G2.9中：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Alloc</span><span class="token operator">></span><span class="token keyword">void</span> list<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> Alloc<span class="token operator">></span> <span class="token operator">::</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 判断链表是否为空或者只有一个元素</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>next <span class="token operator">==</span> node <span class="token operator">||</span> <span class="token function">link_type</span><span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span>next <span class="token operator">==</span> node<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    list<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> Alloc<span class="token operator">></span> carry<span class="token punctuation">;</span>    list<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> alloc<span class="token operator">></span> counter<span class="token punctuation">[</span><span class="token number">64</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> fill <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        carry<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>carry<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> fill <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>counter<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            counter<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">merge</span><span class="token punctuation">(</span>carry<span class="token punctuation">)</span><span class="token punctuation">;</span>            carry<span class="token punctuation">.</span><span class="token function">swap</span><span class="token punctuation">(</span>counter<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        carry<span class="token punctuation">.</span><span class="token function">swap</span><span class="token punctuation">(</span>counter<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">==</span> fill<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token operator">++</span>fill<span class="token punctuation">;</span>        <span class="token punctuation">}</span>     <span class="token punctuation">}</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> fill<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>        counter<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">merge</span><span class="token punctuation">(</span>counter<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">swap</span><span class="token punctuation">(</span>counter<span class="token punctuation">[</span>fill<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>对应的外部实现是：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">sortList</span><span class="token punctuation">(</span>list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token operator">&amp;</span>l<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>l<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> carry<span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// 辅助链表，用于从a中提取元素以及临时保存两个链表的合并结果</span>    list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> counter<span class="token punctuation">[</span><span class="token number">64</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 保存着当前每一个归并层次的结果, i号链表保存的元素个数为2的i次方或者0</span>    <span class="token keyword">int</span> fill <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// 表示当前最大归并排序的层次，while循环之后fill变成log2(a.size())</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>l<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        carry<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>carry<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> l<span class="token punctuation">,</span> l<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 将链表a中的第一个元素移动至carry开头</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 从小往大不断合并非空归并层次直至遇到空层或者到达当前最大归并层次</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> fill <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>counter<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            counter<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">merge</span><span class="token punctuation">(</span>carry<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 链表合并，结果链表是有序的，必须保证合并前两个链表是有序的</span>            carry<span class="token punctuation">.</span><span class="token function">swap</span><span class="token punctuation">(</span>counter<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 链表元素互换</span>        <span class="token punctuation">}</span>        carry<span class="token punctuation">.</span><span class="token function">swap</span><span class="token punctuation">(</span>counter<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> fill<span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token comment" spellcheck="true">// i到达当前最大归并层次，说明得增加一层</span>            <span class="token operator">++</span>fill<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> fill<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 将所有归并层次的结果合并得到最终结果counter[fill - 1]</span>        counter<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">merge</span><span class="token punctuation">(</span>counter<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    l<span class="token punctuation">.</span><span class="token function">swap</span><span class="token punctuation">(</span>counter<span class="token punctuation">[</span>fill <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>这一块可以参考</p><blockquote><p><a href="https://blog.csdn.net/chenhanzhun/article/details/39337331" target="_blank" rel="noopener">https://blog.csdn.net/chenhanzhun/article/details/39337331</a></p></blockquote><p>上面给出了详细的过程图解。</p><p>我们再次将G4.9转换对应的外部实现：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">sortList1</span><span class="token punctuation">(</span>list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token operator">&amp;</span>l<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">typedef</span> list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> list<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>l<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    list __carry<span class="token punctuation">;</span>    list __tmp<span class="token punctuation">[</span><span class="token number">64</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    list <span class="token operator">*</span>__fill <span class="token operator">=</span> <span class="token operator">&amp;</span>__tmp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    list <span class="token operator">*</span>__counter<span class="token punctuation">;</span>    <span class="token keyword">do</span> <span class="token punctuation">{</span>        __carry<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>__carry<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> l<span class="token punctuation">,</span> l<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>__counter <span class="token operator">=</span> <span class="token operator">&amp;</span>__tmp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>             __counter <span class="token operator">!=</span> __fill <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>__counter<span class="token operator">-</span><span class="token operator">></span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token operator">++</span>__counter<span class="token punctuation">)</span> <span class="token punctuation">{</span>            __counter<span class="token operator">-</span><span class="token operator">></span><span class="token function">merge</span><span class="token punctuation">(</span>__carry<span class="token punctuation">)</span><span class="token punctuation">;</span>            __carry<span class="token punctuation">.</span><span class="token function">swap</span><span class="token punctuation">(</span><span class="token operator">*</span>__counter<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        __carry<span class="token punctuation">.</span><span class="token function">swap</span><span class="token punctuation">(</span><span class="token operator">*</span>__counter<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>__counter <span class="token operator">==</span> __fill<span class="token punctuation">)</span> <span class="token operator">++</span>__fill<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>l<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>__counter <span class="token operator">=</span> <span class="token operator">&amp;</span>__tmp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> __counter <span class="token operator">!=</span> __fill<span class="token punctuation">;</span> <span class="token operator">++</span>__counter<span class="token punctuation">)</span>        __counter<span class="token operator">-</span><span class="token operator">></span><span class="token function">merge</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span>__counter <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    l<span class="token punctuation">.</span><span class="token function">swap</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span>__fill <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>使用：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> l <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"===============排序前=============="</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> i<span class="token operator">:</span>l<span class="token punctuation">)</span> cout <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token function">sortList1</span><span class="token punctuation">(</span>l<span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"===============排序后=============="</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> i<span class="token operator">:</span>l<span class="token punctuation">)</span> cout <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>【<strong>操作符重载</strong>】</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _Tp<span class="token punctuation">,</span> <span class="token keyword">typename</span> _Alloc<span class="token operator">></span><span class="token keyword">inline</span> <span class="token keyword">bool</span><span class="token keyword">operator</span><span class="token operator">==</span><span class="token punctuation">(</span><span class="token keyword">const</span> list<span class="token operator">&lt;</span>_Tp<span class="token punctuation">,</span> _Alloc<span class="token operator">></span> <span class="token operator">&amp;</span>__x<span class="token punctuation">,</span> <span class="token keyword">const</span> list<span class="token operator">&lt;</span>_Tp<span class="token punctuation">,</span> _Alloc<span class="token operator">></span> <span class="token operator">&amp;</span>__y<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">typedef</span> <span class="token keyword">typename</span> list<span class="token operator">&lt;</span>_Tp<span class="token punctuation">,</span> _Alloc<span class="token operator">></span><span class="token operator">::</span>const_iterator const_iterator<span class="token punctuation">;</span>    const_iterator __end1 <span class="token operator">=</span> __x<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    const_iterator __end2 <span class="token operator">=</span> __y<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    const_iterator __i1 <span class="token operator">=</span> __x<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    const_iterator __i2 <span class="token operator">=</span> __y<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>__i1 <span class="token operator">!=</span> __end1 <span class="token operator">&amp;&amp;</span> __i2 <span class="token operator">!=</span> __end2 <span class="token operator">&amp;&amp;</span> <span class="token operator">*</span>__i1 <span class="token operator">==</span> <span class="token operator">*</span>__i2<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token operator">++</span>__i1<span class="token punctuation">;</span>        <span class="token operator">++</span>__i2<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> __i1 <span class="token operator">==</span> __end1 <span class="token operator">&amp;&amp;</span> __i2 <span class="token operator">==</span> __end2<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>实现思路是，迭代判断两个迭代器是否都抵达末尾。</p><p>剩下就是其他的操作符重载，比较简单，就不阐述了。其中<code>lexicographical_compare</code>实现在<code>c++-v3/src/c++98/stl_algobase.h</code>中，该函数是按照字典序测试[frist1,last1)是否小于[first2,last2)。该函数使用opeartor&lt;或者是comp进行比较。其行为类似于：如果两个序列长度不同，并且短序列和长序列头部完全一样，例如example和examplee.那么，长度大的字典序比短序的大。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">InputIterator1</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">InputIterator2</span><span class="token operator">></span><span class="token keyword">bool</span> <span class="token function">lexicographical_compare</span> <span class="token punctuation">(</span>InputIterator1 first1<span class="token punctuation">,</span> InputIterator1 last1<span class="token punctuation">,</span>InputIterator2 first2<span class="token punctuation">,</span> InputIterator2 last2<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>first1<span class="token operator">!=</span>last1<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>first2<span class="token operator">==</span>last2 <span class="token operator">||</span> <span class="token operator">*</span>first2<span class="token operator">&lt;</span><span class="token operator">*</span>first1<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>first1<span class="token operator">&lt;</span><span class="token operator">*</span>first2<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token operator">++</span>first1<span class="token punctuation">;</span> <span class="token operator">++</span>first2<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>first2<span class="token operator">!=</span>last2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>使用：</p><pre><code>int main() {     vector&lt;char&gt; v1{'h','e','l','l','o'};    vector&lt;char&gt; v2{'h','e','l','l','o','o'};    vector&lt;char&gt; v3{'h','e','l','m','o'};    cout&lt;&lt;"v1=";    for(char i:v1)        cout&lt;&lt;i&lt;&lt;" ";    cout&lt;&lt;endl;    cout&lt;&lt;"v2=";    for(char i:v2)        cout&lt;&lt;i&lt;&lt;" ";    cout&lt;&lt;endl;    cout&lt;&lt;"v3=";    for(char i:v3)        cout&lt;&lt;i&lt;&lt;" ";    cout&lt;&lt;endl;    if(lexicographical_compare(v1.begin(),v1.end(),v2.begin(),v2.end()))        cout&lt;&lt;"v1 is less than v2 "&lt;&lt;endl;    else        cout&lt;&lt;"v2 is less than v1 "&lt;&lt;endl;    if(lexicographical_compare(v1.begin(),v1.end(),v3.begin(),v3.end()))        cout&lt;&lt;"v1 is less than v3 "&lt;&lt;endl;    else        cout&lt;&lt;"v3 is less than v1 "&lt;&lt;endl;}</code></pre><p>其它重载操作符如下：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _Tp<span class="token punctuation">,</span> <span class="token keyword">typename</span> _Alloc<span class="token operator">></span><span class="token keyword">inline</span> <span class="token keyword">bool</span><span class="token keyword">operator</span><span class="token operator">&lt;</span><span class="token punctuation">(</span><span class="token keyword">const</span> list<span class="token operator">&lt;</span>_Tp<span class="token punctuation">,</span> _Alloc<span class="token operator">></span> <span class="token operator">&amp;</span>__x<span class="token punctuation">,</span> <span class="token keyword">const</span> list<span class="token operator">&lt;</span>_Tp<span class="token punctuation">,</span> _Alloc<span class="token operator">></span> <span class="token operator">&amp;</span>__y<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> std<span class="token operator">::</span><span class="token function">lexicographical_compare</span><span class="token punctuation">(</span>__x<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> __x<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                                        __y<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> __y<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/// Based on operator==</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _Tp<span class="token punctuation">,</span> <span class="token keyword">typename</span> _Alloc<span class="token operator">></span><span class="token keyword">inline</span> <span class="token keyword">bool</span><span class="token keyword">operator</span><span class="token operator">!=</span><span class="token punctuation">(</span><span class="token keyword">const</span> list<span class="token operator">&lt;</span>_Tp<span class="token punctuation">,</span> _Alloc<span class="token operator">></span> <span class="token operator">&amp;</span>__x<span class="token punctuation">,</span> <span class="token keyword">const</span> list<span class="token operator">&lt;</span>_Tp<span class="token punctuation">,</span> _Alloc<span class="token operator">></span> <span class="token operator">&amp;</span>__y<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token operator">!</span><span class="token punctuation">(</span>__x <span class="token operator">==</span> __y<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token comment" spellcheck="true">/// Based on operator&lt;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _Tp<span class="token punctuation">,</span> <span class="token keyword">typename</span> _Alloc<span class="token operator">></span><span class="token keyword">inline</span> <span class="token keyword">bool</span><span class="token keyword">operator</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">const</span> list<span class="token operator">&lt;</span>_Tp<span class="token punctuation">,</span> _Alloc<span class="token operator">></span> <span class="token operator">&amp;</span>__x<span class="token punctuation">,</span> <span class="token keyword">const</span> list<span class="token operator">&lt;</span>_Tp<span class="token punctuation">,</span> _Alloc<span class="token operator">></span> <span class="token operator">&amp;</span>__y<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> __y <span class="token operator">&lt;</span> __x<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token comment" spellcheck="true">/// Based on operator&lt;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _Tp<span class="token punctuation">,</span> <span class="token keyword">typename</span> _Alloc<span class="token operator">></span><span class="token keyword">inline</span> <span class="token keyword">bool</span><span class="token keyword">operator</span><span class="token operator">&lt;=</span><span class="token punctuation">(</span><span class="token keyword">const</span> list<span class="token operator">&lt;</span>_Tp<span class="token punctuation">,</span> _Alloc<span class="token operator">></span> <span class="token operator">&amp;</span>__x<span class="token punctuation">,</span> <span class="token keyword">const</span> list<span class="token operator">&lt;</span>_Tp<span class="token punctuation">,</span> _Alloc<span class="token operator">></span> <span class="token operator">&amp;</span>__y<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token operator">!</span><span class="token punctuation">(</span>__y <span class="token operator">&lt;</span> __x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token comment" spellcheck="true">/// Based on operator&lt;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _Tp<span class="token punctuation">,</span> <span class="token keyword">typename</span> _Alloc<span class="token operator">></span><span class="token keyword">inline</span> <span class="token keyword">bool</span><span class="token keyword">operator</span><span class="token operator">>=</span><span class="token punctuation">(</span><span class="token keyword">const</span> list<span class="token operator">&lt;</span>_Tp<span class="token punctuation">,</span> _Alloc<span class="token operator">></span> <span class="token operator">&amp;</span>__x<span class="token punctuation">,</span> <span class="token keyword">const</span> list<span class="token operator">&lt;</span>_Tp<span class="token punctuation">,</span> _Alloc<span class="token operator">></span> <span class="token operator">&amp;</span>__y<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token operator">!</span><span class="token punctuation">(</span>__x <span class="token operator">&lt;</span> __y<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre><h3 id="1-2-list基类源码"><a href="#1-2-list基类源码" class="headerlink" title="1.2 list基类源码"></a>1.2 list基类源码</h3><p><code>_list_base</code>中有一个结构体:<code>_List_impl</code>,而<code>_List_impl</code>中有一个<code>List_node_base</code>。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">_List_base</span><span class="token punctuation">{</span><span class="token keyword">protected</span><span class="token operator">:</span>  <span class="token keyword">typedef</span> <span class="token keyword">typename</span> _Alloc<span class="token operator">::</span><span class="token keyword">template</span> rebind<span class="token operator">&lt;</span>_List_node<span class="token operator">&lt;</span>_Tp<span class="token operator">></span> <span class="token operator">></span><span class="token operator">::</span>other    _Node_alloc_type<span class="token punctuation">;</span>  <span class="token keyword">typedef</span> <span class="token keyword">typename</span> _Alloc<span class="token operator">::</span><span class="token keyword">template</span> rebind<span class="token operator">&lt;</span>_Tp<span class="token operator">></span><span class="token operator">::</span>other _Tp_alloc_type<span class="token punctuation">;</span>  <span class="token keyword">struct</span> _List_impl  <span class="token operator">:</span> <span class="token keyword">public</span> _Node_alloc_type  <span class="token punctuation">{</span>    __detail<span class="token operator">::</span>_List_node_base _M_node<span class="token punctuation">;</span>    <span class="token function">_List_impl</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token operator">:</span> <span class="token function">_Node_alloc_type</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">_M_node</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span> <span class="token punctuation">}</span>    <span class="token function">_List_impl</span><span class="token punctuation">(</span><span class="token keyword">const</span> _Node_alloc_type<span class="token operator">&amp;</span> __a<span class="token punctuation">)</span> _GLIBCXX_NOEXCEPT    <span class="token operator">:</span> <span class="token function">_Node_alloc_type</span><span class="token punctuation">(</span>__a<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">_M_node</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span> <span class="token punctuation">}</span>    <span class="token macro property">#<span class="token directive keyword">if</span> __cplusplus >= 201103L</span>    <span class="token function">_List_impl</span><span class="token punctuation">(</span>_Node_alloc_type<span class="token operator">&amp;&amp;</span> __a<span class="token punctuation">)</span> _GLIBCXX_NOEXCEPT    <span class="token operator">:</span> <span class="token function">_Node_alloc_type</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>__a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">_M_node</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span> <span class="token punctuation">}</span>    <span class="token macro property">#<span class="token directive keyword">endif</span></span>  <span class="token punctuation">}</span><span class="token punctuation">;</span>  _List_impl _M_impl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>最后形成的图就是:</p><p><img src="https://raw.githubusercontent.com/Light-City/cloudimg/master/list_iterator_design.png" alt="list's iterator_design"></p><p>所以如果求:</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">sizeof</span><span class="token punctuation">(</span>list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token number">16</span></code></pre><p>原因是:</p><p><code>list</code>的sizeof为1,所以sizeof来源于基类<code>_list_base</code>,而<code>_list_base</code>中有一个结构体:<code>_List_impl</code>,而<code>_List_impl</code>中有一个<code>_List_node_base</code>.</p><p>我们知道<code>_List_node_base</code>,里面有两个指针,在64位上,每个为8字节,共16字节。</p><h2 id="2-list’s-Iterator剖析"><a href="#2-list’s-Iterator剖析" class="headerlink" title="2.list’s Iterator剖析"></a>2.list’s Iterator剖析</h2><h3 id="2-1-iterator"><a href="#2-1-iterator" class="headerlink" title="2.1 iterator"></a>2.1 iterator</h3><p>list的iterator定义</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _Tp<span class="token operator">></span><span class="token keyword">struct</span> _List_iterator<span class="token punctuation">{</span>  <span class="token keyword">typedef</span> _List_iterator<span class="token operator">&lt;</span>_Tp<span class="token operator">></span>                _Self<span class="token punctuation">;</span>  <span class="token keyword">typedef</span> _List_node<span class="token operator">&lt;</span>_Tp<span class="token operator">></span>                    _Node<span class="token punctuation">;</span>  <span class="token keyword">typedef</span> ptrdiff_t                          difference_type<span class="token punctuation">;</span>  <span class="token keyword">typedef</span> std<span class="token operator">::</span>bidirectional_iterator_tag    iterator_category<span class="token punctuation">;</span>  <span class="token keyword">typedef</span> _Tp                                value_type<span class="token punctuation">;</span>  <span class="token keyword">typedef</span> _Tp<span class="token operator">*</span>                               pointer<span class="token punctuation">;</span>  <span class="token keyword">typedef</span> _Tp<span class="token operator">&amp;</span>                               reference<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// The only member points to the %list element.</span>   __detail<span class="token operator">::</span>_List_node_base<span class="token operator">*</span> _M_node<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//  _List_node(节点的数据部分) -> _List_node_base(前指针与后指针)</span>  <span class="token function">_List_iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> _GLIBCXX_NOEXCEPT  <span class="token operator">:</span> <span class="token function">_M_node</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>  <span class="token keyword">explicit</span>  <span class="token function">_List_iterator</span><span class="token punctuation">(</span>__detail<span class="token operator">::</span>_List_node_base<span class="token operator">*</span> __x<span class="token punctuation">)</span> _GLIBCXX_NOEXCEPT  <span class="token operator">:</span> <span class="token function">_M_node</span><span class="token punctuation">(</span>__x<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>  _Self  <span class="token function">_M_const_cast</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> _GLIBCXX_NOEXCEPT  <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// The only member points to the %list element.</span>  __detail<span class="token operator">::</span>_List_node_base<span class="token operator">*</span> _M_node<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>内部重载函数:</p><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// Must downcast from _List_node_base to _List_node to get to _M_data.</span><span class="token comment" spellcheck="true">// 重载*操作符</span>reference <span class="token keyword">operator</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> _GLIBCXX_NOEXCEPT<span class="token punctuation">{</span>     <span class="token keyword">return</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span>_Node<span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">(</span>_M_node<span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span>_M_data<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 重载->操作符</span>pointer <span class="token keyword">operator</span><span class="token operator">-</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> _GLIBCXX_NOEXCEPT<span class="token punctuation">{</span>     <span class="token keyword">return</span> std<span class="token operator">::</span><span class="token function">__addressof</span><span class="token punctuation">(</span><span class="token keyword">static_cast</span><span class="token operator">&lt;</span>_Node<span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">(</span>_M_node<span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span>_M_data<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 重载前置++操作符  ++i</span>_Self<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">++</span><span class="token punctuation">(</span><span class="token punctuation">)</span> _GLIBCXX_NOEXCEPT   <span class="token punctuation">{</span>     _M_node <span class="token operator">=</span> _M_node<span class="token operator">-</span><span class="token operator">></span>_M_next<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 重载后置++操作符 i++</span>_Self <span class="token keyword">operator</span><span class="token operator">++</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> _GLIBCXX_NOEXCEPT<span class="token punctuation">{</span>    _Self __tmp <span class="token operator">=</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">// 记录原值  *调用的是拷贝构造函数</span>    _M_node <span class="token operator">=</span> _M_node<span class="token operator">-</span><span class="token operator">></span>_M_next<span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 进行操作</span>    <span class="token keyword">return</span> __tmp<span class="token punctuation">;</span>                     <span class="token comment" spellcheck="true">// 返回原值</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 重载前置--操作符  --i</span>_Self<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">--</span><span class="token punctuation">(</span><span class="token punctuation">)</span> _GLIBCXX_NOEXCEPT<span class="token punctuation">{</span>    _M_node <span class="token operator">=</span> _M_node<span class="token operator">-</span><span class="token operator">></span>_M_prev<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 重载后置--操作符  --i</span>_Self <span class="token keyword">operator</span><span class="token operator">--</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> _GLIBCXX_NOEXCEPT<span class="token punctuation">{</span>    _Self __tmp <span class="token operator">=</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>    _M_node <span class="token operator">=</span> _M_node<span class="token operator">-</span><span class="token operator">></span>_M_prev<span class="token punctuation">;</span>    <span class="token keyword">return</span> __tmp<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 重载++操作符</span><span class="token keyword">bool</span> <span class="token keyword">operator</span><span class="token operator">==</span><span class="token punctuation">(</span><span class="token keyword">const</span> _Self<span class="token operator">&amp;</span> __x<span class="token punctuation">)</span> <span class="token keyword">const</span> _GLIBCXX_NOEXCEPT<span class="token punctuation">{</span>     <span class="token keyword">return</span> _M_node <span class="token operator">==</span> __x<span class="token punctuation">.</span>_M_node<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 重载!=操作符</span><span class="token keyword">bool</span> <span class="token keyword">operator</span><span class="token operator">!=</span><span class="token punctuation">(</span><span class="token keyword">const</span> _Self<span class="token operator">&amp;</span> __x<span class="token punctuation">)</span> <span class="token keyword">const</span> _GLIBCXX_NOEXCEPT<span class="token punctuation">{</span>     <span class="token keyword">return</span> _M_node <span class="token operator">!=</span> __x<span class="token punctuation">.</span>_M_node<span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre><h3 id="2-2-结点设计"><a href="#2-2-结点设计" class="headerlink" title="2.2 结点设计"></a>2.2 结点设计</h3><p>iterator内部的<code>_List_node</code>,这里可以得到继承自<code>_List_node_base</code>.</p><p><code>_List_node</code>放数据部分</p><p><code>_List_node_base</code>放前后指针</p><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">/// An actual node in the %list.</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _Tp<span class="token operator">></span><span class="token keyword">struct</span> _List_node <span class="token operator">:</span> <span class="token keyword">public</span> __detail<span class="token operator">::</span>_List_node_base<span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">///&lt; User's data.</span>  _Tp _M_data<span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">if</span> __cplusplus >= 201103L</span>  <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> _Args<span class="token operator">></span>    <span class="token function">_List_node</span><span class="token punctuation">(</span>_Args<span class="token operator">&amp;&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> __args<span class="token punctuation">)</span><span class="token operator">:</span> __detail<span class="token operator">::</span><span class="token function">_List_node_base</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">_M_data</span><span class="token punctuation">(</span>std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>_Args<span class="token operator">></span><span class="token punctuation">(</span>__args<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span>     <span class="token punctuation">{</span> <span class="token punctuation">}</span><span class="token macro property">#<span class="token directive keyword">endif</span></span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p><code>_List_node_base</code>代码:</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">namespace</span> __detail<span class="token punctuation">{</span>    _GLIBCXX_BEGIN_NAMESPACE_VERSION    <span class="token comment" spellcheck="true">/// Common part of a node in the %list. </span>    <span class="token keyword">struct</span> _List_node_base    <span class="token punctuation">{</span>      _List_node_base<span class="token operator">*</span> _M_next<span class="token punctuation">;</span>      _List_node_base<span class="token operator">*</span> _M_prev<span class="token punctuation">;</span>      <span class="token keyword">static</span> <span class="token keyword">void</span>      <span class="token function">swap</span><span class="token punctuation">(</span>_List_node_base<span class="token operator">&amp;</span> __x<span class="token punctuation">,</span> _List_node_base<span class="token operator">&amp;</span> __y<span class="token punctuation">)</span> _GLIBCXX_USE_NOEXCEPT<span class="token punctuation">;</span>      <span class="token keyword">void</span>      <span class="token function">_M_transfer</span><span class="token punctuation">(</span>_List_node_base<span class="token operator">*</span> <span class="token keyword">const</span> __first<span class="token punctuation">,</span>          _List_node_base<span class="token operator">*</span> <span class="token keyword">const</span> __last<span class="token punctuation">)</span> _GLIBCXX_USE_NOEXCEPT<span class="token punctuation">;</span>      <span class="token keyword">void</span>      <span class="token function">_M_reverse</span><span class="token punctuation">(</span><span class="token punctuation">)</span> _GLIBCXX_USE_NOEXCEPT<span class="token punctuation">;</span>      <span class="token keyword">void</span>      <span class="token function">_M_hook</span><span class="token punctuation">(</span>_List_node_base<span class="token operator">*</span> <span class="token keyword">const</span> __position<span class="token punctuation">)</span> _GLIBCXX_USE_NOEXCEPT<span class="token punctuation">;</span>      <span class="token keyword">void</span>      <span class="token function">_M_unhook</span><span class="token punctuation">(</span><span class="token punctuation">)</span> _GLIBCXX_USE_NOEXCEPT<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    _GLIBCXX_END_NAMESPACE_VERSION<span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// namespace detail</span></code></pre><p>迭代器在设计的时候,总是保持前闭后开原则,例如iter-&gt;begin()指向第一个元素,iter-&gt;end()指向实际最后一个元素的下一个元素,故最后的设计刻意在环形list尾部加一个空白结点,用以符合STL前闭后开原则.</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> STL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C/C++多线程编程基础</title>
      <link href="/2019/09/24/duo-jin-cheng-yu-duo-xian-cheng-ji-chu/"/>
      <url>/2019/09/24/duo-jin-cheng-yu-duo-xian-cheng-ji-chu/</url>
      
        <content type="html"><![CDATA[<h1 id="C-C-多线程编程基础"><a href="#C-C-多线程编程基础" class="headerlink" title="C/C++多线程编程基础"></a>C/C++多线程编程基础</h1><h2 id="1-基础问题"><a href="#1-基础问题" class="headerlink" title="1.基础问题"></a>1.基础问题</h2><ul><li><strong>某个线程崩溃，会导致进程退出吗?或者说进程中某个线程崩溃，是否会对其他线程造成影响？</strong></li></ul><p>答：一般来说，每个线程都是独立执行的单位，每个线程都有自己的上下文堆栈，一个线程的的崩溃不会对其他线程造成影响。但是通常情况下，一个线程崩溃会产生一个进程内的错误，例如，在 Linux 操作系统中，可能会产生一个 <strong>Segment Fault</strong> 错误，这个错误会产生一个信号，操作系统默认对这个信号的处理就是结束进程，整个进程都被销毁了，这样的话这个进程中存在的其他线程自然也就不存在了。</p><ul><li><strong>排查 Linux 进程 CPU 使用率过高问题？</strong></li></ul><p>在实际开发中，有时候由于我们的程序逻辑不当问题，会导致某个线程<strong>空转</strong>（如无限空循环），进而引起该进程占用 CPU 使用率过高。这不仅会造成我们的系统卡顿，也是对 CPU 资源的一种浪费。那如何定位和排查引起 CPU 使用率过高的线程呢？</p><p>在 Linux 下我们可以综合使用 pstack 和 top 命令来排查此类问题。</p><h2 id="2-基础命令"><a href="#2-基础命令" class="headerlink" title="2.基础命令"></a>2.基础命令</h2><ul><li>pstack</li></ul><p>Linux 系统中可以通过 <strong>pstack</strong> 来命令查看一个进程的线程数量和每个线程的调用堆栈情况。</p><pre><code>pstack pid</code></pre><p><strong>pid</strong> 设置为要查看的进程的 id 即可。</p><ul><li>top</li></ul><p>可以查看cpu高的进程，找到占用cpu最大的进程号，然后使用：</p><pre><code>top -p pid</code></pre><p>观察指定pid的CPU和内存以及负载情况。</p><p>现在有如下信息：</p><pre><code>top - 19:30:05 up  6:15,  1 user,  load average: 0.85, 0.71, 0.61Tasks:   1 total,   0 running,   1 sleeping,   0 stopped,   0 zombie%Cpu(s):  8.1 us,  2.9 sy,  0.0 ni, 87.8 id,  0.0 wa,  0.0 hi,  1.1 si,  0.0 stKiB Mem : 20412976 total, 10960136 free,  5416592 used,  4036248 buff/cacheKiB Swap:  2097148 total,  2097148 free,        0 used. 14315608 avail Mem </code></pre><p><strong>第一行是任务队列信息</strong></p><table><thead><tr><th align="center">任务队列信息</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">9:30:05</td><td align="center">当前时间</td></tr><tr><td align="center">6:15 min</td><td align="center">用户在线时间</td></tr><tr><td align="center">1users</td><td align="center">在线用户数</td></tr><tr><td align="center">load average: 0.85, 0.71, 0.61</td><td align="center">系统负载，即任务队列的平均长度。1分钟前、5分钟前、15分钟前平均负载</td></tr></tbody></table><p><strong>第二行为进程的信息</strong></p><table><thead><tr><th align="center">进程信息</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">Tasks: 1 total</td><td align="center">进程总数</td></tr><tr><td align="center">0 running</td><td align="center">正在运行的进程数</td></tr><tr><td align="center">1 sleeping</td><td align="center">睡眠的进程数</td></tr><tr><td align="center">0 stopped</td><td align="center">停止的进程数</td></tr><tr><td align="center">0 zombie</td><td align="center">僵尸进程数</td></tr></tbody></table><p><strong>第三行为cpu信息</strong></p><table><thead><tr><th align="center">cpu信息</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">8.1 us</td><td align="center">用户空间占用CPU百分比</td></tr><tr><td align="center">2.9% sy</td><td align="center">内核空间占用CPU百分比</td></tr><tr><td align="center">0.0% ni</td><td align="center">用户进程空间内改变过优先级的进程占用CPU百分比</td></tr><tr><td align="center">87.8% id</td><td align="center">空闲CPU百分比</td></tr><tr><td align="center">0.0% wa</td><td align="center">等待输入输出的CPU时间百分比</td></tr><tr><td align="center">0.0% hi</td><td align="center">硬件中断</td></tr><tr><td align="center">1.1% si</td><td align="center">软件中断</td></tr><tr><td align="center">0.0%st</td><td align="center">实时</td></tr></tbody></table><p><strong>第四、五行为内存信息。</strong></p><table><thead><tr><th align="center">物理内存信息</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">Mem: 20412976 total</td><td align="center">物理内存总量</td></tr><tr><td align="center">5416592 used</td><td align="center">使用的物理内存总量</td></tr><tr><td align="center">10960136 free</td><td align="center">空闲内存总量</td></tr><tr><td align="center">4036248 buffers/cache</td><td align="center">用作内核缓存的内存量</td></tr></tbody></table><table><thead><tr><th align="center">交换区信息</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">Swap: 2097148 total</td><td align="center">交换区总量</td></tr><tr><td align="center">0k used</td><td align="center">使用的交换区总量</td></tr><tr><td align="center">2097148 free</td><td align="center">空闲交换区总量</td></tr><tr><td align="center">14315608 cached</td><td align="center">缓冲的交换区总量</td></tr></tbody></table><p>那如何通过top命令定位问题进程中每个线程占用cpu情况？</p><p>使用<code>-H</code>,top 命令的 -H 选项的作用是显示每个一个进程的各个线程运行状态（线程模式）。</p><p>例如：</p><pre><code>top -p 2085 -H</code></pre><p><img src="https://raw.githubusercontent.com/Light-City/cloudimg/master/top.png" alt=""></p><p>由上图明显可以发现，线程PID 2085 CPU占用率最高，接下来定位该线程的代码是否出现异常导致cpu占用过高。</p><p>结合上述的pstack，例如：</p><pre><code>pstack 2085</code></pre><p>在 pstack 输出的各个线程中，只要逐一对照我们的程序源码来梳理下该线程中是否有大多数时间都处于空转的逻辑，然后修改和优化这些逻辑就可以解决 CPU 使用率过高的问题了，一般情况下，不工作的线程应尽量使用锁对象让其挂起，而不是空转，这样可以提高系统资源利用率。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> C </category>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 项目之Googletest单元测试</title>
      <link href="/2019/09/17/googletest-1/"/>
      <url>/2019/09/17/googletest-1/</url>
      
        <content type="html"><![CDATA[<h1 id="C-项目之Googletest单元测试"><a href="#C-项目之Googletest单元测试" class="headerlink" title="C++ 项目之Googletest单元测试"></a>C++ 项目之Googletest单元测试</h1><h2 id="1-Clion集成Googletest单元测试"><a href="#1-Clion集成Googletest单元测试" class="headerlink" title="1.Clion集成Googletest单元测试"></a>1.Clion集成Googletest单元测试</h2><p>Googletest - Google Testing and Mocking Framework</p><p>源码下载地址:</p><blockquote><p><a href="https://github.com/google/googletest/releases" target="_blank" rel="noopener">https://github.com/google/googletest/releases</a></p></blockquote><p>Googletest中包含两个模块,分别是gtest与gmock,需要分别源码编译,编译完后,到指定目录去拷贝includes文件夹与.so文件到下面路径的指定位置.</p><p>然后项目中创建ext目录,里面分为两块</p><ul><li>第一块:includes</li></ul><p>包含gmock与gtest的include文件,对应于gcc -I参数,头文件路径,包含以.h结尾的头文件</p><ul><li>第二块:libs</li></ul><p>包含gmock与gtest的libs文件,对应gcc -L参数,库文件路径,里面包含的是一些.so或.dll等动态或静态链接库</p><pre class=" language-cpp"><code class="language-cpp">├── ext│   ├── includes│   │   ├── gmock│   │   └── gtest│   └── libs│       ├── gmock│       └── gtest</code></pre><p>上述本地项目路径配置好后,在CmakeLists.txt中进行配置:</p><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property"># ext</span><span class="token function">set</span><span class="token punctuation">(</span>BASE_INCLUDES ext<span class="token operator">/</span>includes<span class="token punctuation">)</span><span class="token function">set</span><span class="token punctuation">(</span>BASE_LIBS ext<span class="token operator">/</span>libs<span class="token punctuation">)</span><span class="token macro property"># googletest</span><span class="token function">set</span><span class="token punctuation">(</span>GTEST_INCLUDE_DIR $<span class="token punctuation">{</span>BASE_INCLUDES<span class="token punctuation">}</span><span class="token operator">/</span>gtest<span class="token operator">/</span>include<span class="token punctuation">)</span><span class="token function">set</span><span class="token punctuation">(</span>GMOCK_INCLUDE_DIR $<span class="token punctuation">{</span>BASE_INCLUDES<span class="token punctuation">}</span><span class="token operator">/</span>gmock<span class="token operator">/</span>include<span class="token punctuation">)</span><span class="token function">set</span><span class="token punctuation">(</span>GTEST_LINK_DIR $<span class="token punctuation">{</span>BASE_LIBS<span class="token punctuation">}</span><span class="token operator">/</span>gtest<span class="token operator">/</span>lib<span class="token operator">/</span><span class="token punctuation">)</span><span class="token function">set</span><span class="token punctuation">(</span>GMOCK_LINK_DIR $<span class="token punctuation">{</span>BASE_LIBS<span class="token punctuation">}</span><span class="token operator">/</span>gmock<span class="token operator">/</span>lib<span class="token operator">/</span><span class="token punctuation">)</span># 去哪里找头文件 相当于gcc<span class="token operator">/</span>clang 中的<span class="token operator">-</span><span class="token function">I</span><span class="token punctuation">(</span>i的大写字母<span class="token punctuation">)</span>参数<span class="token function">include_directories</span><span class="token punctuation">(</span>$<span class="token punctuation">{</span>GTEST_INCLUDE_DIR<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token function">include_directories</span><span class="token punctuation">(</span>$<span class="token punctuation">{</span>GMOCK_INCLUDE_DIR<span class="token punctuation">}</span><span class="token punctuation">)</span># 去哪里找库文件 <span class="token punctuation">.</span>so <span class="token punctuation">.</span>dll <span class="token punctuation">.</span>dylib 相当于gcc 中的<span class="token operator">-</span>L参数<span class="token function">link_directories</span><span class="token punctuation">(</span>$<span class="token punctuation">{</span>GTEST_LINK_DIR<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token function">link_directories</span><span class="token punctuation">(</span>$<span class="token punctuation">{</span>GMOCK_LINK_DIR<span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p>然后为每个test配上链接库即可.</p><p>例如,现在有个测试file,文件名为:了l1.cpp</p><p>那么在CmakeLists.txt中配置为:</p><pre class=" language-cpp"><code class="language-cpp"><span class="token function">add_executable</span><span class="token punctuation">(</span>l1 l1<span class="token punctuation">.</span>cpp<span class="token punctuation">)</span><span class="token function">target_link_libraries</span><span class="token punctuation">(</span>l1 gtest gtest_main<span class="token punctuation">)</span>  </code></pre><h2 id="2-gtest之Helloworld"><a href="#2-gtest之Helloworld" class="headerlink" title="2.gtest之Helloworld"></a>2.gtest之Helloworld</h2><pre><code>int main(int argc, char* argv[]){    // 接收命令行参数    testing::InitGoogleTest(&amp;argc, argv);    vector&lt;int&gt; x={1,2,3,5};    // EXPECT_EQ使用    for (int i = 0; i &lt; x.size(); ++i)    {        EXPECT_EQ(x[i], 1) &lt;&lt; "Vectors x and y differ at index " &lt;&lt; i;    }    RUN_ALL_TESTS();    return 0;}</code></pre><p>例如上述就是个完整的例子,每次运行:</p><pre><code>testing::InitGoogleTest(&amp;argc, argv);</code></pre><p>然后使用:</p><pre><code>RUN_ALL_TESTS();</code></pre><p>运行所有的Test,每个Test编写参考后面断言.</p><p>我们看看运行效果:</p><pre class=" language-cpp"><code class="language-cpp">l1<span class="token punctuation">.</span>cpp<span class="token operator">:</span><span class="token number">113</span><span class="token operator">:</span> FailureExpected equality of these values<span class="token operator">:</span>  x<span class="token punctuation">[</span>i<span class="token punctuation">]</span>    Which is<span class="token operator">:</span> <span class="token number">2</span>  <span class="token number">1</span>Vectors x <span class="token operator">and</span> y differ at index <span class="token number">1</span>l1<span class="token punctuation">.</span>cpp<span class="token operator">:</span><span class="token number">113</span><span class="token operator">:</span> FailureExpected equality of these values<span class="token operator">:</span>  x<span class="token punctuation">[</span>i<span class="token punctuation">]</span>    Which is<span class="token operator">:</span> <span class="token number">3</span>  <span class="token number">1</span>Vectors x <span class="token operator">and</span> y differ at index <span class="token number">2</span>l1<span class="token punctuation">.</span>cpp<span class="token operator">:</span><span class="token number">113</span><span class="token operator">:</span> FailureExpected equality of these values<span class="token operator">:</span>  x<span class="token punctuation">[</span>i<span class="token punctuation">]</span>    Which is<span class="token operator">:</span> <span class="token number">5</span>  <span class="token number">1</span>Vectors x <span class="token operator">and</span> y differ at index <span class="token number">3</span><span class="token punctuation">[</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token punctuation">]</span> Running <span class="token number">0</span> tests from <span class="token number">0</span> test cases<span class="token punctuation">.</span><span class="token punctuation">[</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token punctuation">]</span> <span class="token number">0</span> tests from <span class="token number">0</span> test cases ran<span class="token punctuation">.</span> <span class="token punctuation">(</span><span class="token number">0</span> ms total<span class="token punctuation">)</span><span class="token punctuation">[</span>  PASSED  <span class="token punctuation">]</span> <span class="token number">0</span> tests<span class="token punctuation">.</span><span class="token punctuation">[</span>  FAILED  <span class="token punctuation">]</span> <span class="token number">0</span> tests<span class="token punctuation">,</span> listed below<span class="token operator">:</span> <span class="token number">0</span> FAILED TESTS</code></pre><h2 id="2-gtest初识之断言"><a href="#2-gtest初识之断言" class="headerlink" title="2.gtest初识之断言"></a>2.gtest初识之断言</h2><p>关于断言Google包装了一系列<code>EXPECT</code>和<code>ASSERT</code>的宏，而EXPECT系列和ASSERT系列的区别是：</p><ul><li><code>EXPECT</code>  失败时，案例继续往下执行。</li><li><code>ASSERT</code> 失败时，直接在当前函数中返回，当前函数中<code>ASSERT</code>后面的语句将不会执行。</li></ul><p>例如:</p><pre class=" language-cpp"><code class="language-cpp"><span class="token function">TEST</span><span class="token punctuation">(</span>ASSERTTest<span class="token punctuation">,</span> ASSERT_VS_EXPECT<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">ASSERT_TRUE</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token operator">&lt;</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// ASSERT失败,直接在当前函数中返回,后面语句不执行</span>    <span class="token function">ASSERT_FALSE</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token operator">&lt;</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">EXPECT_EQ</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span> <span class="token function">Foo</span><span class="token punctuation">(</span><span class="token number">310</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>每个Test是个宏,Test底层源码如下:</p><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property"># <span class="token directive keyword">define</span> TEST(test_case_name, test_name) GTEST_TEST(test_case_name, test_name)</span></code></pre><p>对应test_case名与test名.</p><p>上述代码中10&lt;2为False,而使用了<code>ASSERT_TRUE</code>,该Test后面所有内容就不会执行,如果换成<code>EXPECT_TRUE</code>则正常运行!</p><blockquote><p> 布尔值检查</p></blockquote><table><thead><tr><th><strong>Fatal assertion</strong></th><th><strong>Nonfatal assertion</strong></th><th><strong>Verifies</strong></th></tr></thead><tbody><tr><td><code>ASSERT_TRUE(</code><em>condition</em><code>)</code>;</td><td><code>EXPECT_TRUE(</code><em>condition</em><code>)</code>;</td><td><em>condition</em> is true</td></tr><tr><td><code>ASSERT_FALSE(</code><em>condition</em><code>)</code>;</td><td><code>EXPECT_FALSE(</code><em>condition</em><code>)</code>;</td><td><em>condition</em> is false</td></tr></tbody></table><blockquote><p>数值型数据检查</p></blockquote><table><thead><tr><th><strong>Fatal assertion</strong></th><th><strong>Nonfatal assertion</strong></th><th><strong>Verifies</strong></th></tr></thead><tbody><tr><td><code>ASSERT_EQ(</code><em>expected</em><code>,</code><em>actual</em><code>);</code></td><td><code>EXPECT_EQ(</code><em>expected</em><code>,</code><em>actual</em><code>);</code></td><td><em>expected</em> <code>==</code> <em>actual</em></td></tr><tr><td><code>ASSERT_NE(</code><em>val1</em><code>,</code><em>val2</em><code>);</code></td><td><code>EXPECT_NE(</code><em>val1</em><code>,</code><em>val2</em><code>);</code></td><td><em>val1</em> <code>!=</code> <em>val2</em></td></tr><tr><td><code>ASSERT_LT(</code><em>val1</em><code>,</code><em>val2</em><code>);</code></td><td><code>EXPECT_LT(</code><em>val1</em><code>,</code><em>val2</em><code>);</code></td><td><em>val1</em> <code>&lt;</code> <em>val2</em></td></tr><tr><td><code>ASSERT_LE(</code><em>val1</em><code>,</code><em>val2</em><code>);</code></td><td><code>EXPECT_LE(</code><em>val1</em><code>,</code><em>val2</em><code>);</code></td><td><em>val1</em> <code>&lt;=</code> <em>val2</em></td></tr><tr><td><code>ASSERT_GT(</code><em>val1</em><code>,</code><em>val2</em><code>);</code></td><td><code>EXPECT_GT(</code><em>val1</em><code>,</code><em>val2</em><code>);</code></td><td><em>val1</em> <code>&gt;</code> <em>val2</em></td></tr><tr><td><code>ASSERT_GE(</code><em>val1</em><code>,</code><em>val2</em><code>);</code></td><td><code>EXPECT_GE(</code><em>val1</em><code>,</code><em>val2</em><code>);</code></td><td><em>val1</em> <code>&gt;=</code> <em>val2</em></td></tr></tbody></table><blockquote><p>字符串检查</p></blockquote><pre class=" language-cpp"><code class="language-cpp"><span class="token function">TEST</span><span class="token punctuation">(</span>StringCmpTest<span class="token punctuation">,</span> Demo<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">char</span><span class="token operator">*</span> pszCoderZh <span class="token operator">=</span> <span class="token string">"CoderZh"</span><span class="token punctuation">;</span>    <span class="token keyword">wchar_t</span><span class="token operator">*</span> wszCoderZh <span class="token operator">=</span> L<span class="token string">"CoderZh"</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>string strCoderZh <span class="token operator">=</span> <span class="token string">"CoderZh"</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>wstring wstrCoderZh <span class="token operator">=</span> L<span class="token string">"CoderZh"</span><span class="token punctuation">;</span>    <span class="token function">EXPECT_STREQ</span><span class="token punctuation">(</span><span class="token string">"CoderZh"</span><span class="token punctuation">,</span> pszCoderZh<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">EXPECT_STREQ</span><span class="token punctuation">(</span>L<span class="token string">"CoderZh"</span><span class="token punctuation">,</span> wszCoderZh<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">EXPECT_STRNE</span><span class="token punctuation">(</span><span class="token string">"CnBlogs"</span><span class="token punctuation">,</span> pszCoderZh<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">EXPECT_STRNE</span><span class="token punctuation">(</span>L<span class="token string">"CnBlogs"</span><span class="token punctuation">,</span> wszCoderZh<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">EXPECT_STRCASEEQ</span><span class="token punctuation">(</span><span class="token string">"coderzh"</span><span class="token punctuation">,</span> pszCoderZh<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//EXPECT_STRCASEEQ(L"coderzh", wszCoderZh);    不支持</span>    <span class="token function">EXPECT_STREQ</span><span class="token punctuation">(</span><span class="token string">"CoderZh"</span><span class="token punctuation">,</span> strCoderZh<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">EXPECT_STREQ</span><span class="token punctuation">(</span>L<span class="token string">"CoderZh"</span><span class="token punctuation">,</span> wstrCoderZh<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>其中STREQ和STRNE同时支持char<em>和wchar_t</em>类型的，<em>STRCASEEQ</em>和<em>STRCASENE</em>却只接收<code>char*</code></p><blockquote><p>显示返回成功或失败</p></blockquote><p>直接返回成功：<code>SUCCEED();</code></p><p>返回失败：</p><table><thead><tr><th><strong>Fatal assertion</strong></th><th><strong>Nonfatal assertion</strong></th></tr></thead><tbody><tr><td><code>FAIL();</code></td><td><code>ADD_FAILURE();</code></td></tr></tbody></table><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 返回成功与否</span><span class="token function">TEST</span><span class="token punctuation">(</span>ExplicitTest<span class="token punctuation">,</span> Demo<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">ADD_FAILURE</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"这行打印失败 Sorry"</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// None Fatal Asserton，继续往下执行。</span>    <span class="token comment" spellcheck="true">//FAIL(); // Fatal Assertion，不往下执行该案例。</span>    <span class="token function">EXPECT_TRUE</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">==</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span><span class="token string">"1==2 failed!"</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 为了验证上述失败后是否执行下面</span>    <span class="token function">SUCCEED</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><blockquote><p>异常检查</p></blockquote><p>分为三个:</p><p><code>EXPECT_NO_THROW(statement);</code>  不抛出异常</p><p><code>EXPECT_ANY_THROW(statement);</code>抛出任意类型异常</p><p><code>EXPECT_THROW(statement, exception_type);</code> 抛出指定类型异常</p><pre class=" language-cpp"><code class="language-cpp"><span class="token function">TEST</span><span class="token punctuation">(</span>ExceptionTest<span class="token punctuation">,</span>et<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 抛出任意类型异常</span>    <span class="token function">EXPECT_ANY_THROW</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token operator">/</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//Expected: 10/0 throws an exception.</span>    <span class="token comment" spellcheck="true">// 抛出指定类型异常</span>    <span class="token function">EXPECT_THROW</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">/</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//Expected: 1/0 throws an exception of type int.</span><span class="token punctuation">}</span></code></pre><blockquote><p>Predicate Assertions</p></blockquote><p>检查一个函数的返回值TRUE还是FALSE时，希望能够输出传入的参数是什么，以便失败后好跟踪</p><p>例如:</p><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 预测断言</span><span class="token keyword">bool</span> <span class="token function">MN</span><span class="token punctuation">(</span><span class="token keyword">int</span> m<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> m<span class="token operator">></span>n<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//检查一个函数的返回值TRUE还是FALSE时，希望能够输出传入的参数是什么，以便失败后好跟踪</span><span class="token function">TEST</span><span class="token punctuation">(</span>PredicateAssertionTest<span class="token punctuation">,</span> Demo<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> m <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">,</span> n <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span>    <span class="token function">EXPECT_PRED2</span><span class="token punctuation">(</span>MN<span class="token punctuation">,</span> m<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//只提供&lt;=5个参数  传递参数要与函数MN对应</span><span class="token punctuation">}</span></code></pre><p>``EXPECT_PRED2(pred2, val1, val2);`ASSERT类似.PRED2可以到PRED5</p><p>最多支持5个参数.</p><blockquote><p>浮点型检查</p></blockquote><p><code>EXPECT_FLOAT_EQ(expected, actual)</code>与<code>EXPECT_DOUBLE_EQ(expected, actual)</code></p><p>ASSERT类似.</p><p>对相近的两个数比较：</p><p><code>EXPECT_NEAR(val1, val2, abs_error);</code></p><p>ASSERT类似.</p><p>例如:</p><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 浮点型</span><span class="token function">TEST</span><span class="token punctuation">(</span>FloatDoubleTest<span class="token punctuation">,</span>Demo<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">ASSERT_DOUBLE_EQ</span><span class="token punctuation">(</span><span class="token number">1.1</span><span class="token punctuation">,</span><span class="token number">1.1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">EXPECT_FLOAT_EQ</span><span class="token punctuation">(</span><span class="token number">1.2</span><span class="token punctuation">,</span><span class="token number">4.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">EXPECT_NEAR</span><span class="token punctuation">(</span><span class="token number">1.234</span><span class="token punctuation">,</span><span class="token number">1.888</span><span class="token punctuation">,</span><span class="token number">0.9</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//    EXPECT_PRED_FORMAT2(testing::FloatLE, val1, val2);</span><span class="token comment" spellcheck="true">//    EXPECT_PRED_FORMAT2(testing::DoubleLE, val1, val2);</span>    <span class="token function">EXPECT_PRED_FORMAT2</span><span class="token punctuation">(</span>testing<span class="token operator">::</span>FloatLE<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// LE表示小于等于 也就是value1&lt;=value2</span>    <span class="token function">EXPECT_PRED_FORMAT2</span><span class="token punctuation">(</span>testing<span class="token operator">::</span>DoubleLE<span class="token punctuation">,</span><span class="token number">0.1</span><span class="token punctuation">,</span><span class="token number">0.2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><blockquote><p>类型检查</p></blockquote><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 类型检查</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">Tt</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        testing<span class="token operator">::</span>StaticAssertTypeEq<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token punctuation">,</span> T<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 与下面调用一致就不报错,否则报错</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token function">TEST</span><span class="token punctuation">(</span>TypeAssertionTest<span class="token punctuation">,</span> Demo<span class="token punctuation">)</span><span class="token punctuation">{</span>    Tt<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span> tt<span class="token punctuation">;</span>    tt<span class="token punctuation">.</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>学习参考自:<a href="https://www.cnblogs.com/coderzh/archive/2009/04/06/1430364.html" target="_blank" rel="noopener">https://www.cnblogs.com/coderzh/archive/2009/04/06/1430364.html</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 单元测试 </category>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> Googletest </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
