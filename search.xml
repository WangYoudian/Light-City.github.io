<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>C++ STL源码剖析之双向环形链表list</title>
      <link href="/2019/10/06/list/"/>
      <url>/2019/10/06/list/</url>
      
        <content type="html"><![CDATA[<h1 id="C-STL源码剖析之双向环形链表list"><a href="#C-STL源码剖析之双向环形链表list" class="headerlink" title="C++ STL源码剖析之双向环形链表list"></a>C++ STL源码剖析之双向环形链表list</h1><h2 id="0-导语"><a href="#0-导语" class="headerlink" title="0. 导语"></a>0. 导语</h2><p>源码对应的版本为<strong>gcc-4.9.1</strong></p><h3 id="1-list"><a href="#1-list" class="headerlink" title="1.list"></a>1.list</h3><p>list为双向环形链表，其结构为：</p><p><img src="http://pxz2lirgn.bkt.clouddn.com/list_1.png" alt=""></p><p>自己绘制的图如下：</p><p><img src="http://pxz2lirgn.bkt.clouddn.com/list_a.png" alt="list_all"></p><p>双向环状链表从节点值为3开始插入，红色框表示最后一个节点(end()指向的节点)。黄色线条表示指向前驱节点，黑色线条表示指向后继节点。</p><h3 id="1-1-list源码"><a href="#1-1-list源码" class="headerlink" title="1.1 list源码"></a>1.1 list源码</h3><h4 id="1-1-1-类结构"><a href="#1-1-1-类结构" class="headerlink" title="1.1.1 类结构"></a>1.1.1 类结构</h4><pre class=" language-c++"><code class="language-c++"> template<typename _Tp, typename _Alloc = std::allocator<_Tp> > class list : protected _List_base<_Tp, _Alloc>  { }</code></pre><p><code>list</code>继承<code>_List_base</code>。</p><h4 id="1-1-2-双向环形链表实现"><a href="#1-1-2-双向环形链表实现" class="headerlink" title="1.1.2 双向环形链表实现"></a>1.1.2 双向环形链表实现</h4><p>【<strong>构造函数</strong>】</p><p><strong>（1）不带任何元素的list</strong></p><pre class=" language-c++"><code class="language-c++">explicitlist(const allocator_type &__a) _GLIBCXX_NOEXCEPT: _Base(_Node_alloc_type(__a)) {}</code></pre><p><strong>（2）带n个元素且赋予初值的list</strong></p><pre class=" language-c++"><code class="language-c++">explicit list(size_type __n, const value_type &__value = value_type(),const allocator_type &__a = allocator_type()) : _Base(_Node_alloc_type(__a)) { _M_fill_initialize(__n, __value); }</code></pre><p><strong>（3）从一个范围中进行初始化list</strong></p><pre class=" language-c++"><code class="language-c++">template<typename _InputIterator>list(_InputIterator __first, _InputIterator __last,     const allocator_type &__a = allocator_type())        : _Base(_Node_alloc_type(__a)) {    // Check whether it's an integral type.  If so, it's not an iterator.    typedef typename std::__is_integer<_InputIterator>::__type _Integral;    _M_initialize_dispatch(__first, __last, _Integral());}</code></pre><p>【<strong>创建节点</strong>】</p><p>做的事情：创建一个新的节点并动态分配内存，返回节点。</p><pre class=" language-c++"><code class="language-c++">_Node *_M_create_node(const value_type &__x) {    _Node *__p = this->_M_get_node();    __try    {        _M_get_Tp_allocator().construct                (std::__addressof(__p->_M_data), __x);    }    __catch(...)    {        _M_put_node(__p);        __throw_exception_again;    }    return __p;}</code></pre><p>注意到里面有两个重要的函数<code>_M_get_node</code>与<code>_M_put_node</code>，我们来查看后发现这些方法来自基类，源码为：</p><pre class=" language-c++"><code class="language-c++">_List_node<_Tp> * _M_get_node() { return _M_impl._Node_alloc_type::allocate(1); }void _M_put_node(_List_node<_Tp> *__p)   _GLIBCXX_NOEXCEPT{ _M_impl._Node_alloc_type::deallocate(__p, 1); }</code></pre><p>对应的就是创建节点动态分配内存，若创建过程中抛出异常，则释放内存。</p><p>【<strong>插入节点</strong>】</p><p>插入节点包括：</p><ul><li>尾部插入n个指定节点值的节点，对应的函数<code>_M_fill_initialize</code></li></ul><p>在list的构造函数中使用：</p><pre class=" language-c++"><code class="language-c++">explicit list(size_type __n, const value_type &__value = value_type(),const allocator_type &__a = allocator_type()) : _Base(_Node_alloc_type(__a)) { _M_fill_initialize(__n, __value); }</code></pre><ul><li>指定位置插入指定节点值的节点，对应的函数<code>_M_insert</code></li></ul><p>其中大家经常使用的<code>push_back</code>与<code>push_front</code>底层就是调用<code>_M_insert</code>函数。</p><p>两者函数区别是：</p><pre class=" language-c++"><code class="language-c++">this->_M_insert(end(), __x);  // push_back   尾部插入  this->_M_insert(begin(), __x); // push_front 头部插入</code></pre><ul><li><strong>双向环形链表插入函数</strong><code>_M_hook</code>   <strong>(最重要！！！)</strong></li></ul><p>像前面提到的<code>push_back</code>、<code>push_front</code>、<code>_M_insert</code>，还有<code>insert</code>都是使用最基础的双向链表插入函数<code>_M_hook</code>实现的。</p><p><strong>下面来深入研究一下：</strong></p><p>其中<code>_M_fill_initialize</code>源码如下：</p><pre class=" language-c++"><code class="language-c++">void _M_fill_initialize(size_type __n, const value_type &__x) {    for (; __n; --__n)        push_back(__x);}</code></pre><p>其中<code>push_back</code>源码如下：</p><pre class=" language-c++"><code class="language-c++">void push_back(const value_type &__x) { this->_M_insert(end(), __x); }</code></pre><p>其中<code>_M_insert</code>，在指定的位置插入初始值为x的节点。</p><pre class=" language-c++"><code class="language-c++">void _M_insert(iterator __position, const value_type &__x) {    _Node *__tmp = _M_create_node(__x);    __tmp->_M_hook(__position._M_node);}</code></pre><p>其中<code>_M_hook</code>实现在<code>gcc-4.9.1/libstdc++-v3/src/c++98/list.cc</code>中,当然<code>_List_node_base</code>的其他函数，例如：<code>_M_unhook</code>也在这个文件中。</p><pre class=" language-c++"><code class="language-c++">// 在指定的位置前插入this指向的节点void_List_node_base::_M_hook(_List_node_base* const __position) _GLIBCXX_USE_NOEXCEPT{  this->_M_next = __position;          this->_M_prev = __position->_M_prev;  __position->_M_prev->_M_next = this;  __position->_M_prev = this;}</code></pre><p>所以上述细分为两个函数：我们把上述代码进行总结：</p><p>（1）在指定的位置插入初始值为x的节点</p><pre class=" language-c++"><code class="language-c++">void _M_insert(iterator __position, const value_type &__x) {    _Node *__tmp = _M_create_node(__x);    __tmp->_M_next = __position;            // 第一步    __tmp->_M_prev = __position->_M_prev;    // 第二步    __position->_M_prev->_M_next = __tmp;    // 第三步    __position->_M_prev = __tmp;            // 第四步}</code></pre><p>这种插入是在指定位置前插入，(对应到代码就是)例如实现在指定<code>__position</code>节点为7前插入节点值9的节点(对应到代码就是__tmp)，下面阐述了具体的插入流程。</p><p><img src="http://pxz2lirgn.bkt.clouddn.com/list_insert.png" alt="list_insert"></p><p>（2）在末尾依次插入n个节点值为x的节点</p><pre class=" language-c++"><code class="language-c++">void _M_fill_initialize(size_type __n, const value_type &__x) {    for (; __n; --__n)        _M_insert(end(), __x);}</code></pre><p>对于上述的代码大家或许会联想到<code>insert</code>,它有三个。<code>insert</code>实现文件在<code>libstdc++-v3/include/bits/list.tcc</code>。</p><ul><li><strong>第一：在指定迭代器之前插入指定元素值节点。</strong></li></ul><p>实现是调用前面的<code>_M_hook</code>函数。</p><pre class=" language-c++"><code class="language-c++">template<typename _Tp, typename _Alloc>typename list<_Tp, _Alloc>::iteratorlist<_Tp, _Alloc>::#if __cplusplus >= 201103Linsert(const_iterator __position, const value_type& __x)#elseinsert(iterator __position, const value_type& __x)#endif{  _Node* __tmp = _M_create_node(__x);  __tmp->_M_hook(__position._M_const_cast()._M_node);  return iterator(__tmp);}</code></pre><ul><li><strong>第二：在指定迭代器之前插入n个指定节点值的节点。</strong></li></ul><pre class=" language-c++"><code class="language-c++">void insert(iterator __position, size_type __n, const value_type &__x) {    list __tmp(__n, __x, get_allocator());    splice(__position, __tmp);}</code></pre><p>实现是先调用list构造函数，完成创建一个拥有n个指定节点值的list。</p><pre class=" language-c++"><code class="language-c++">explicit list(size_type __n, const value_type &__value = value_type(),const allocator_type &__a = allocator_type()) : _Base(_Node_alloc_type(__a)) { _M_fill_initialize(__n, __value); }</code></pre><p>然后使用<code>splice</code>函数完成从另一个list中来插入当前list。</p><pre class=" language-c++"><code class="language-c++">void splice(iterator __position, list &__x){    if (!__x.empty()) {        _M_check_equal_allocators(__x);        this->_M_transfer(__position._M_const_cast(),                          __x.begin(), __x.end());    }}</code></pre><p>其中<code>_M_transfer</code>追踪代码，可以知道：</p><pre class=" language-c++"><code class="language-c++">// Moves the elements from [first,last) before position.void_M_transfer(iterator __position, iterator __first, iterator __last) {    __position._M_node->_M_transfer(__first._M_node, __last._M_node);}</code></pre><p>再次分析得到其来自list的基类<code>_List_node_base</code>，而<code>_M_transfer</code>实现文件在<code>gcc-4.9.1/libstdc++-v3/src/c++98/list.cc</code>中：</p><pre class=" language-c++"><code class="language-c++">void _List_node_base::_M_transfer(_List_node_base * const __first,    _List_node_base * const __last) _GLIBCXX_USE_NOEXCEPT{  if (this != __last)  {      // Remove [first, last) from its old position.      __last->_M_prev->_M_next  = this;      __first->_M_prev->_M_next = __last;      this->_M_prev->_M_next    = __first;      // Splice [first, last) into its new position.      _List_node_base* const __tmp = this->_M_prev;      this->_M_prev                = __last->_M_prev;      __last->_M_prev              = __first->_M_prev;      __first->_M_prev             = __tmp;  }}</code></pre><p>仍然是上述的图：</p><p><img src="http://pxz2lirgn.bkt.clouddn.com/list_a.png" alt="list_all"></p><p>经过前面分析，我们知道<code>splice</code>是将上述图的所代表的整个list插入指定迭代器前面，例如，我们想要在下面两个节点前面插入，具体图形步骤如下：</p><p><code>this</code>代表的节点为值为8的节点，下图描述的就是在节点10与节点8中间插入整个list。</p><p><code>__last</code>代表的是红色框节点，该节点为<code>end()</code>指向的节点，我们是不需要该节点的，所以在后面处理中，会把该节点从整个list中去除掉。</p><p><code>__first</code>代表的是图中节点值为3的节点。</p><p><strong>第一步：先将最后一个有效节点，也就是红色框的前一个节点的next指针指向指定的节点8。</strong></p><p><img src="http://pxz2lirgn.bkt.clouddn.com/step1.png" alt=""></p><p>对应代码为：</p><pre><code>__last-&gt;_M_prev-&gt;_M_next  = this;    </code></pre><p><strong>第二步：<code>_last</code>的next指针指向自己。</strong></p><p><img src="http://pxz2lirgn.bkt.clouddn.com/step2.png" alt=""></p><p>对应的代码为：</p><pre><code>__first-&gt;_M_prev-&gt;_M_next = __last;</code></pre><p><strong>第三步：让指定迭代器之前的节点的nex指向原先list的第一个节点(<code>__first</code>)。</strong></p><p><img src="http://pxz2lirgn.bkt.clouddn.com/step3.png" alt=""></p><p>对应的代码为：</p><pre><code>this-&gt;_M_prev-&gt;_M_next    = __first;</code></pre><p><strong>第四步：保存指定迭代器的前驱节点(对应到哪图中的节点值为10的节点)。</strong></p><pre><code>_List_node_base* const __tmp = this-&gt;_M_prev;</code></pre><p><strong>第五步：指定迭代器的前驱节点指向原list中实际最后一个节点(end()前一节点)。</strong></p><p><img src="http://pxz2lirgn.bkt.clouddn.com/step5.png" alt=""></p><p>对应的代码为：</p><pre><code>this-&gt;_M_prev                = __last-&gt;_M_prev;</code></pre><p><strong>第六步：让原list的最后一个节点(end()指向的节点)的prev指向自己。</strong></p><p><img src="http://pxz2lirgn.bkt.clouddn.com/step6.png" alt=""></p><p>对应的代码为：</p><pre><code>__last-&gt;_M_prev              = __first-&gt;_M_prev;</code></pre><p><strong>第七步：让原list第一个节点的prev指向第四步保存的节点。</strong></p><p><img src="http://pxz2lirgn.bkt.clouddn.com/step7.png" alt=""></p><p>对应的代码为：</p><pre><code>__first-&gt;_M_prev             = __tmp;</code></pre><p>这样经过以上七步操作，完成了在节点8与节点10之前插入一个list。</p><ul><li><strong>第三：从一个list范围把数据插入到指定迭代器前面。</strong></li></ul><pre class=" language-c++"><code class="language-c++">template<typename _InputIterator>voidinsert(iterator __position, _InputIterator __first,       _InputIterator __last) {    list __tmp(__first, __last, get_allocator());    splice(__position, __tmp);}</code></pre><p>原理同上，只不过这个<code>__tmp</code>是调用另外一个构造函数。</p><p>【<strong>删除节点</strong>】</p><ul><li>删除指定节点</li></ul><p>删除指定节点分为两个，第一个通过迭代器删除，第二个是通过元素值删除。</p><p><strong>（1）通过迭代器删除，对应函数为erase</strong></p><p>其中<code>pop_front</code>与<code>pop_back</code>、<code>erase</code>、<code>remove</code>底层实现基于<code>_M_erase</code>函数。</p><pre class=" language-c++"><code class="language-c++">this->_M_erase(begin());     // pop_front 不断删除起点的元素this->_M_erase(iterator(this->_M_impl._M_node._M_prev)); // pop_back移除最后一个元素</code></pre><p>在<code>libstdc++-v3/include/bits/list.tcc</code>中：</p><pre class=" language-c++"><code class="language-c++">erase(iterator __position)#endif{  iterator __ret = iterator(__position._M_node->_M_next);  _M_erase(__position._M_const_cast());  return __ret;}</code></pre><p><strong>（2）通过元素值删除，对应函数为remove</strong></p><p>特殊情况处理，当删除元素的地址与迭代器的地址一样的时候，先保存起来，最后判断保存的迭代器是不是end()，如果不是，就删除掉。底层仍旧是通过<code>_M_erase</code>删除。</p><pre class=" language-c++"><code class="language-c++">template<typename _Tp, typename _Alloc>void list<_Tp, _Alloc>::remove(const value_type& __value){  iterator __first = begin();  iterator __last = end();  iterator __extra = __last;  while (__first != __last)  {      iterator __next = __first;      ++__next;      if (*__first == __value)        {          // _GLIBCXX_RESOLVE_LIB_DEFECTS          // 526. Is it undefined if a function in the standard changes          // in parameters?          if (std::__addressof(*__first) != std::__addressof(__value))        _M_erase(__first);          else        __extra = __first;        }      __first = __next;  }  if (__extra != __last)    _M_erase(__extra);}</code></pre><p>除了这个remove外，还有一个是<code>remove_if</code>，根据条件来删除。</p><pre class=" language-c++"><code class="language-c++">template<typename _Tp, typename _Alloc>template <typename _Predicate>void list<_Tp, _Alloc>::remove_if(_Predicate __pred){    iterator __first = begin();    iterator __last = end();    while (__first != __last)    {        iterator __next = __first;        ++__next;        if (__pred(*__first))          _M_erase(__first);        __first = __next;    }}</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> STL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C/C++多线程编程基础</title>
      <link href="/2019/09/24/duo-jin-cheng-yu-duo-xian-cheng-ji-chu/"/>
      <url>/2019/09/24/duo-jin-cheng-yu-duo-xian-cheng-ji-chu/</url>
      
        <content type="html"><![CDATA[<h1 id="C-C-多线程编程基础"><a href="#C-C-多线程编程基础" class="headerlink" title="C/C++多线程编程基础"></a>C/C++多线程编程基础</h1><h2 id="1-基础问题"><a href="#1-基础问题" class="headerlink" title="1.基础问题"></a>1.基础问题</h2><ul><li><strong>某个线程崩溃，会导致进程退出吗?或者说进程中某个线程崩溃，是否会对其他线程造成影响？</strong></li></ul><p>答：一般来说，每个线程都是独立执行的单位，每个线程都有自己的上下文堆栈，一个线程的的崩溃不会对其他线程造成影响。但是通常情况下，一个线程崩溃会产生一个进程内的错误，例如，在 Linux 操作系统中，可能会产生一个 <strong>Segment Fault</strong> 错误，这个错误会产生一个信号，操作系统默认对这个信号的处理就是结束进程，整个进程都被销毁了，这样的话这个进程中存在的其他线程自然也就不存在了。</p><ul><li><strong>排查 Linux 进程 CPU 使用率过高问题？</strong></li></ul><p>在实际开发中，有时候由于我们的程序逻辑不当问题，会导致某个线程<strong>空转</strong>（如无限空循环），进而引起该进程占用 CPU 使用率过高。这不仅会造成我们的系统卡顿，也是对 CPU 资源的一种浪费。那如何定位和排查引起 CPU 使用率过高的线程呢？</p><p>在 Linux 下我们可以综合使用 pstack 和 top 命令来排查此类问题。</p><h2 id="2-基础命令"><a href="#2-基础命令" class="headerlink" title="2.基础命令"></a>2.基础命令</h2><ul><li>pstack</li></ul><p>Linux 系统中可以通过 <strong>pstack</strong> 来命令查看一个进程的线程数量和每个线程的调用堆栈情况。</p><pre><code>pstack pid</code></pre><p><strong>pid</strong> 设置为要查看的进程的 id 即可。</p><ul><li>top</li></ul><p>可以查看cpu高的进程，找到占用cpu最大的进程号，然后使用：</p><pre><code>top -p pid</code></pre><p>观察指定pid的CPU和内存以及负载情况。</p><p>现在有如下信息：</p><pre><code>top - 19:30:05 up  6:15,  1 user,  load average: 0.85, 0.71, 0.61Tasks:   1 total,   0 running,   1 sleeping,   0 stopped,   0 zombie%Cpu(s):  8.1 us,  2.9 sy,  0.0 ni, 87.8 id,  0.0 wa,  0.0 hi,  1.1 si,  0.0 stKiB Mem : 20412976 total, 10960136 free,  5416592 used,  4036248 buff/cacheKiB Swap:  2097148 total,  2097148 free,        0 used. 14315608 avail Mem </code></pre><p><strong>第一行是任务队列信息</strong></p><table><thead><tr><th align="center">任务队列信息</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">9:30:05</td><td align="center">当前时间</td></tr><tr><td align="center">6:15 min</td><td align="center">用户在线时间</td></tr><tr><td align="center">1users</td><td align="center">在线用户数</td></tr><tr><td align="center">load average: 0.85, 0.71, 0.61</td><td align="center">系统负载，即任务队列的平均长度。1分钟前、5分钟前、15分钟前平均负载</td></tr></tbody></table><p><strong>第二行为进程的信息</strong></p><table><thead><tr><th align="center">进程信息</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">Tasks: 1 total</td><td align="center">进程总数</td></tr><tr><td align="center">0 running</td><td align="center">正在运行的进程数</td></tr><tr><td align="center">1 sleeping</td><td align="center">睡眠的进程数</td></tr><tr><td align="center">0 stopped</td><td align="center">停止的进程数</td></tr><tr><td align="center">0 zombie</td><td align="center">僵尸进程数</td></tr></tbody></table><p><strong>第三行为cpu信息</strong></p><table><thead><tr><th align="center">cpu信息</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">8.1 us</td><td align="center">用户空间占用CPU百分比</td></tr><tr><td align="center">2.9% sy</td><td align="center">内核空间占用CPU百分比</td></tr><tr><td align="center">0.0% ni</td><td align="center">用户进程空间内改变过优先级的进程占用CPU百分比</td></tr><tr><td align="center">87.8% id</td><td align="center">空闲CPU百分比</td></tr><tr><td align="center">0.0% wa</td><td align="center">等待输入输出的CPU时间百分比</td></tr><tr><td align="center">0.0% hi</td><td align="center">硬件中断</td></tr><tr><td align="center">1.1% si</td><td align="center">软件中断</td></tr><tr><td align="center">0.0%st</td><td align="center">实时</td></tr></tbody></table><p><strong>第四、五行为内存信息。</strong></p><table><thead><tr><th align="center">物理内存信息</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">Mem: 20412976 total</td><td align="center">物理内存总量</td></tr><tr><td align="center">5416592 used</td><td align="center">使用的物理内存总量</td></tr><tr><td align="center">10960136 free</td><td align="center">空闲内存总量</td></tr><tr><td align="center">4036248 buffers/cache</td><td align="center">用作内核缓存的内存量</td></tr></tbody></table><table><thead><tr><th align="center">交换区信息</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">Swap: 2097148 total</td><td align="center">交换区总量</td></tr><tr><td align="center">0k used</td><td align="center">使用的交换区总量</td></tr><tr><td align="center">2097148 free</td><td align="center">空闲交换区总量</td></tr><tr><td align="center">14315608 cached</td><td align="center">缓冲的交换区总量</td></tr></tbody></table><p>那如何通过top命令定位问题进程中每个线程占用cpu情况？</p><p>使用<code>-H</code>,top 命令的 -H 选项的作用是显示每个一个进程的各个线程运行状态（线程模式）。</p><p>例如：</p><pre><code>top -p 2085 -H</code></pre><p><img src="http://pxz2lirgn.bkt.clouddn.com/top.png" alt=""></p><p>由上图明显可以发现，线程PID 2085 CPU占用率最高，接下来定位该线程的代码是否出现异常导致cpu占用过高。</p><p>结合上述的pstack，例如：</p><pre><code>pstack 2085</code></pre><p>在 pstack 输出的各个线程中，只要逐一对照我们的程序源码来梳理下该线程中是否有大多数时间都处于空转的逻辑，然后修改和优化这些逻辑就可以解决 CPU 使用率过高的问题了，一般情况下，不工作的线程应尽量使用锁对象让其挂起，而不是空转，这样可以提高系统资源利用率。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> C </category>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 项目之Googletest单元测试</title>
      <link href="/2019/09/17/googletest-1/"/>
      <url>/2019/09/17/googletest-1/</url>
      
        <content type="html"><![CDATA[<h1 id="C-项目之Googletest单元测试"><a href="#C-项目之Googletest单元测试" class="headerlink" title="C++ 项目之Googletest单元测试"></a>C++ 项目之Googletest单元测试</h1><h2 id="1-Clion集成Googletest单元测试"><a href="#1-Clion集成Googletest单元测试" class="headerlink" title="1.Clion集成Googletest单元测试"></a>1.Clion集成Googletest单元测试</h2><p>Googletest - Google Testing and Mocking Framework</p><p>源码下载地址:</p><blockquote><p><a href="https://github.com/google/googletest/releases" target="_blank" rel="noopener">https://github.com/google/googletest/releases</a></p></blockquote><p>Googletest中包含两个模块,分别是gtest与gmock,需要分别源码编译,编译完后,到指定目录去拷贝includes文件夹与.so文件到下面路径的指定位置.</p><p>然后项目中创建ext目录,里面分为两块</p><ul><li>第一块:includes</li></ul><p>包含gmock与gtest的include文件,对应于gcc -I参数,头文件路径,包含以.h结尾的头文件</p><ul><li>第二块:libs</li></ul><p>包含gmock与gtest的libs文件,对应gcc -L参数,库文件路径,里面包含的是一些.so或.dll等动态或静态链接库</p><pre class=" language-c++"><code class="language-c++">├── ext│   ├── includes│   │   ├── gmock│   │   └── gtest│   └── libs│       ├── gmock│       └── gtest</code></pre><p>上述本地项目路径配置好后,在CmakeLists.txt中进行配置:</p><pre class=" language-c++"><code class="language-c++"># extset(BASE_INCLUDES ext/includes)set(BASE_LIBS ext/libs)# googletestset(GTEST_INCLUDE_DIR ${BASE_INCLUDES}/gtest/include)set(GMOCK_INCLUDE_DIR ${BASE_INCLUDES}/gmock/include)set(GTEST_LINK_DIR ${BASE_LIBS}/gtest/lib/)set(GMOCK_LINK_DIR ${BASE_LIBS}/gmock/lib/)# 去哪里找头文件 相当于gcc/clang 中的-I(i的大写字母)参数include_directories(${GTEST_INCLUDE_DIR})include_directories(${GMOCK_INCLUDE_DIR})# 去哪里找库文件 .so .dll .dylib 相当于gcc 中的-L参数link_directories(${GTEST_LINK_DIR})link_directories(${GMOCK_LINK_DIR})</code></pre><p>然后为每个test配上链接库即可.</p><p>例如,现在有个测试file,文件名为:了l1.cpp</p><p>那么在CmakeLists.txt中配置为:</p><pre class=" language-c++"><code class="language-c++">add_executable(l1 l1.cpp)target_link_libraries(l1 gtest gtest_main)  </code></pre><h2 id="2-gtest之Helloworld"><a href="#2-gtest之Helloworld" class="headerlink" title="2.gtest之Helloworld"></a>2.gtest之Helloworld</h2><pre><code>int main(int argc, char* argv[]){    // 接收命令行参数    testing::InitGoogleTest(&amp;argc, argv);    vector&lt;int&gt; x={1,2,3,5};    // EXPECT_EQ使用    for (int i = 0; i &lt; x.size(); ++i)    {        EXPECT_EQ(x[i], 1) &lt;&lt; "Vectors x and y differ at index " &lt;&lt; i;    }    RUN_ALL_TESTS();    return 0;}</code></pre><p>例如上述就是个完整的例子,每次运行:</p><pre><code>testing::InitGoogleTest(&amp;argc, argv);</code></pre><p>然后使用:</p><pre><code>RUN_ALL_TESTS();</code></pre><p>运行所有的Test,每个Test编写参考后面断言.</p><p>我们看看运行效果:</p><pre class=" language-c++"><code class="language-c++">l1.cpp:113: FailureExpected equality of these values:  x[i]    Which is: 2  1Vectors x and y differ at index 1l1.cpp:113: FailureExpected equality of these values:  x[i]    Which is: 3  1Vectors x and y differ at index 2l1.cpp:113: FailureExpected equality of these values:  x[i]    Which is: 5  1Vectors x and y differ at index 3[==========] Running 0 tests from 0 test cases.[==========] 0 tests from 0 test cases ran. (0 ms total)[  PASSED  ] 0 tests.[  FAILED  ] 0 tests, listed below: 0 FAILED TESTS</code></pre><h2 id="2-gtest初识之断言"><a href="#2-gtest初识之断言" class="headerlink" title="2.gtest初识之断言"></a>2.gtest初识之断言</h2><p>关于断言Google包装了一系列<code>EXPECT</code>和<code>ASSERT</code>的宏，而EXPECT系列和ASSERT系列的区别是：</p><ul><li><code>EXPECT</code>  失败时，案例继续往下执行。</li><li><code>ASSERT</code> 失败时，直接在当前函数中返回，当前函数中<code>ASSERT</code>后面的语句将不会执行。</li></ul><p>例如:</p><pre class=" language-c++"><code class="language-c++">TEST(ASSERTTest, ASSERT_VS_EXPECT){    ASSERT_TRUE(10<2);  // ASSERT失败,直接在当前函数中返回,后面语句不执行    ASSERT_FALSE(10<2);    EXPECT_EQ(6, Foo(310, 18));}</code></pre><p>每个Test是个宏,Test底层源码如下:</p><pre class=" language-c++"><code class="language-c++"># define TEST(test_case_name, test_name) GTEST_TEST(test_case_name, test_name)</code></pre><p>对应test_case名与test名.</p><p>上述代码中10&lt;2为False,而使用了<code>ASSERT_TRUE</code>,该Test后面所有内容就不会执行,如果换成<code>EXPECT_TRUE</code>则正常运行!</p><blockquote><p> 布尔值检查</p></blockquote><table><thead><tr><th><strong>Fatal assertion</strong></th><th><strong>Nonfatal assertion</strong></th><th><strong>Verifies</strong></th></tr></thead><tbody><tr><td><code>ASSERT_TRUE(</code><em>condition</em><code>)</code>;</td><td><code>EXPECT_TRUE(</code><em>condition</em><code>)</code>;</td><td><em>condition</em> is true</td></tr><tr><td><code>ASSERT_FALSE(</code><em>condition</em><code>)</code>;</td><td><code>EXPECT_FALSE(</code><em>condition</em><code>)</code>;</td><td><em>condition</em> is false</td></tr></tbody></table><blockquote><p>数值型数据检查</p></blockquote><table><thead><tr><th><strong>Fatal assertion</strong></th><th><strong>Nonfatal assertion</strong></th><th><strong>Verifies</strong></th></tr></thead><tbody><tr><td><code>ASSERT_EQ(</code><em>expected</em><code>,</code><em>actual</em><code>);</code></td><td><code>EXPECT_EQ(</code><em>expected</em><code>,</code><em>actual</em><code>);</code></td><td><em>expected</em> <code>==</code> <em>actual</em></td></tr><tr><td><code>ASSERT_NE(</code><em>val1</em><code>,</code><em>val2</em><code>);</code></td><td><code>EXPECT_NE(</code><em>val1</em><code>,</code><em>val2</em><code>);</code></td><td><em>val1</em> <code>!=</code> <em>val2</em></td></tr><tr><td><code>ASSERT_LT(</code><em>val1</em><code>,</code><em>val2</em><code>);</code></td><td><code>EXPECT_LT(</code><em>val1</em><code>,</code><em>val2</em><code>);</code></td><td><em>val1</em> <code>&lt;</code> <em>val2</em></td></tr><tr><td><code>ASSERT_LE(</code><em>val1</em><code>,</code><em>val2</em><code>);</code></td><td><code>EXPECT_LE(</code><em>val1</em><code>,</code><em>val2</em><code>);</code></td><td><em>val1</em> <code>&lt;=</code> <em>val2</em></td></tr><tr><td><code>ASSERT_GT(</code><em>val1</em><code>,</code><em>val2</em><code>);</code></td><td><code>EXPECT_GT(</code><em>val1</em><code>,</code><em>val2</em><code>);</code></td><td><em>val1</em> <code>&gt;</code> <em>val2</em></td></tr><tr><td><code>ASSERT_GE(</code><em>val1</em><code>,</code><em>val2</em><code>);</code></td><td><code>EXPECT_GE(</code><em>val1</em><code>,</code><em>val2</em><code>);</code></td><td><em>val1</em> <code>&gt;=</code> <em>val2</em></td></tr></tbody></table><blockquote><p>字符串检查</p></blockquote><pre class=" language-c++"><code class="language-c++">TEST(StringCmpTest, Demo){    char* pszCoderZh = "CoderZh";    wchar_t* wszCoderZh = L"CoderZh";    std::string strCoderZh = "CoderZh";    std::wstring wstrCoderZh = L"CoderZh";    EXPECT_STREQ("CoderZh", pszCoderZh);    EXPECT_STREQ(L"CoderZh", wszCoderZh);    EXPECT_STRNE("CnBlogs", pszCoderZh);    EXPECT_STRNE(L"CnBlogs", wszCoderZh);    EXPECT_STRCASEEQ("coderzh", pszCoderZh);    //EXPECT_STRCASEEQ(L"coderzh", wszCoderZh);    不支持    EXPECT_STREQ("CoderZh", strCoderZh.c_str());    EXPECT_STREQ(L"CoderZh", wstrCoderZh.c_str());}</code></pre><p>其中STREQ和STRNE同时支持char<em>和wchar_t</em>类型的，<em>STRCASEEQ</em>和<em>STRCASENE</em>却只接收<code>char*</code></p><blockquote><p>显示返回成功或失败</p></blockquote><p>直接返回成功：<code>SUCCEED();</code></p><p>返回失败：</p><table><thead><tr><th><strong>Fatal assertion</strong></th><th><strong>Nonfatal assertion</strong></th></tr></thead><tbody><tr><td><code>FAIL();</code></td><td><code>ADD_FAILURE();</code></td></tr></tbody></table><pre class=" language-c++"><code class="language-c++">// 返回成功与否TEST(ExplicitTest, Demo){    ADD_FAILURE() << "这行打印失败 Sorry"; // None Fatal Asserton，继续往下执行。    //FAIL(); // Fatal Assertion，不往下执行该案例。    EXPECT_TRUE(1==2)<<"1==2 failed!";      // 为了验证上述失败后是否执行下面    SUCCEED();}</code></pre><blockquote><p>异常检查</p></blockquote><p>分为三个:</p><p><code>EXPECT_NO_THROW(statement);</code>  不抛出异常</p><p><code>EXPECT_ANY_THROW(statement);</code>抛出任意类型异常</p><p><code>EXPECT_THROW(statement, exception_type);</code> 抛出指定类型异常</p><pre class=" language-c++"><code class="language-c++">TEST(ExceptionTest,et) {    // 抛出任意类型异常    EXPECT_ANY_THROW(10/0); //Expected: 10/0 throws an exception.    // 抛出指定类型异常    EXPECT_THROW(1/0,int); //Expected: 1/0 throws an exception of type int.}</code></pre><blockquote><p>Predicate Assertions</p></blockquote><p>检查一个函数的返回值TRUE还是FALSE时，希望能够输出传入的参数是什么，以便失败后好跟踪</p><p>例如:</p><pre class=" language-c++"><code class="language-c++">// 预测断言bool MN(int m, int n){    return m>n;}//检查一个函数的返回值TRUE还是FALSE时，希望能够输出传入的参数是什么，以便失败后好跟踪TEST(PredicateAssertionTest, Demo){    int m = 5, n = 6;    EXPECT_PRED2(MN, m, n); //只提供<=5个参数  传递参数要与函数MN对应}</code></pre><p>``EXPECT_PRED2(pred2, val1, val2);`ASSERT类似.PRED2可以到PRED5</p><p>最多支持5个参数.</p><blockquote><p>浮点型检查</p></blockquote><p><code>EXPECT_FLOAT_EQ(expected, actual)</code>与<code>EXPECT_DOUBLE_EQ(expected, actual)</code></p><p>ASSERT类似.</p><p>对相近的两个数比较：</p><p><code>EXPECT_NEAR(val1, val2, abs_error);</code></p><p>ASSERT类似.</p><p>例如:</p><pre class=" language-c++"><code class="language-c++">// 浮点型TEST(FloatDoubleTest,Demo) {    ASSERT_DOUBLE_EQ(1.1,1.1);    EXPECT_FLOAT_EQ(1.2,4.0);    EXPECT_NEAR(1.234,1.888,0.9);//    EXPECT_PRED_FORMAT2(testing::FloatLE, val1, val2);//    EXPECT_PRED_FORMAT2(testing::DoubleLE, val1, val2);    EXPECT_PRED_FORMAT2(testing::FloatLE,1,0);      // LE表示小于等于 也就是value1<=value2    EXPECT_PRED_FORMAT2(testing::DoubleLE,0.1,0.2);}</code></pre><blockquote><p>类型检查</p></blockquote><pre class=" language-c++"><code class="language-c++">// 类型检查template <typename T>class Tt{public:    void foo() {        testing::StaticAssertTypeEq<bool, T>();     // 与下面调用一致就不报错,否则报错    }};TEST(TypeAssertionTest, Demo){    Tt<bool> tt;    tt.foo();}</code></pre><p>学习参考自:<a href="https://www.cnblogs.com/coderzh/archive/2009/04/06/1430364.html" target="_blank" rel="noopener">https://www.cnblogs.com/coderzh/archive/2009/04/06/1430364.html</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 单元测试 </category>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> Googletest </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
